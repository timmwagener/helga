//     AdvancedSkeleton
//     Version 3.9.93
// 
// 
// AdvancedSkeleton is is a collection of Maya tools for doing character setup.
//   
// INSTALLATION: 
// Run the SETUP file (setup.exe) 
// Choose the Destination Folder.
// NOTE: destination folder must be your Maya user directory 
// eg: C:\Users\$user\Documents\maya\2014\
// Continue installation.
// Start Maya. 
// Now you will find a new Shelf called 'advancedSkeleton':  
// 
// For detailed instructions go to: www.animationstudios.com.au
// 
// Copyright (C)2014 Animation Studios
// 
// email: support@animationstudios.com.au
// Last Modified 17/04/2014

global proc asScriptLocator (){}

global proc string asScriptLocation ()
{
string $whatIs=`whatIs asScriptLocator`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder)`;
return $scriptLocation;
}

global proc asFace ()
{
global int $asIsResetting;
string $asScriptLocation=`asScriptLocation`;
string $sourceAsProcedures=("source \""+$asScriptLocation+"asProcedures.mel\"");
string $sourceAsToolProcedures=("source \""+$asScriptLocation+"asToolProcedures.mel\"");
if (!`exists asCharSize`)
	eval ($sourceAsProcedures);
if (!`exists aspopulateNameSpaceMenu`)
	eval ($sourceAsToolProcedures);	

if (!`optionVar -ex asFsGeometryTextField`)
	optionVar -sv asFsGeometryTextField "";
if (!`optionVar -ex asFsEye_LTextField`)
	optionVar -sv asFsEye_LTextField "";
if (!`optionVar -ex asFsEye_RTextField`)
	optionVar -sv asFsEye_RTextField "";
if (!`optionVar -ex asFsUpperTeethTextField`)
	optionVar -sv asFsUpperTeethTextField "";
if (!`optionVar -ex asFsLowerTeethTextField`)
	optionVar -sv asFsLowerTeethTextField "";
if (!`optionVar -ex asFsTongueTextField`)
	optionVar -sv asFsTongueTextField "";
if (!`optionVar -ex asFsHeadJointTextField`)
	optionVar -sv asFsHeadJointTextField "Head_M";
if (!`optionVar -ex asFsJawJointTextField`)
	optionVar -sv asFsJawJointTextField "Jaw_M";
if (!`optionVar -ex asFsJawControlTextField`)
	optionVar -sv asFsJawControlTextField "FKExtraJaw_M";
if (!`optionVar -ex asFsEyeJoint_LTextField`)
	optionVar -sv asFsEyeJoint_LTextField "Eye_L";
if (!`optionVar -ex asFsEyeJoint_RTextField`)
	optionVar -sv asFsEyeJoint_RTextField "Eye_R";
if (!`optionVar -ex asFsEyeControl_LTextField`)
	optionVar -sv asFsEyeControl_LTextField "FKExtraEye_L";
if (!`optionVar -ex asFsEyeControl_RTextField`)
	optionVar -sv asFsEyeControl_RTextField "FKExtraEye_R";
if (!`optionVar -ex asFsSkinClusterTextField`)
	optionVar -sv asFsSkinClusterTextField "";
if (!`optionVar -ex asFsAllFaceGeoTextField`)
	optionVar -sv asFsAllFaceGeoTextField "";
if (!`optionVar -ex asFsAllFaceGeoTextField`)
	optionVar -sv asFsAllFaceGeoTextField "";
	
if (!`optionVar -ex asFsUpperTeethJointTextField`)
	optionVar -sv asFsUpperTeethJointTextField "Head_M";
if (!`optionVar -ex asFsLowerTeethJointTextField`)
	optionVar -sv asFsLowerTeethJointTextField "Jaw_M";

if (`window -q -ex faceSetup`)
	deleteUI faceSetup;
window -w 370 -h 400 faceSetup;
formLayout asFsFormLayout;

	scrollLayout -w 50 -h 100 asFsScrollLayout1;
	columnLayout -adj 1 asFsColumnLayout1;
	frameLayout -w 340 -cll 1 -cl 1 -l "Start" asFaceStartFrameLayout;
		columnLayout;
		rowLayout -nc 2 -cw2 295 100;
			separator -st "none";
			button -h 15 -l "reset" -c asFaceReset;
			setParent..;
/*
			text -l "- First bind the head (and teeth,toungue & eyes)";
			text -l "  (No need for jaw weighing)";
			text -l "- Then proceed with the steps below.";
*/
	text -l "Choose Geometry";
	text -l " * = Optional";
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Face" -c "asChooseInput asFsGeometryTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsGeometryTextField` asFsGeometryTextField;
		setParent..;
	rowLayout -nc 3 -cw 1 120;
		button -w 120 -l "All Head" -c "asChooseInput asFsAllFaceGeoTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsAllFaceGeoTextField` asFsAllFaceGeoTextField;
		text -l "(eyes,hair,teeth,etc.)";
		setParent..;
	rowLayout -nc 3 -cw 1 120;
		button -w 120 -l "Left Eye" -c "asChooseInput asFsEye_LTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsEye_LTextField` asFsEye_LTextField;
		text -l "*";
		setParent..;
	rowLayout -nc 3 -cw 1 120;
		button -w 120 -l "Right Eye" -c "asChooseInput asFsEye_RTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsEye_RTextField` asFsEye_RTextField;
		text -l "*";
		setParent..;
	rowLayout -nc 3 -cw 1 120;
		button -w 120 -l "Upper Teeth" -c "asChooseInput asFsUpperTeethTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsUpperTeethTextField` asFsUpperTeethTextField;
		text -l "*";
		setParent..;
	rowLayout -nc 3 -cw 1 120;
		button -w 120 -l "Lower Teeth" -c "asChooseInput asFsLowerTeethTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsLowerTeethTextField` asFsLowerTeethTextField;
		text -l "*";
		setParent..;
	rowLayout -nc 3 -cw 1 120;
		button -w 120 -l "Tongue" -c "asChooseInput asFsTongueTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsTongueTextField` asFsTongueTextField;
		text -l "*";
		setParent..;

	checkBox -m 1 -l advanced -onc "columnLayout -e -m 1 asFsAdvancedinputColumnLayout" -ofc "columnLayout -e -m 0 asFsAdvancedinputColumnLayout";
	columnLayout -m 0 asFsAdvancedinputColumnLayout;
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Choose Head Joint" -c "asChooseInput asFsHeadJointTextField";
	textField -w 100 -ed 0 -tx `optionVar -q asFsHeadJointTextField` asFsHeadJointTextField;
		setParent..;
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Choose Jaw Joint" -c "asChooseInput asFsJawJointTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsJawJointTextField` asFsJawJointTextField;
		setParent..;
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Choose Jaw Control" -c "asChooseInput asFsJawControlTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsJawControlTextField` asFsJawControlTextField;
		setParent..;
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Choose Eye_L Joint" -c "asChooseInput asFsEyeJoint_LTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsEyeJoint_LTextField` asFsEyeJoint_LTextField;
		setParent..;
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Choose Eye_R Joint" -c "asChooseInput asFsEyeJoint_RTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsEyeJoint_RTextField` asFsEyeJoint_RTextField;
		setParent..;
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Choose Eye_L Control" -c "asChooseInput asFsEyeControl_LTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsEyeControl_LTextField` asFsEyeControl_LTextField;
		setParent..;
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Choose Eye_R Control" -c "asChooseInput asFsEyeControl_RTextField";
		textField -w 100 -ed 0 -tx `optionVar -q asFsEyeControl_RTextField` asFsEyeControl_RTextField;
		setParent..;
	text -l "SkinCluster found on Face Geo:";
	textField -w 150 -m 1 -tx `optionVar -q asFsSkinClusterTextField` asFsSkinClusterTextField;
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Choose Lid_R Pivot" -c "asChooseInput asFsEyeLidPivot_RTextField";
		textField -w 60 -ed 0 -tx "" asFsEyeLidPivot_RTextField;
		setParent..;
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Choose Lid_L Pivot" -c "asChooseInput asFsEyeLidPivot_LTextField";
		textField -w 60 -ed 0 -tx "" asFsEyeLidPivot_LTextField;
		setParent..;
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Choose UTeeth Joint" -c "asChooseInput asFsUpperTeethJointTextField";
	textField -w 100 -ed 0 -tx `optionVar -q asFsUpperTeethJointTextField` asFsUpperTeethJointTextField;
		setParent..;
	rowLayout -nc 2 -cw 1 120;
		button -w 120 -l "Choose LTeeth Joint" -c "asChooseInput asFsLowerTeethJointTextField";
	textField -w 100 -ed 0 -tx `optionVar -q asFsLowerTeethJointTextField` asFsLowerTeethJointTextField;
		setParent..;
		setParent..;
		setParent..;
		setParent..;

	frameLayout -w 340 -cll 1 -cl 1 -l "Loops";
	columnLayout;
	text -l "-Select EdgeLoops:";
	text -l "      (optional: also select vert for start of loop)";
	rowLayout -nc 2;
		separator -w 200 -st "none";
		button -h 15 -l "shrink edgeloop selection" -c asShrinkEdgeLoopSelection;
		setParent..;

	asFaceVertChooseWidget asCreateFaceFitJointsFromEdgeLoop EyeOuter 0.001 21;
	asFaceVertChooseWidget asCreateFaceFitJointsFromEdgeLoop EyeMiddle 0.001 22;
	asFaceVertChooseWidget asCreateFaceFitJointsFromEdgeLoop EyeInner 0.001 25;

	separator -w 340 -h 10;

	asFaceVertChooseWidget asCreateFaceFitJointsFromEdgeLoop LipOuter 0.001 21;
	asFaceVertChooseWidget asCreateFaceFitJointsFromEdgeLoop LipMiddle 0.001 22;
/*
	rowLayout -nc 5 -cw 1 150;
		button -w 120 -l "Outer EyeLid" -c "asCreateFaceFitJointsFromEdgeLoop EyeOuter 0.001 21";
		button -w 20 -l "?" -c "asFaceHelpImage EyeOuter";
		separator -st "none" -w 10;
		text -l " " -w 10 -bgc 0.894 0.675 0.475;
		setParent..;

	rowLayout -nc 9 -cw 1 125 -cw 2 23;
		button -w 120 -l "Next EyeLid" -c "asCreateFaceFitJointsFromEdgeLoop EyeMiddle 0.001 22";
		textField -w 20 -tx "A" asFSEyeMiddlePrefixTextField;
		button -w 20 -l "?" -c "asFaceHelpImage EyeMiddle";
		separator -st "none" -w 10;
		text -l "A" -w 10 -bgc 0 0.6 0.329;
		text -l "B" -w 10 -bgc 0.631 0.412 0.188;
		text -l "C" -w 10 -bgc 0.624 0.631 0.188;
		text -l "D" -w 10 -bgc 0.408 0.631 0.188;
		text -l "E" -w 10 -bgc 0.188 0.631 0.365;
		setParent..;

	rowLayout -nc 4 -cw 1 150;
		button -w 120 -l "Inner EyeLid" -c "asCreateFaceFitJointsFromEdgeLoop EyeInner 0.001 25";
		button -w 20 -l "?" -c "asFaceHelpImage EyeInner";
		separator -st "none" -w 10;
		text -l "" -w 10 -bgc 0.624 0.631 0.188;
		setParent..;

	separator -w 340 -h 10;
	rowLayout -nc 4 -cw 1 150;
		button -w 120 -l "Outer Lips" -c "asCreateFaceFitJointsFromEdgeLoop LipOuter 0.001 21";
		button -w 20 -l "?" -c "asFaceHelpImage LipOuter";
		separator -st "none" -w 10;
		text -l " " -w 10 -bgc 0.894 0.675 0.475;
		setParent..;
	rowLayout -nc 9 -cw 1 125 -cw 2 23;
		button -w 120 -l "Next Lips" -c "asCreateFaceFitJointsFromEdgeLoop LipMiddle 0.001 22";
		textField -w 20 -tx "A" asFSLipMiddlePrefixTextField;
		button -w 20 -l "?" -c "asFaceHelpImage LipMiddle";
		separator -st "none" -w 10;
		text -l "A" -w 10 -bgc 0 0.6 0.329;
		text -l "B" -w 10 -bgc 0.631 0.412 0.188;
		text -l "C" -w 10 -bgc 0.624 0.631 0.188;
		text -l "D" -w 10 -bgc 0.408 0.631 0.188;
		text -l "E" -w 10 -bgc 0.188 0.631 0.365;
		setParent..;
*/

	setParent..;
	setParent..;

	frameLayout -w 340 -cll 1 -cl 1 -l "Vertices";
	columnLayout;
	text -l "-Select Vertices:";

	asFaceVertChooseWidget asCreateFaceFitJoint foreheadMiddle 0.4 20;
	asFaceVertChooseWidget asCreateFaceFitJoint foreheadOuter 0.4 20;
	asFaceVertChooseWidget asCreateFaceFitJoint browMiddle 0.4 6;
	asFaceVertChooseWidget asCreateFaceFitJoint browInner 0.4 6;
	asFaceVertChooseWidget asCreateFaceFitJoint browHalf 0.4 10;
	asFaceVertChooseWidget asCreateFaceFitJoint browOuter 0.4 6;
	asFaceVertChooseWidget asCreateFaceFitJoint noseMiddle 0.4 20;
	asFaceVertChooseWidget asCreateFaceFitJoint noseOuter 0.4 20;
	asFaceVertChooseWidget asCreateFaceFitJoint cheekInner 0.4 20;
	asFaceVertChooseWidget asCreateFaceFitJoint cheekOuter 0.4 20;
	asFaceVertChooseWidget asCreateFaceFitJoint jaw 0.4 20;
	asFaceVertChooseWidget asCreateFaceFitJoint chinMiddle 0.5 20;
	asFaceVertChooseWidget asCreateFaceFitJoint noseLower 0.4 6;
	asFaceVertChooseWidget asCreateFaceFitJoint noseTip 0.4 20;
	asFaceVertChooseWidget asCreateFaceFitJoint noseCorner 0.4 6;
	asFaceVertChooseWidget asCreateFaceFitJoint chin 0.4 20;
	asFaceVertChooseWidget asCreateFaceFitJoint smile 0.4 6;

	setParent..;
	setParent..;

	frameLayout -w 340 -cll 1 -cl 1 -l "SkinEyes";
	columnLayout;
		button -w 120 -l "skin eyes" -c "asSkinEyes";
/*
		text -l "test eyes:";
		floatSlider -w 120 -min -30 -max 30 -value 0 -step 0.1 asFaceJawFloatSlider;
		connectControl asFaceJawFloatSlider (`optionVar -q asFsEyeControl_LTextField`+".ry");
*/
	setParent..;
	setParent..;

	frameLayout -w 340 -cll 1 -cl 1 -l "JawCurve";
	columnLayout;
		rowLayout -nc 3 -cw 1 120;
			button -w 120 -l "create JawCurve" -c "asCreateJawCurve";
			text -l ", then and adjust the jaw-line";
			button -w 20 -l "?" -c "asFaceHelpImage jawLine";
			setParent..;
		separator -st "none" -h 10;
		rowLayout -nc 3;
			text -l "Select all vertices affected by the jaw ";
			button -w 20 -l "?" -c "asFaceHelpImage setJawArea";
			setParent..;
		text -l "then:";
		rowLayout -nc 3 -cw 1 130 -cw 2 40;
			button -w 120 -l "set JawArea" -c "asSetJawArea";
			button -w 120 -l "show selected JawArea" -c "select jawArea";
			setParent..;
		button -w 120 -l "skin Jaw" -c "asSkinJaw";
		text -l "test jaw open:";
		floatSlider -w 120 -min 0 -max 30 -value 0 -step 0.1 asFaceJawFloatSlider;
	setParent..;
	setParent..;
	
	frameLayout -w 340 -cll 1 -cl 1 -l "HeadSquash *";
	columnLayout;
		text -l "*   HeadSquash is optional";
		separator -st "none" -h 10;
		button -w 150 -l "create base locator" -c "asFaceCreateSquash Base";

		rowLayout -nc 3;
			text -l "Then move this into place, under the chin";
			button -w 20 -l "?" -c "asFaceHelpImage squashBaseLocator";
			setParent..;

		button -w 150 -l "create top locator" -c "asFaceCreateSquash Top";
		rowLayout -nc 3;
			text -l "Then move this into place, on top of the head";
			button -w 20 -l "?" -c "asFaceHelpImage  squashTopLocator";
			setParent..;
/*
		separator -w 340 -h 10;
		button -l "Create Eye-Sculpt" -c "asFaceCreateEyeSculpt";
*/
		setParent..;
		setParent..;

	frameLayout -w 340 -cll 1 -cl 1 -l "Tongue *";
	columnLayout;
		text -l "*   Tongue is optional";
		separator -st "none" -h 10;
		button -w 120 -l "create tongue joints" -c "asFaceCreateTongueJoints";
		text -l "Then move joints into place";
		setParent..;
		setParent..;
		
	frameLayout -w 340 -cll 1 -cl 1 -l "Cage *";
	columnLayout;
		text -l "*   Cage is optional";
		separator -st "none" -h 10;
		button -w 120 -l "build face cage" -c "asFaceSurfacer";
		rowLayout -nc 3;
			text -l "Then tweak face cage if neccecary";
			button -w 20 -l "?" -c "asFaceHelpImage faceCage";
			setParent..;
		button -w 120 -l "build head cage" -c "asFaceHeadCage";
		rowLayout -nc 3;
			text -l "Then tweak head cage if neccecary";
			button -w 20 -l "?" -c "asFaceHelpImage headCage";
			setParent..;
		text -l "*  Optional: add eyeLid influence (isolates eyeLid deformation)";
		button -l "add eyeLid" -c "asFaceAddInfluenceEyeLid";
		separator -h 10;
		text -l "Add influences if neccecary (for fixing deformations inside mouth etc.)";
		rowLayout -nc 3;
			button -l "add sphere" -c "asFaceAddInfluenceSphere";
			button -l "add plane" -c "asFaceAddInfluencePlane 0";
			button -l "add plane(follow Jaw)" -c "asFaceAddInfluencePlane 1";
			setParent..;
		separator -h 10;
		setParent..;
	setParent..;
	setParent..;

/*
	frameLayout -w 340 -cll 1 -cl 1 -l "Vertices(2)";
	columnLayout;
	text -l "- *Optional Cartoon face controls:";
	text -l "- Select Vertices:";
	rowLayout -nc 4 -cw4 110 70 70 70;
		separator -st "none";
		button -w 80 -l "eyeShaper3" -c "asCreateFaceFitJoint eyeShaper3 0.4 9";
		setParent..;
	rowLayout -nc 4 -cw4 50 120 70 70;
		separator -st "none";
		button -w 80 -l "eyeShaper2" -c "asCreateFaceFitJoint eyeShaper2 0.4 9";
		button -w 80 -l "eyeShaper4" -c "asCreateFaceFitJoint eyeShaper4 0.4 9";
		separator -st "none";
		setParent..;
	rowLayout -nc 4 -cw4 70 60 80 70;
		button -w 80 -l "eyeShaper1" -c "asCreateFaceFitJoint eyeShaper1 0.4 9";
		separator -st "none";
		button -w 20 -l "?" -c "asFaceHelpImage eyeShapers";
		button -w 80 -l "eyeShaper5" -c "asCreateFaceFitJoint eyeShaper5 0.4 9";
		setParent..;
	rowLayout -nc 4 -cw4 50 120 70 70;
		separator -st "none";
		button -w 80 -l "eyeShaper8" -c "asCreateFaceFitJoint eyeShaper8 0.4 9";
		button -w 80 -l "eyeShaper6" -c "asCreateFaceFitJoint eyeShaper6 0.4 9";
		separator -st "none";
		setParent..;
	rowLayout -nc 4 -cw4 110 70 70 70;
		separator -st "none";
		button -w 80 -l "eyeShaper7" -c "asCreateFaceFitJoint eyeShaper7 0.4 9";
		setParent..;
	setParent..;
	setParent..;
*/

/*
	frameLayout -w 340 -cll 1 -cl 1 -l "Squash Regions";
	columnLayout;
	text -l "- *Optional Cartoon face controls:";
	text -l "- Create Locators, and position (up/down) correctly:";
	rowLayout -nc 2 -cw 1 150;
		button -w 120 -l "UnderChin Locator" -c "asFaceCreateRegionLocator underChin";
		button -w 20 -l "?" -c "asFaceHelpImage underChin";
		setParent..;
	rowLayout -nc 2 -cw 1 150;
		button -w 120 -l "UnderEye Locator" -c "asFaceCreateRegionLocator underEye";
		button -w 20 -l "?" -c "asFaceHelpImage underEye";
		setParent..;
	rowLayout -nc 2 -cw 1 150;
		button -w 120 -l "OverEye Locator" -c "asFaceCreateRegionLocator overEye";
		button -w 20 -l "?" -c "asFaceHelpImage overEye";
		setParent..;
	setParent..;
	setParent..;
*/

	frameLayout -w 340 -cll 1 -cl 1 -l "Build";
		columnLayout;
			button -l "Build FaceSetup" -c "asFaceFirstBuild";
/*
	columnLayout asFsColumnLayout2;
	separator -w 340 -h 10;
	rowLayout -nc 2 -cw2 130 10 ;
		separator -st none;
		checkBox -m 0 -v 1 -l "Rebuild Connections" asFSRebuildConnections;
		setParent..;
	rowLayout -nc 4 -cw4 10 110 30 100 asFsRowLayout;
		separator -st "none";
		button -c asFaceToggleFaceFitSkeleton -l "Toggle Fit/Advanced";
		separator -st "none";
		button -l "(Re) Build FaceSetup" -c "asFaceReBuild";
*/
			setParent..;
		setParent..;

	frameLayout -w 340 -cll 1 -cl 1 -l "ReBuild";
		columnLayout;
			button -c asFaceToggleFaceFitSkeleton -l "toggle Fit/Advanced";
			setParent..;
		separator;
		columnLayout;
			checkBox -v 1 -l "keep tweaked blendShapes" asFaceKeepBlendShapes;
			button -l "rebuild cage deformation only" -c asFaceRebuildCageDeformOnly;
			button -l "reBuild all faceSetup" -c "asFaceReBuild";
			setParent..;
		setParent..;
/*
	frameLayout -w 340 -cll 1 -cl 1 -l "Tweaks - clusters";
	columnLayout;
	text "Move any of the \"cluster\" control (light blue), then";
	button -l "Convert selected Control to SoftMod" -c "asFaceConvertControlToSoftMod";
	text -l "Move around the SoftMod, and tweak falloffRadius etc, then:";

	columnLayout -m 0 asFaceDirectionRadisuColumnLayout;
		rowLayout -nc 2 -cw2 50 30;
			floatField -ed 0 -w 50 -pre 2 asFaceDirWgtsUpFloatField;
			button -w 35 -l "up" -c "asFaceGetDirWght Up";
			setParent..;
		rowLayout -nc 2 -cw2 50 30;
			floatField -ed 0 -w 50 -pre 2 asFaceDirWgtsLeftFloatField;
			button -w 35 -l "left" -c "asFaceGetDirWght Left";
			setParent..;
		rowLayout -nc 2 -cw2 50 30;
			floatField -ed 0 -w 50 -pre 2 asFaceDirWgtsRightFloatField;
			button -w 35 -l "right" -c "asFaceGetDirWght Right";
			setParent..;
		rowLayout -nc 2 -cw2 50 30;
			floatField -ed 0 -w 50 -pre 2 asFaceDirWgtsDownFloatField;
			button -w 35 -l "down" -c "asFaceGetDirWght Down";
			setParent..;
		button -l "reset" -c asFaceResetDirWgts;
		setParent..;

	button -l "Convert SoftMod back to Control" -c "asFaceConvertSoftModToControl 1";
	text -l "Or, Paint Cluster weights";
	button -l "Paint weights for selected Control" -c "asFacePaintClusterWeights";
	text -l "Painting outside falloffRadius ?  ";
	rowLayout -nc 3;
		button -l "UnPrune all cluster" -c "asUnpruneClusters 0";
		separator -st "none" -w 10;
		button -l "RePrune all cluster" -c "asUnpruneClusters 1";
		setParent..;
	separator -w 340 -h 20;
	text "manually create a new softMod, then";
	button -l "Create new Control from selected SoftMod" -c "asFaceConvertSoftModToControl 0";
	separator -w 340 -h 20;
	text -l "If you manually paint or tweak cluster weights, then";
	button -l "Mirror ClusterWeights" -c asFaceMirrorAllClusterWeights;
	setParent..;
	setParent..;
*/
	frameLayout -w 340 -cll 1 -cl 1 -l "Tweaks - Brows";
		columnLayout;
		text -l "*   Brows is optional";
		separator -st "none" -h 10;
		text -l "Select EyeBrows, then:";
		button -l "WrapDeform to face" -c "asFaceWrapDeformToFace";
		setParent..;
		setParent..;

	frameLayout -w 340 -cll 1 -cl 1 -l "Tweaks - lipFalloff";
	columnLayout;
	text -l "number of edgeLoops out from lips to blend weights:";
	rowLayout -nc 4;
		intField -v 2 -w 30 skinWeightMouthIntField;
		button -l "select vertex" -c asFaceSelectMouthFalloffVtx;
		button -l "remove weights" -c asFaceMouthRemoveWeights;
		button -l "hammer weights" -c asFaceMouthHammer;
	setParent..;
	setParent..;
	setParent..;

	frameLayout -w 340 -cll 1 -cl 1 -l "Tweaks - add control";
	columnLayout;
	text -l "Create a softmod, then";
//	button -l "add control" -c "asFaceAddControl";
	checkBox -l "Make this a \"_Middle\" Control" asFaceIsMiddleControlCheckBox;
	button -l "Create new Control from selected SoftMod" -c "asFaceConvertSoftModToControl 0";
	button -l "Paint weights for selected Control" -c "asFacePaintClusterWeights";
	button -l "Mirror weights for selected Control (R>L)" -c asFaceMirrorAllClusterWeights;
	setParent..;
	setParent..;

	frameLayout -w 340 -cll 1 -cl 1 -l "Tweaks - blendshapes";
	columnLayout;
	text -l "Set controls to the shape for adjustment, then";
	button -l "create blendShape target" -c "asBSAdjustTarget";
	floatSlider -en 0 -w 120 -min 0 -max 1 -value 0 -step 0.1 asFaceBSFloatSlider;
	text -l "Delete the targets when finished";
	separator -st "none" -h 20;
	text -l "Or step through ALL the BlendShape targets, with the Wizard";
	rowLayout -nc 3 -cw3 150 30 50;
		button -l "start blendShapes wizard" -c "asBSWizard";
		button -en 0 -l "?" -c "asFaceHelpImage asBSWizardStep0" asBSWizardHelpButton;
		button -en 0 -l "next.." -c "asBSWizardNext" asBSWizardNextButton;
		setParent..;
	rowLayout -nc 3 -cw3 50 150 50;
		text -en 0 -l "0/37" asBSWizardStepText;
		text -en 0 -l "..." asBSWizardObjAttrText;
		text -en 0 -l "..." asBSWizardValueText;
		setParent..;
	button -l "stop blendShapes wizard" -c "asBSWizardStop";
	setParent..;
	setParent..;

	setParent..;
	setParent..;
	rowLayout -nc 2 -cw2 120 100 asFsRowLayout1;
	separator;
	button -l "Go to Build Pose" -c "asGoToBuildPose faceSetup";
	setParent..;
	setParent..;
	setParent..;


formLayout -e
	-af asFsScrollLayout1 "right" 0
	-af asFsScrollLayout1 "left" 0
	-af asFsScrollLayout1 "top" 0
	-ac asFsScrollLayout1 "bottom" 0 asFsRowLayout1
	-af asFsRowLayout1 "bottom" 0
	asFsFormLayout;

showWindow;
if ($asIsResetting)
	$asIsResetting=0;
else
	asFaceUpdateInfo 1;

connectControl asFaceJawFloatSlider (`textField -q -tx asFsJawControlTextField`+".rz");
}

global proc asFaceReset ()
{
global int $asIsResetting;
$asIsResetting=1;
string $allOptionVars[]=`optionVar -list`;
for ($i=0;$i<size($allOptionVars);$i++)
	if (`gmatch $allOptionVars[$i] "asFs*"`)
		optionVar -remove $allOptionVars[$i];
deleteUI faceSetup;
asFace;
frameLayout -e -cl 0 asFaceStartFrameLayout;
}

global proc asShrinkEdgeLoopSelection ()
{
global string $gMainProgressBar;
string $sel[]=`ls -sl -fl`;
if (!`gmatch $sel[0] "*.e\[[]*"`)
	error "EdgeLoop must be selected, before attempting to automatically select the next edgeloop inwards";
GrowPolygonSelectionRegion;
GrowPolygonSelectionRegion;
select -d $sel;
ShrinkPolygonSelectionRegion;
string $gSel[]=`ls -sl -fl`;
int $inClosedLoop[];
int $closedLoopNr;
string $connectedEdges[];
string $edgesInBrokenLoop[];
string $edgeNr;
clear $edgesInBrokenLoop;
string $closedLoopEdges[];
clear $closedLoopEdges;
progressBar -e -st ("shrinking edgeloop selection") -bp -ii 0 -min 0 -max (size($gSel)) $gMainProgressBar;
for ($i=0;$i<size($gSel);$i++)
    {
		progressBar -e -s 1 $gMainProgressBar;
    if(`stringArrayCount $gSel[$i] $edgesInBrokenLoop`)
        continue;
    $inClosedLoop[$i]=0;
    string $edgesInThisLoop[];
    clear $edgesInThisLoop;
    select $gSel[$i];
    int $nextIsOnLoop=1;
    $edgesInThisLoop[0]=$gSel[$i];
    int $loopNr=0;
    while ($nextIsOnLoop && !$inClosedLoop[$i])
        {
        string $tempSel[]=`ls -sl -fl`;
        GrowPolygonSelectionRegion;
        select -d $tempSel;
        $connectedEdges=`ls -sl -fl`;
        select -cl;
        $nextIsOnLoop=0;
        for ($y=0;$y<size($connectedEdges);$y++)
            {
            if (`stringArrayCount $connectedEdges[$y] $gSel`)
                if (!`stringArrayCount $connectedEdges[$y] $edgesInThisLoop`)
                    {
                    $edgesInThisLoop[size($edgesInThisLoop)]=$connectedEdges[$y];
                    select $connectedEdges[$y];
                    $nextIsOnLoop=1;
                    break;
                    }
            if ($loopNr>2 && $connectedEdges[$y]==$gSel[$i])
                {
                $inClosedLoop[$i]=1;
                $edgeNr=`substitute "body_M.e[[]" $edgesInThisLoop[0] ""`;
                $edgeNr=`substitute "[]]" $edgeNr ""`;
                if($closedLoopNr==0 || !`gmatch $closedLoopEdges[$closedLoopNr-1] ("*[[]"+$edgeNr+"[]]*")`)
                    {
                    for ($z=0;$z<size($edgesInThisLoop);$z++)
                        $closedLoopEdges[$closedLoopNr]=$closedLoopEdges[$closedLoopNr]+$edgesInThisLoop[$z]+" ";
                    $closedLoopNr++;
                    }
                }
            }
        $loopNr++;
        }
    if (!$inClosedLoop[$i])
        {
        $edgesInBrokenLoop=`stringArrayCatenate $edgesInBrokenLoop $edgesInThisLoop`;
        $edgesInBrokenLoop=`stringArrayRemoveDuplicates $edgesInBrokenLoop`;
        }        
    }

select -cl;
for ($i=0;$i<size($gSel);$i++)
    if ($inClosedLoop[$i])
        select -add $gSel[$i];

//Might have 2 resulting loops, choose the smallest.
if (size($closedLoopEdges)>1)
    {
    float $loopLenghts[];
    for ($i=0;$i<2;$i++)
        {
        eval ("select "+$closedLoopEdges[$i]);
        string $nSel[]=`ls -sl -fl`;
        for ($y=0;$y<size($nSel);$y++)
            {
            select $nSel[$y];
            ConvertSelectionToVertices;
            string $vrts[]=`ls -sl -fl`;
            float $posA[]=`xform -q -ws -t $vrts[0]`;
            float $posB[]=`xform -q -ws -t $vrts[1]`;
            $loopLenghts[$i]+=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[0]-$posB[0]>>`;
            }
        }
    if ($loopLenghts[0]<$loopLenghts[1])
        eval ("select "+$closedLoopEdges[0]);
    else
        eval ("select "+$closedLoopEdges[1]);
    }
progressBar -e -ep $gMainProgressBar;
}


global proc asFaceWrapDeformToFace ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFsGeometryTextField`;
//remove possible FFD influence first
string $squashFfdSet;
string $history[],$tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -ni -s $sel[$i]`;
	$history=`listHistory $sel[$i]`;
	if (`stringArrayCount "squashFfd" $history`)
		{
		$tempString=`listConnections squashFfd.message`;
		for ($y=0;$y<size($tempString);$y++)
			if ($tempString[$y]!="FaceAllSet")
				$squashFfdSet=$tempString[$y];
		select $sel[$i];
		DeleteHistory;
		print ("// Deleting history for \""+$sel[$i]+"\", to avoid double deformations;\n");
		}
	}
for ($i=0;$i<size($sel);$i++)
	{
	select -r $sel[$i];
	select -add $geometry;
	doWrapArgList "7" { "1","0","1", "2", "0", "1", "0", "0" };
	}
}

global proc asFaceAddControl ()
{
if (`promptDialog -t "New Control" -m "Enter Name:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
	return;
string $name=`promptDialog -query -text`;
string $skinCluster=`textField -q -tx asFsSkinClusterTextField`;
int $b=1;
int $color=6;
string $side="_R";
string $sel[]=`ls -sl`;
float $pos[]=`xform -q -ws -t`;

select -cl;
joint -n $name;
setAttr ($name+".overrideColor") 6;
parent $name FaceFitSkeleton;
xform -ws -t $pos[0] $pos[1] $pos[2] $name;

for ($b=1;$b>-2;$b=$b-2)
	{
	//determine $side
	$pos=`xform -q -ws -t $name`;
	if ($pos[0]<-0.001) $side="_R"; else $side="_M"; if ($b==-1 && $side=="_R") $side="_L"; if ($b==-1 && $side=="_M") continue;
	pingPong $name $name $b $side $color;
	}
}

global proc asFaceVertChooseWidget (string $cmd, string $region, float $size, int $color)
{
//20 besj holder, 6 blue ctrl, 10 brown ctrl, (8 added (cluster) controls)
int $abcCheckBoxes,$abcCheckBoxes;
if ($cmd=="asCreateFaceFitJointsFromEdgeLoop" && `gmatch $region "*Middle"`)
	$abcCheckBoxes=1;
if ($cmd=="asCreateFaceFitJointsFromEdgeLoop" && `gmatch $region "*Inner"`)
	$extraCheckBoxes=1;
float $checkValue=0;
if (`objExists $region` || `objExists ("upper"+$region+"1")`)
	$checkValue=1;
rowLayout -nc 9 -cw 1 130;
	button -w 120 -l $region -c ($cmd+" "+$region+" "+$size+" "+$color);
	if ($abcCheckBoxes)
		textField -w 20 -tx "A" ("asFS"+$region+"PrefixTextField");
	else
		checkBox -w 20 -l "" -ed $checkValue -v $checkValue -ofc ("asFaceDeleteFromCheckBox "+$region) ("asFace"+$region);
	button -w 20 -l "?" -c ("asFaceHelpImage "+$region);
	if ($abcCheckBoxes || $extraCheckBoxes)
		{
		separator -w 20 -st "none";
		for($i=1;$i<6;$i++)
			{
			string $letter=`asFaceNrToLetter $i`;
			string $label=$letter;
			$checkValue=0;
			int $w=25;
			string $extra="";
			if ($extraCheckBoxes)
				{
				if ($i>3) continue;
				$label="X"+$letter;
				$w=35;
				$extra="Extra";
				}
			if (`objExists ("upper"+$region+$extra+$letter+"1")`)
				{
				$checkValue=1;
				if (`textField -q -ex ("asFS"+$region+"PrefixTextField")`)
					textField -e -tx `asFaceNrToLetter ($i+1)` ("asFS"+$region+"PrefixTextField");
				}
			checkBox -w $w -l $label -ed $checkValue -v $checkValue -ofc ("asFaceDeleteFromCheckBox "+$region+$extra+$letter) ("asFace"+$region+$extra+$letter);
			}
		}
	setParent..;
}

global proc asFaceDeleteFromCheckBox (string $region)
{
int $loopOfJoints=0;
// loops of joints (otherwice single joints)
if ($region=="EyeOuter" || `gmatch $region "EyeInner*"` || `gmatch $region "EyeMiddle[A-Z]"` 
 || $region=="LipOuter" || `gmatch $region "LipInner*"` || `gmatch $region "LipMiddle[A-Z]"`)
	$loopOfJoints=1;
string $m="Delete "+$region+" joint ?";
if ($loopOfJoints)
	$m="Delete "+$region+" joints ?";
string $dialog=`confirmDialog -t "Confirm"
	-m $m
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	{
	checkBox -e -v 1 ("asFace"+$region);
	return;
	}
if ($loopOfJoints)
	delete `ls ("upper"+$region+"*") ("lower"+$region+"*")`;
else
	delete $region;
checkBox -e -ed 0 ("asFace"+$region);
}

global proc asFaceRebuildCageDeformOnly ()
{
//first go to buildPose(minus .run attrs)
eval `getAttr faceBuildPose.udAttr`;
asFaceProcessor;
asFaceBsSdkSetup;
//go to buildPose(include .run attrs)
asGoToBuildPose faceSetup;
if (`getAttr FaceFitSkeleton.v`)
	asFaceToggleFaceFitSkeleton;
}

global proc asSetJawArea ()
{
string $skinCluster=`textField -q -tx asFsSkinClusterTextField`;
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
string $sel[]=`ls -sl -fl`;
if (`objExists jawArea`)
	{
	warning "jawArea was already set, assigning vtx in previous set JawArea to HeadJoint";
	select jawArea;
	skinPercent -tv $headJoint 1 $skinCluster `ls -sl`;
	}
else
	{
	createNode -n jawArea objectSet;	
	if (`objExists "Sets"`)
		sets -add "Sets" jawArea;
	}
select $sel;
sets -add jawArea `ls -sl`;
}

global proc asSkinEyes ()
{
int $haveSkinCluster;
string $tempString[],$historyNodes[],$eyeGeos[];

for ($a=0;$a<2;$a++)
	{
	if ($a==0)	$side="_R";
	if ($a==1)	$side="_L";

	string $eyeJoint=`textField -q -tx ("asFsEyeJoint"+$side+"TextField")`;
	string $eye=`textField -q -tx ("asFsEye"+$side+"TextField")`;

	if ($eye=="")
		{
		warning "//No eye geometry specified, skipping..";
		continue;
		}
	tokenize $eye " " $tempString;
	clear $eyeGeos;
	for ($i=0;$i<size($tempString);$i++)
		$eyeGeos[$i]=$tempString[$i];

	for ($i=0;$i<size($eyeGeos);$i++)
		{
		$haveSkinCluster=0;
		$historyNodes=`listHistory $eyeGeos[$i]`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				$haveSkinCluster=1;
	
		if ($haveSkinCluster)
			print ("// Skipping \""+$eyeGeos[$i]+"\", it already has skinCluster\n");
		else
			{
			select $eyeJoint $eyeGeos;
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			for ($i=0;$i<size($tempString);$i++)
				rename $tempString[$i] eyeSC_R;
			}
		}
	}
}

global proc asSkinJaw ()
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $skinCluster=`textField -q -tx asFsSkinClusterTextField`;
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
string $jawJoint=`textField -q -tx asFsJawJointTextField`;
string $upperTeeth=`textField -q -tx asFsUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFsLowerTeethTextField`;
string $upperTeethJoint=`textField -q -tx asFsUpperTeethJointTextField`;
string $lowerTeethJoint=`textField -q -tx asFsLowerTeethJointTextField`;
//add jaw joint as inf
string $tempString[]=`listConnections ($jawJoint+".worldMatrix[0]")`;
if (!`stringArrayCount $skinCluster $tempString`)
	skinCluster -e -ai $jawJoint -lw false -wt 0 $skinCluster;

//teeth
string $upperLower,$teeth,$teethJoint,$teethObject;
string $teethSC=$skinCluster;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$teeth=$upperTeeth;$teethJoint=$upperTeethJoint;}
	else {$upperLower="lower";$teeth=$lowerTeeth;$teethJoint=$lowerTeethJoint;}
		
	if ($teeth=="")
		continue;
	$teethObject=$teeth;
	if (`gmatch $teeth "*[.]*"`)
		{
		tokenize $teeth "." $tempString;
		$teethObject=$tempString[0];
		}
	int $haveSkinCluster=0;
	string $historyNodes[]=`listHistory $teethObject`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$teethSC=$historyNodes[$y];
			}
	if (!$haveSkinCluster)
		{
		select $teethJoint;
		select -add $teeth;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($upperLower+"TeethSC");
		}
	else
		{
		$tempString=`listConnections ($teethSC+".matrix")`;
		if (!`stringArrayCount $teethJoint $tempString`)
			skinCluster -e -ai $teethJoint -lw false -wt 0 $teethSC;
		eval ("select "+$teeth);
		skinPercent -tv $teethJoint 1 $teethSC `ls -sl`;
		}
	}

//jaw line
asSelectJawCurveVtx;
string $jawCurveVtxs[]=`ls -sl`;
skinPercent -tv $jawJoint 1 $skinCluster `ls -sl`;

select jawArea;
select -d $jawCurveVtxs;
weightHammerVerts;
select $jawCurveVtxs;
weightHammerVerts;

copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
}

global proc asSelectJawCurveVtx ()
{
string $geometry=`textField -q -tx asFsGeometryTextField`;

string $tmpObjs[]={"tempLocator","tempPointOnCurveInfo","closestSampler"};
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
spaceLocator -n tempLocator;
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
connectAttr -f JawCurveShape.worldSpace[0] tempPointOnCurveInfo.inputCurve;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
setAttr tempPointOnCurveInfo.parameter 0.5;
connectAttr tempPointOnCurveInfo.position tempLocator.t;

createNode -n closestSampler closestPointOnMesh;
string $tempString[]=`listRelatives -ni -s $geometry`;
connectAttr ($tempString[0]+".outMesh") closestSampler.inMesh;
connectAttr -f ($geometry+".xformMatrix") closestSampler.inputMatrix;
connectAttr tempLocator.worldPosition closestSampler.inPosition;
setAttr "tempPointOnCurveInfo.parameter" 1;
select -cl;
int $previousVtx;
for ($i=0;$i<99;$i++)
	{
	setAttr tempPointOnCurveInfo.parameter (0.01*$i);
	int $vtx=`getAttr closestSampler.result.closestVertexIndex`;
	if($vtx!=$previousVtx)
		select -add ($geometry+".vtx["+$vtx+"]");
	$previousVtx=$vtx;
	}
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
}

global proc asCreateJawCurve ()
{
if (!`objExists cheekOuter`) error "\"cheekOuter\" not found";
if (!`objExists chinMiddle`) error "\"chinMiddle\" not found";
if (`objExists JawCurve`) error "\"JawCurve\" already exists";
circle -n JawCurve -c 0 0 0 -nr 0 1 0 -sw 180 -r 1 -d 3 -ut 0 -tol 3.93701e-005 -s 8 -ch 0;
parent JawCurve FaceFitSkeleton;
float $temp[3]=`xform -q -ws -t cheekOuter`;
xform -ws -t 0 $temp[1] $temp[2] JawCurve;
setAttr JawCurve.sz $temp[0];
delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 chinMiddle JawCurve`;
createNode -n tempXform transform;
parent tempXform chinMiddle;
setAttr -type float3 tempXform.t 0 0 0;
parent tempXform JawCurve;
setAttr JawCurve.sx (`getAttr tempXform.tx`*-1);
delete tempXform;
select JawCurve;
}

global proc asUnpruneClusters (int $rePrune)
{
global string $gSelect;
global string $gArtAttrCurrentAttr;
string $artAttrCurrentAttr=$gArtAttrCurrentAttr;
int $autoKeyState=`autoKeyframe -q -state`;
if ($autoKeyState)
			autoKeyframe -state 0;
string $ctx=`currentCtx`;
setToolTo $gSelect;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $historyNodes[]=`listHistory $geometry`;
string $tempString[];
for ($i=0;$i<size($historyNodes);$i++)
	if (`objExists $historyNodes[$i]`)
		if (`nodeType $historyNodes[$i]`=="cluster")
			{
			string $cluster=$historyNodes[$i];
			$tempString=`listConnections ($cluster+".message")`;
			for ($y=0;$y<size($tempString);$y++)
				if (!`gmatch $tempString[$y] "*AllSet"`)
					{
					string $deformSet=$tempString[$y];
					if ($rePrune)
						{
						//temporarily move control to woraround `pruning non-moved-clusters-removes-all-weight`
						string $control=`substitute "Cluster" $cluster ""`;
						float $temp[]=`xform -q -ws -t $control`;
						setAttr -type float3 ($control+".t") 1 0 0;
						cluster -e -pr $cluster;
						refresh;
						xform -ws -t $temp[0] $temp[1] $temp[2] $control;
						}
					else
						{
						select $deformSet;
						if (size(`ls -sl`))
							{
							InvertSelection;
							sets -add $deformSet;
							percent -v 0 $cluster `ls -sl`;
							}
						}
					}
			}
if ($autoKeyState)
			autoKeyframe -state 1;
select $sel;
if ($ctx=="artAttrContext")
	{
	setToolTo artAttrContext;
	eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \""+$artAttrCurrentAttr+"\")");
	select $geometry;
	evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \""+$artAttrCurrentAttr+"\")");
	}
}

global proc asFacePaintClusterWeights ()
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $sel[]=`ls -sl`;
string $tempString[];
tokenize $sel[0] "_" $tempString;
$fitJoint=$tempString[0];
$side="_"+$tempString[1];
artAttrToolScript 4 "cluster";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
select $geometry;
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
}

global proc asFaceCreateEyeSculpt ()
{
$eyeJoint=`textField -q -tx ("asFsEyeJoint_RTextField")`;
float $pos[3]=`xform -q -ws -t $eyeJoint`;
select $eyeJoint;
asCreateFaceFitJoint eyeSculpt `abs($pos[0])` 9;
select eyeSculpt;
}

global proc asFaceCreateSquash (string $region)
{
if (`objExists ("squash"+$region)`)
	error ("Object \"squash"+$region+"\" already exists");
float $scale=`asFaceGetScale`;
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
float $headPos[]=`xform -q -ws -t $headJoint`;
spaceLocator -n ("squash"+$region);
parent ("squash"+$region) FaceFitSkeleton;
setAttr -type float3 ("squash"+$region+"Shape.localScale") ($scale*3) ($scale*3) ($scale*3);
if ($region=="Base")
	xform -ws -t $headPos[0] ($headPos[1]-($scale*3)) $headPos[2] ("squash"+$region);
if ($region=="Top")
	xform -ws -t $headPos[0] ($headPos[1]+($scale*4.5)) $headPos[2] ("squash"+$region);
}

global proc asFaceMouthRemoveWeights ()
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
string $sel[]=`ls -sl`;
string $lipDeformSel[];
for ($i=0;$i<size($sel);$i++)
	$lipDeformSel[$i]=`substitute $geometry $sel[$i] "lipDeform"`;
select -r $lipDeformSel;
skinPercent -tv lipHead 1 lipDeformSkinCluster `ls -sl`;
select $sel;
}

global proc asFaceMouthHammer ()
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $sel[]=`ls -sl`;
string $lipDeformSel[];
for ($i=0;$i<size($sel);$i++)
	$lipDeformSel[$i]=`substitute $geometry $sel[$i] "lipDeform"`;
select -r $lipDeformSel;
weightHammerVerts;
select $sel;
}

global proc asFaceSelectMouthFalloffVtx ()
{
//user might not havwe gone back to buildPose, so we temporarily disable some deformers to increase chances of working
string $skinCluster=`textField -q -tx asFsSkinClusterTextField`;
setAttr ($skinCluster+".envelope") 0;
if (`objExists lipLidBS`) setAttr lipLidBS.envelope 0;
if (`objExists squashFfd`) setAttr squashFfd.envelope 0;
if (`objExists upperLipRibbonWrap`) setAttr upperLipRibbonWrap.envelope 0;
if (`objExists lowerLipRibbonWrap`) setAttr lowerLipRibbonWrap.envelope 0;
int $numGrow=`intField -q -v skinWeightMouthIntField`;
string $geometry=`textField -q -tx asFsGeometryTextField`;
select `ls -type joint "*Lip*_*"`;
select -d `ls -type joint "*LipCenter*_*"`;
asFaceSelectVtxFromJoint $geometry;
string $lipVtxs[]=`ls -sl`;
select `ls "*LipOuter*_*"`;
asFaceSelectVtxFromJoint $geometry;
for ($i=0;$i<$numGrow;$i++)
	GrowPolygonSelectionRegion;
select -d $lipVtxs;
setAttr ($skinCluster+".envelope") 1;
if (`objExists lipLidBS`) setAttr lipLidBS.envelope 1;
if (`objExists squashFfd`) setAttr squashFfd.envelope 1;
if (`objExists upperLipRibbonWrap`) setAttr upperLipRibbonWrap.envelope 1;
if (`objExists lowerLipRibbonWrap`) setAttr lowerLipRibbonWrap.envelope 1;
}

global proc asBSWizardStop ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
text -e -l ("0/"+$lastStep) asBSWizardStepText;
text -e -l "..." asBSWizardObjAttrText;
text -e -l "..." asBSWizardValueText;
button -e -en 0 asBSWizardHelpButton;
button -e -en 0 asBSWizardNextButton;
if (`objExists deleteThis`)
	delete deleteThis;
if (`objExists tempAnimCurve`)
	delete tempAnimCurve;
asGoToBuildPose faceSetup;
}

global proc asBSWizard ()
{
button -e -en 1 asBSWizardNextButton;
button -e -en 1 asBSWizardHelpButton;
asGoToBuildPose faceSetup;
playbackOptions -min 1 -max 10 -ast 1 -aet 10;
asBSWizardNext;
}

global proc asBSWizardNext ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
int $step=$previousStep+1;
text -e -l ($step+"/"+$lastStep) asBSWizardStepText;
button -e -c ("asFaceHelpImage asBSWizardStep"+$step) asBSWizardHelpButton;
if (`window -q -ex faceHelpImage`)
	asFaceHelpImage ("asBSWizardStep"+$step);
if (`objExists deleteThis`)
	delete deleteThis;
if (`objExists tempAnimCurve`)
	delete tempAnimCurve;
asGoToBuildPose faceSetup;

string $objAttr;
float $value;
if ($step==1)
	{$objAttr="ctrlBrow_R.translateY";$value=-1;}
if ($step==2)
	{$objAttr="ctrlBrow_R.translateY";$value=1;}
if ($step==3)
	{$objAttr="ctrlBrow_R.translateX";$value=1;}
if ($step==4)
	{$objAttr="ctrlBrow_R.translateX";$value=-1;}
if ($step==5)
	{$objAttr="ctrlBrow_R.squeeze";$value=10;}
if ($step==6)
	{$objAttr="ctrlBrow_R.outerUpDown";$value=10;}
if ($step==7)
	{$objAttr="ctrlBrow_R.outerUpDown";$value=-10;}
if ($step==8)
	{$objAttr="ctrlEye_R.squint";$value=10;}
if ($step==9)
	{$objAttr="ctrlCheek_R.translateY";$value=1;}
if ($step==10)
	{$objAttr="ctrlCheek_R.translateX";$value=1;}
if ($step==11)
	{$objAttr="ctrlCheek_R.translateX";$value=-1;}
if ($step==12)
	{$objAttr="ctrlNose_R.translateY";$value=1;}
if ($step==13)
	{$objAttr="ctrlNose_R.translateX";$value=1;}
if ($step==14)
	{$objAttr="ctrlNose_R.translateX";$value=-1;}
if ($step==15)
	{$objAttr="ctrlNose_R.furrowDeepener";$value=10;}
if ($step==16)
	{$objAttr="ctrlMouth_M.translateY";$value=-1;}
if ($step==17)
	{$objAttr="ctrlMouth_M.translateX";$value=1;}
if ($step==18)
	{$objAttr="ctrlMouth_M.translateX";$value=-1;}
if ($step==19)
	{
	//jawSide can not be tweaked at the moment, as it drives 2 shapes..skipping..
	//	$objAttr="ctrlMouth_M.jawSide";$value=10;
	asBSWizardNext;
	return;
	}
if ($step==20)
	{$objAttr="ctrlMouth_M.jawForward";$value=10;}
if ($step==21)
	{$objAttr="ctrlMouth_M.jawForward";$value=-10;}
if ($step==22)
	{$objAttr="ctrlMouth_M.jawShut";$value=10;}
if ($step==23)
	{$objAttr="ctrlMouth_M.chinRaiser";$value=10;}
if ($step==24)
	{$objAttr="ctrlMouth_M.oh";$value=10;}
if ($step==25)
	{$objAttr="ctrlMouth_M.pucker";$value=10;}
if ($step==26)
	{$objAttr="ctrlMouth_M.funnel";$value=10;}
if ($step==27)
	{$objAttr="ctrlMouth_M.lipPress_R";$value=10;}
if ($step==28)
	{$objAttr="ctrlMouth_M.lipUpperRoll_R";$value=10;}
if ($step==29)
	{$objAttr="ctrlMouth_M.lipUpperRoll_R";$value=-10;}
if ($step==30)
	{$objAttr="ctrlMouth_M.lipLowerRoll_R";$value=10;}
if ($step==31)
	{$objAttr="ctrlMouth_M.lipLowerRoll_R";$value=-10;}
if ($step==32)
	{$objAttr="ctrlMouthCorner_R.translateY";$value=-1;}
if ($step==33)
	{$objAttr="ctrlMouthCorner_R.translateY";$value=1;}
if ($step==34)
	{$objAttr="ctrlMouthCorner_R.translateX";$value=1;}
if ($step==35)
	{$objAttr="ctrlMouthCorner_R.translateX";$value=-1;}
if ($step==36)
	{$objAttr="ctrlMouthCorner_R.dimpler";$value=10;}
if ($step==37)
	{$objAttr="ctrlMouthCorner_R.stretcher";$value=10;}
if ($step==38)
	{
	print ("All Shapes Complete.\n");
	asBSWizardStop;
	if (`window -q -ex faceHelpImage`)
		deleteUI faceHelpImage;
	return;
	}

text -e -l $objAttr asBSWizardObjAttrText;
text -e -l $value asBSWizardValueText;

currentTime 1;
setKeyframe $objAttr;
currentTime 10;
setAttr $objAttr $value;
setKeyframe $objAttr;
string $tempString[]=`listConnections $objAttr`;
rename $tempString[0] tempAnimCurve;
asBSAdjustTarget;
}

global proc asFaceCreateTongueJoints ()
{
string $jawControl=`textField -q -tx asFsJawControlTextField`;
$eyeJoint=`textField -q -tx ("asFsEyeJoint_RTextField")`;
float $scale=`asFaceGetScale`;

if (`objExists faceRigTongue0`)
	error "Object \"faceRigTongue0\" Already exists";
select -cl;
joint -n faceRigTongue0;
float $posA[3]=`xform -q -ws -t $jawControl`;
float $posB[3]=`xform -q -ws -t $eyeJoint`;
xform -ws -t 0 $posA[1] ($posA[2]+$posB[2]/2.0) faceRigTongue0;
setAttr -type float3 faceRigTongue0.jo 180 -90 0;
joint -n faceRigTongue1;
setAttr faceRigTongue1.tx ($scale*0.75);
joint -n faceRigTongue2;
setAttr faceRigTongue2.tx ($scale*0.75);
joint -n faceRigTongue3;
setAttr faceRigTongue3.tx ($scale*0.75);
joint -n faceRigTongue4;
setAttr faceRigTongue4.tx ($scale*0.75);
parent faceRigTongue0 FaceFitSkeleton;
select faceRigTongue0;
}

global proc asBSAdjustTarget ()
{
select asFaceBS;
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $skinCluster=`textField -q -tx asFsSkinClusterTextField`;
string $targets[]=`listAttr -m asFaceBS.weight`;
string $targetLeft;
int $targetNum;
float $targetWeights[];
float $targetWeightsSum=0;
for ($i=0;$i<size($targets);$i++)
    {
    $targetWeights[$i]=`getAttr ("asFaceBS."+$targets[$i])`;
    $targetWeightsSum+=$targetWeights[$i];
    if ($targetWeights[$i]>0.99 && $targetWeights[$i]<1.01)
        $targetNum=$i;
    }
if ($targetWeightsSum>1.01 || $targetWeightsSum<0.99)
	{
	for ($i=0;$i<size($targets);$i++)
		if ($targetWeights[$i]>0.001 || $targetWeights[$i]<-0.001)
			print ("asFaceBS."+$targets[$i]+" = "+$targetWeights[$i]+"\n");
  error "Must have one target set to \"1\", and the rest set to \"0\\n";
  }
if (`objExists deleteThis`)
	delete deleteThis;
createNode -n deleteThis transform;
float $cheekPos[]=`xform -q -ws -t cheekOuter`;
string $targetName=$targets[$targetNum];
if (`objExists $targetName`)
	error ("Object "+$targetName+" exists");
if (!`attributeExists ($targetName+"_tweaked") FaceFitSkeleton`)
	addAttr -k 1 -dv 1 -ln ($targetName+"_tweaked") -at bool FaceFitSkeleton;
setAttr ("FaceFitSkeleton."+$targetName+"_tweaked") 1;
if (`gmatch $targetName "*_R"`)
	{
	$targetLeft=`substitute "_R" $targetName "_L"`;
		if (!`attributeExists ($targetLeft+"_tweaked") FaceFitSkeleton`)
			addAttr -k 1 -dv 1 -ln ($targetLeft+"_tweaked") -at bool FaceFitSkeleton;
	setAttr ("FaceFitSkeleton."+$targetLeft+"_tweaked") 1;
	}
setAttr ($skinCluster+".envelope") 0;
duplicate -n $targetName $geometry;
setAttr ($skinCluster+".envelope") 1;
parent $targetName deleteThis;
move -r ($cheekPos[0]*2.5) 0 0 $targetName;
select $targetName;
string $tempString[]=`listRelatives -s $targetName`;
for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
connectAttr -f ($targetName+".worldMesh[0]") ("asFaceBS.inputTarget[0].inputTargetGroup["+$targetNum+"].inputTargetItem[6000].inputGeomTarget");

if (`gmatch $targetName "*_R"`)
    {
    refresh;
    $targetLeft=`substitute "_R" $targetName "_L"`;
    setAttr asFaceBS.envelope 0;
    duplicate -n $targetLeft $geometry;
    parent $targetLeft deleteThis;
    setAttr asFaceBS.envelope 1;
    move -r ($cheekPos[0]*-2.5) 0 0 $targetLeft;
    $tempString=`listRelatives -s $targetLeft`;
    for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
    duplicate -n ($targetLeft+"MirrorDriver") $targetLeft;
    setAttr ($targetLeft+"MirrorDriver.sx") -1;
    setAttr ($targetLeft+"MirrorDriver.v") 0;
/*
    deformer -type wrap $targetLeft;
    select -r $targetLeft ($targetLeft+"MirrorDriver");
    AddWrapInfluence;
*/
    select -r $targetLeft ($targetLeft+"MirrorDriver");
		CreateWrap;
    $tempString=`listConnections ($targetLeft+"MirrorDriver.inflType")`;
		rename $tempString[0] asFaceMirroWrap;
		setAttr asFaceMirroWrap.exclusiveBind 1;
    connectAttr -f ($targetName+".outMesh") ($targetLeft+"MirrorDriver.inMesh");
    
    for ($i=0;$i<size($targets);$i++)
        if ($targets[$i]==$targetLeft)
            connectAttr -f ($targetLeft+".worldMesh[0]") ("asFaceBS.inputTarget[0].inputTargetGroup["+$i+"].inputTargetItem[6000].inputGeomTarget");
    }

floatSlider -e -en 1 asFaceBSFloatSlider;
connectControl asFaceBSFloatSlider ("asFaceBS."+$targetName);
select $targetName;
}

global proc asFaceConvertSoftModToControl (int $convertingBack)
{
global string $gSelect;
string $sel[]=`ls -sl`;
float $pos[3],$posSoftMod[3],$posControl[3],$currentT[3],$currentR[3],$currentS[3];
string $tempString[],$historyList[];
string $side;
int $multiply;
int $autoKeyState=`autoKeyframe -q -state`;
string $fitJoint,$restoreCmd,$setAttrCmdExtra,$softModSet;
string $geometry=`textField -q -tx asFsGeometryTextField`;
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*Handle*"`)
		$sel[0]=$sel[$i];

if ($convertingBack)
	{
	if (!`gmatch $sel[0] "convertedSoftModHandle_*"`)
		error "convertedSoftModHandle not selected";
	tokenize $sel[0] "_" $tempString;
	$fitJoint=$tempString[1];
	$side="_"+$tempString[2];
	$tempString=`listConnections ("convertedSoftMod_"+$fitJoint+"_R.message")`;
	$softModSet=$tempString[0];
	}
else
	{
	string $allBefore[]=`ls`;
	if (!`gmatch $sel[0] "softMod*"`)
		error "Selection is not a new SoftMod, name does not match \"softMod*\"";
	if (`promptDialog -t "New Control" -m "Enter Name:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
		return;
	$fitJoint=`promptDialog -query -text`;
	if (`objExists $fitJoint` || $fitJoint=="")
		error "not a unique name";
	setToolTo $gSelect;

	//find $side, when tx=0
	float $locPos[3]=`getAttr ($sel[0]+".t")`;
	setAttr -type float3 ($sel[0]+".t") 0 0 0;
	float $pos[3]=`xform -q -ws -piv $sel[0]`;
	setAttr -type float3 ($sel[0]+".t") $locPos[0] $locPos[1] $locPos[2];
	$side="_M";
	if (!`checkBox -q -v asFaceIsMiddleControlCheckBox`)
		$side="_R";
	if ($pos[0]>0.001)
		error "SoftMod must be on Right side, or middle, currenly on Left side";

	$sel[0]=`rename $sel[0] ("convertedSoftModHandle_"+$fitJoint+$side)`;
	$tempString=`listConnections ("convertedSoftModHandle_"+$fitJoint+$side+".worldMatrix[0]")`;
	rename $tempString[0] ("convertedSoftMod_"+$fitJoint+$side);
	$tempString=`listConnections ("convertedSoftMod_"+$fitJoint+$side+".message")`;
	$softModSet=$tempString[0];
	string $deformObjs[]=`sets -q -no $softModSet`;
	$deformObjs=`stringArrayRemoveDuplicates $deformObjs`;

	$currentT=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".t")`;
	$currentR=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".r")`;
	$currentS=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".s")`;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".t") 0 0 0;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".r") 0 0 0;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".s") 1 1 1;
	$posSoftMod=`xform -q -ws -piv ("convertedSoftModHandle_"+$fitJoint+$side)`;
	curve -n tempCurve -d 1 -p $posSoftMod[0] $posSoftMod[1] $posSoftMod[2] -p $posSoftMod[0] $posSoftMod[1] $posSoftMod[2] -k 0 -k 1;
	deformer -type wrap tempCurve;
	select -r tempCurve;
	select -add $geometry;
	AddWrapInfluence;

	$posControl=`xform -q -ws -t tempCurve.cv[0]`;
	createNode -n tempTransform transform;
	xform -ws -t $posControl[0] $posControl[1] $posControl[2] tempTransform;
	select tempTransform;
	int $color=6;
	if (size($deformObjs)>1)
		$color=9;
	asCreateFaceFitJoint $fitJoint `getAttr ("convertedSoftMod_"+$fitJoint+$side+".falloffRadius")` $color;
	softCluster $fitJoint $fitJoint 1 $side;
	
	if ($side=="_R")
		{
		//Mirror pose before doing left to ensure identical attachment
		string $restoreCmd=`asFaceMirror`;
		softCluster $fitJoint $fitJoint -1 "_L";
		$setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_R;xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_L;";
	
		eval ($restoreCmd);
		if ($autoKeyState)
			autoKeyframe -state 1;
		}
	else
		$setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_M;";


	delete tempCurve tempTransform;
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".t") $currentT[0] $currentT[1] $currentT[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".r") $currentR[0] $currentR[1] $currentR[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".s") $currentS[0] $currentS[1] $currentS[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	//add to faceBuildPose
	setAttr -type "string" faceBuildPose.udAttr (`getAttr faceBuildPose.udAttr`+$setAttrCmdExtra);

	//FaceAllset
	string $allAfter[]=`ls`;
	string $allNew[];
	for ($i=0;$i<size($allAfter);$i++)
		if (!`stringArrayCount $allAfter[$i] $allBefore`)
			if (`objectType $allAfter[$i]`!="objectSet")
				$allNew[size($allNew)]=$allAfter[$i];
	sets -add FaceAllSet $allNew;
	sets -remove FaceAllSet `listRelatives -ad FaceFitSkeleton`;
	}

float $t[3]=`xform -q -ws -piv $sel[0]`;
float $r[3]=`xform -q -ws -ro $sel[0]`;
float $s[3]=`xform -q -r -s $sel[0]`;
setAttr -type float3 ($sel[0]+".t") 0 0 0;
setAttr -type float3 ($sel[0]+".r") 0 0 0;
setAttr -type float3 ($sel[0]+".s") 1 1 1;

$pos=`xform -q -ws -t $fitJoint`;
string $softMod=`substitute "convertedSoftModHandle" $sel[0] "convertedSoftMod"`;
string $cluster=$fitJoint+"Cluster"+$side;
float $falloffRadius=`getAttr ($softMod+".falloffRadius")`;

float $falloffMode=`getAttr ($softMod+".falloffMode")`;
setAttr ($fitJoint+".falloffRadius") $falloffRadius;
setAttr ($fitJoint+".falloffMode") $falloffMode;

select $softModSet;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
$vtxs=`ls -sl -fl`;
polySelectConstraint -m 0;

percent -v 0 $cluster $geometry;
asFaceSoftModToCluster $softMod $cluster $vtxs;
delete $softMod;
if ($convertingBack)
	asFaceMirrorClusterWeights ($fitJoint+$side);
xform -ws -t $t[0] $t[1] $t[2] -ro $r[0] $r[1] $r[2] -s $s[0] $s[1] $s[2] ($fitJoint+$side);
select ($fitJoint+$side);
}

global proc asFaceConvertControlToSoftMod ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $allFaceGeoString=`textField -q -tx asFsAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a face control";
string $tempString[]=`listRelatives -p $sel[0]`;
if (!`gmatch $tempString[0] "*Subtract*"`)
	error "Selected object is not a \"cluster\" control";
tokenize $sel[0] "_" $tempString;
string $fitJoint=$tempString[0];
string $side="_"+$tempString[1];
if ($side=="_L")
	error "must be Right side";
float $falloffRadius=`getAttr ($fitJoint+".falloffRadius")`;
float $falloffMode=`getAttr ($fitJoint+".falloffMode")`;

float $t[3]=`xform -q -ws -t $sel[0]`;
float $r[3]=`xform -q -ws -ro $sel[0]`;
float $s[3]=`xform -q -r -s $sel[0]`;
setAttr -type float3 ($sel[0]+".t") 0 0 0;
setAttr -type float3 ($sel[0]+".r") 0 0 0;
setAttr -type float3 ($sel[0]+".s") 1 1 1;
float $pos[3]=`xform -q -ws -t $sel[0]`;
select -r $geometry;
string $tempString[]=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ("convertedSoftMod_"+$sel[0])`;
string $softModHandle=`rename $tempString[1] ("convertedSoftModHandle_"+$sel[0])`;
string $tempString[]=`listConnections ($softMod+".message")`;
string $softModSet=$tempString[0];
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]) $pos[1] $pos[2];
xform -piv ($pos[0]) $pos[1] $pos[2] $softModHandle;
xform -ws -t ($t[0]-$pos[0]) ($t[1]-$pos[1]) ($t[2]-$pos[2]) -ro $r[0] $r[1] $r[2] -s $s[0] $s[1] $s[2] $softModHandle;

if (`getAttr ($fitJoint+".overrideColor")`==9)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!=$geometry)
			sets -add $softModSet $allFaceGeo[$i];
	}

float $radiusUp,$radiusLeft,$radiusRight,$radiusDown;
columnLayout -e -m 0 asFaceDirectionRadisuColumnLayout;
if (`getModifiers`%8)
	columnLayout -e -m 1 asFaceDirectionRadisuColumnLayout;
if (`attributeExists radiusUp $fitJoint`)
	{
	columnLayout -e -m 1 asFaceDirectionRadisuColumnLayout;
	$radiusUp=`getAttr ($fitJoint+".radiusUp")`;
	$radiusLeft=`getAttr ($fitJoint+".radiusLeft")`;
	$radiusRight=`getAttr ($fitJoint+".radiusRight")`;
	$radiusDown=`getAttr ($fitJoint+".radiusDown")`;
	}
else
	$radiusUp=$radiusLeft=$radiusRight=$radiusDown=$falloffRadius;
floatField -e -v $radiusUp asFaceDirWgtsUpFloatField;
floatField -e -v $radiusLeft asFaceDirWgtsLeftFloatField;
floatField -e -v $radiusRight asFaceDirWgtsRightFloatField;
floatField -e -v $radiusDown asFaceDirWgtsDownFloatField;

select $softModHandle;
}

global proc asFaceResetDirWgts ()
{
string $sel[]=`ls -sl`;
string $tempString[];
tokenize $sel[0] "_" $tempString;
string $fitJoint=$tempString[1];

string $directions[]={"Up","Left","Right","Down"};
for ($i=0;$i<size($directions);$i++)
	{
	floatField -e -v 0 ("asFaceDirWgts"+$directions[$i]+"FloatField");
	if (`attributeExists ("radius"+$directions[$i]) $fitJoint`)
		deleteAttr ($fitJoint+".radius"+$directions[$i]);
	}
}

global proc asFaceGetDirWght (string $direction)
{
string $sel[]=`ls -sl`;
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*Handle*"`)
		$sel[0]=$sel[$i];
if (!`gmatch $sel[0] "convertedSoftModHandle_*"`)
	error "convertedSoftModHandle not selected";
string $softMod=`substitute "convertedSoftModHandle" $sel[0] "convertedSoftMod"`;
float $falloffRadius=`getAttr ($softMod+".falloffRadius")`;
floatField -e -v $falloffRadius ("asFaceDirWgts"+$direction+"FloatField");

string $tempString[];
string $directions[]={"Up","Left","Right","Down"};
tokenize $sel[0] "_" $tempString;
string $fitJoint=$tempString[1];
if (!`attributeExists radiusUp $fitJoint`)
	for ($i=0;$i<size($directions);$i++)
		addAttr -k 1 -ln ("radius"+$directions[$i]) -at double -dv `floatField -q -v ("asFaceDirWgts"+$directions[$i]+"FloatField")` $fitJoint;

setAttr ($fitJoint+".radius"+$direction) $falloffRadius;

//$falloffRadius==largest dirWght radius
if (`attributeExists radiusUp $fitJoint`)
	for ($i=0;$i<size($directions);$i++)
		if (`floatField -q -v ("asFaceDirWgts"+$directions[$i]+"FloatField")`>$falloffRadius)
			$falloffRadius=`floatField -q -v ("asFaceDirWgts"+$directions[$i]+"FloatField")`;
setAttr ($fitJoint+".falloffRadius") $falloffRadius;
}

global proc asFaceSoftRegions ()
{
global string $gSelect;
setToolTo $gSelect;
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
string $geometry=`textField -q -tx asFsGeometryTextField`;
float $scale=`asFaceGetScale`;
int $numVtxs[];
float $value,$min,$max;
float $pos[3],$pos2[3];
string $name;
string $skinCluster;
string $tempString[],$allFaceGeo[];
string $allFaceGeoString=`textField -q -tx asFsAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//squashHead
float $scale=`asFaceGetScale`;
float $squashTopPos[3]=`xform -q -ws -t squashTop`;
float $squashBasePos[3]=`xform -q -ws -t squashBase`;
float $BaseToTopY=$squashTopPos[1]-$squashBasePos[1];

$tempString[0]=`curve -d 1 -p 1 1 1 -p 1 -1 1 -p -1 -1 1 -p -1 1 1 -p 1 1 1 -p 1 1 -1 -p 1 -1 -1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 1 -1 -p 1 1 -1 -p -1 1 -1 -p -1 1 1 -p -1 -1 1 -p -1 -1 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15`;
rename $tempString[0] squashTop_M;
setAttr squashTop_MShape.overrideEnabled 1;
setAttr squashTop_MShape.overrideColor 13;
createNode -n squashTopOffset transform;
parent squashTop_M squashTopOffset;
xform -ws -t 0 $squashTopPos[1] 0 squashTopOffset;
$pos=`xform -q -ws -t cheekOuter`;
xform -ws -s ($pos[0]*1) ($scale/5.0) ($scale/5.0) squashTop_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashTop_M;
sets -add "FaceControlSet" squashTop_M;
duplicate -n squashBaseOffset squashTopOffset;
rename squashBaseOffset|squashTop_M squashBase_M;
xform -ws -t 0 $squashBasePos[1] 0 squashBaseOffset;
duplicate -n squashMiddleOffset squashTopOffset;
rename squashMiddleOffset|squashTop_M squashMiddle_M;
xform -ws -t 0 (($squashBasePos[1]+$squashTopPos[1])/2) 0 squashMiddleOffset;
scale -r 1.5 1 1 squashMiddle_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashMiddle_M;
parent squashTopOffset squashMiddleOffset squashBase_M;

addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 squashTop_M;
createNode -n squashTopVolumeUC unitConversion;
setAttr squashTopVolumeUC.conversionFactor 0.1;
connectAttr squashTop_M.volume squashTopVolumeUC.input;

setAttr -l 1 -k 0 squashTop_M.rx;setAttr -l 1 -k 0 squashTop_M.ry;setAttr -l 1 -k 0 squashTop_M.rz;
setAttr -l 1 -k 0 squashTop_M.sx;setAttr -l 1 -k 0 squashTop_M.sy;setAttr -l 1 -k 0 squashTop_M.sz;
setAttr -l 1 -k 0 squashTop_M.v;
setAttr -l 1 -k 0 squashMiddle_M.rx;setAttr -l 1 -k 0 squashMiddle_M.ry;setAttr -l 1 -k 0 squashMiddle_M.rz;
setAttr -l 1 -k 0 squashMiddle_M.sx;setAttr -l 1 -k 0 squashMiddle_M.sy;setAttr -l 1 -k 0 squashMiddle_M.sz;
setAttr -l 1 -k 0 squashMiddle_M.v;
setAttr -l 1 -k 0 squashBase_M.sx;setAttr -l 1 -k 0 squashBase_M.sy;setAttr -l 1 -k 0 squashBase_M.sz;
setAttr -l 1 -k 0 squashBase_M.v;

select $allFaceGeo;
$tempString=`lattice  -divisions 2 11 2 -objectCentered true  -ldv 2 2 2`;
rename $tempString[0] squashFfd;
rename $tempString[1] squashFfdLattice;
rename $tempString[2] squashFfdBase;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdLattice;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdBase;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdLattice;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdBase;
scale -r 1.25 1.25 1.25 squashFfdLattice;
scale -r 1.25 1.25 1.25 squashFfdBase;
setAttr "squashFfd.outsideLattice" 1;
parent squashFfdBase squashBase_M;
float $pos[3];
createNode -n squashXup transform;
setAttr -type float3 squashXup.r 90 0 90;
select squashXup;
$pos=`xform -q -ws -t squashFfdLattice.pt[0][1][1]`;
joint -n squashIKX0 -p 0 $pos[1] 0;
select squashXup;
for ($i=1;$i<10;$i++)
    {
    $pos=`xform -q -ws -t squashFfdLattice.pt[0][$i][1]`;
    joint -n ("squashIKX"+$i) -p 0 $pos[1] 0;
    }
$tempString=`ikHandle -n squashIKHandle -ccv 1 -ns 2 -sol ikSplineSolver -sj squashIKX1 -ee squashIKX9`;
rename $tempString[1] squashIKEffector;
rename $tempString[2] squashIKECurve;
for ($i=0;$i<5;$i++)
    {
    select -r squashIKECurve.cv[$i];
    $tempString=`newCluster " -envelope 1"`;
    rename $tempString[0] ("squashIKCluster"+$i);
    rename $tempString[1] ("squashIKClusterHandle"+$i);
    }  
select -cl;
for ($i=0;$i<10;$i++)
    select -add ("squashIKX"+$i);
select -add squashFfdLattice;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] squashIKSC;

skinPercent -tv squashIKX0 1 squashIKSC squashFfdLattice.pt[0:1][0:1][0:1];
skinPercent -tv squashIKX2 1 squashIKSC squashFfdLattice.pt[0:1][2][0] squashFfdLattice.pt[0:1][2][1];
skinPercent -tv squashIKX3 1 squashIKSC squashFfdLattice.pt[0:1][3][0] squashFfdLattice.pt[0:1][3][1];
skinPercent -tv squashIKX4 1 squashIKSC squashFfdLattice.pt[0:1][4][0] squashFfdLattice.pt[0:1][4][1];
skinPercent -tv squashIKX5 1 squashIKSC squashFfdLattice.pt[0:1][5][0] squashFfdLattice.pt[0:1][5][1];
skinPercent -tv squashIKX6 1 squashIKSC squashFfdLattice.pt[0:1][6][0] squashFfdLattice.pt[0:1][6][1];
skinPercent -tv squashIKX7 1 squashIKSC squashFfdLattice.pt[0:1][7][0] squashFfdLattice.pt[0:1][7][1];
skinPercent -tv squashIKX8 1 squashIKSC squashFfdLattice.pt[0:1][8][0] squashFfdLattice.pt[0:1][8][1];
skinPercent -tv squashIKX9 1 squashIKSC squashFfdLattice.pt[0:1][9:10][0:1];

delete `pointConstraint squashIKClusterHandle4 squashIKClusterHandle3`;
parent squashIKClusterHandle3 squashIKClusterHandle4;
move -r 0 ($scale*-0.1) 0 ;

parent squashIKClusterHandle4 squashTop_M;
parent squashIKClusterHandle2 squashMiddle_M;
parent squashIKClusterHandle0 squashIKClusterHandle1 squashIKX0 squashBase_M;

createNode -n squashIKCurveInfo curveInfo;
connectAttr squashIKECurveShape.worldSpace[0] squashIKCurveInfo.inputCurve;
createNode -n squashIKCurveInfoNormalize multiplyDivide;
setAttr squashIKCurveInfoNormalize.operation 2;
connectAttr squashIKCurveInfo.arcLength squashIKCurveInfoNormalize.input1X;
setAttr squashIKCurveInfoNormalize.input2X `getAttr squashIKCurveInfoNormalize.input1X`;
createNode -n squashIKScale multiplyDivide;
connectAttr squashIKCurveInfoNormalize.outputX squashIKScale.input1X;
createNode -n squashIKStretch multiplyDivide;
connectAttr squashIKScale.outputX squashIKStretch.input2X;
setAttr squashIKStretch.input1X `getAttr squashIKX2.tx`;

//connectAttr squashIKScale.outputX squashIKStretch.input1X;
connectAttr FollowHead.sx squashIKScale.input2X;
setAttr "squashIKScale.operation" 2;
for ($i=1;$i<10;$i++)
    connectAttr squashIKStretch.outputX ("squashIKX"+$i+".tx");
createNode -n squashVolume1Over multiplyDivide;
connectAttr squashIKScale.outputX squashVolume1Over.input2X;
setAttr "squashVolume1Over.input1X" 1;
setAttr "squashVolume1Over.operation" 2;
createNode -n squashVolumePow multiplyDivide;
connectAttr squashVolume1Over.outputX squashVolumePow.input1X;
setAttr "squashVolumePow.operation" 3;
setAttr "squashVolumePow.input2X" 0.5;
createNode -n squashBlendTwo blendTwoAttr;
setAttr squashBlendTwo.input[0] 1;
connectAttr squashVolumePow.outputX squashBlendTwo.input[1];
connectAttr squashTopVolumeUC.output squashBlendTwo.attributesBlender;
for ($i=2;$i<9;$i++)
    {
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sy");
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sz");
    }
    
parent squashFfdLattice squashIKECurve squashIKHandle RegionSetup;
parent squashBaseOffset squashIKX1 FollowHead;
delete squashXup;

setAttr -l 1 squashIKX1.v 0;
setAttr -l 1 squashFfdBase.v 0;
setAttr -l 1 squashIKHandle.v 0;
setAttr -l 1 squashIKX0.v 0;
for ($i=0;$i<5;$i++)
    setAttr -l 1 ("squashIKClusterHandle"+$i+".v") 0;

addAttr -k 0 -ln curveVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.curveVis;
connectAttr squashTop_M.curveVis squashIKECurve.v;
addAttr -k 0 -ln LatticeVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.LatticeVis;
connectAttr squashTop_M.LatticeVis squashFfdLattice.v;


/*
$tempString=`nonLinear -type squash  -lowBound -1 -highBound 1 -startSmoothness 0 -endSmoothness 0 -maxExpandPos 0.5 -expand 1 -factor 0`;
rename $tempString[0] squashHead;
rename $tempString[1] squashHeadHandle;
*/
/*
for ($i=0;$i<size($allFaceGeo);$i++)
	{
	$tempString=`listHistory $allFaceGeo[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			{
			$skinCluster=$tempString[$y];
			if (`stringArrayCount asFaceBS $tempString`)
				reorderDeformers asFaceBS squashHead $allFaceGeo[$i];
			else
				reorderDeformers $skinCluster squashHead $allFaceGeo[$i];
			}
	}
*/
/*
createNode -n squashHeadOffset transform;
parent squashHeadHandle squashHeadOffset;
setAttr -type float3 squashHeadHandle.t 0 0 0;
setAttr -type float3 squashHeadHandle.s 1 1 1;
parent squashHeadOffset FollowHead;
setAttr squashHead.lowBound 0;
$temp=`xform -q -ws -t squashBase`;
float $currentPos[]=`xform -q -ws -t squashHeadHandle`;
xform -ws -t $currentPos[0] $temp[1] $currentPos[2] squashHeadOffset;
duplicate -n messureSquashHeight squashTop;
parent messureSquashHeight squashBase;
float $squashHeight=`getAttr messureSquashHeight.ty`;
delete messureSquashHeight;
setAttr -type float3 squashHeadOffset.s $squashHeight $squashHeight $squashHeight;
*/
}

global proc asFaceCreateRegionLocator (string $region)
{
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
float $temp[3]=`xform -q -ws -t $headJoint`;
if (`objExists ($region+"Locator")`)
	delete ($region+"Locator");
spaceLocator -n ($region+"Locator");
parent ($region+"Locator") FaceFitSkeleton;
xform -ws -t $temp[0] $temp[1] $temp[2] ($region+"Locator");
float $ty;
float $scale=`asFaceGetScale`;
if ($region=="underChin")
	$ty=$scale*-1.3;
if ($region=="underEye")
	$ty=$scale*1.1;
if ($region=="overEye")
	$ty=$scale*3.5;
move -r 0 $ty 0 ($region+"Locator");
}

global proc asFaceDeleteSoftModHistory ()
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $history[]=`listHistory $geometry`;
for ($i=0;$i<size($history);$i++)
	if (`gmatch $history[$i] "softMod*"`)
		if (`objExists $history[$i]`)
			delete $history[$i];
}

/*
global proc asFaceMirrorSdkAndSetInfinity ()
{
//MirrorSDK
string $drivens[]=`listConnections faceCtrlDriven.drawInfo`;
string $animCurves[],$tempString[];
string $side,$connectionOutPlug,$connectionInPlug,$oppositeConnectionOutPlug,$oppositeConnectionInPlug,$newAnimCurve;
for ($i=0;$i<size($drivens);$i++)
	{
	tokenize $drivens[$i] "_" $tempString;
	$side="_"+$tempString[1];
	if ($side!="_R")
		continue;
	$animCurves=`listConnections -scn 1 -s 1 -d 0 -type animCurve $drivens[$i]`;
	for ($y=0;$y<size($animCurves);$y++)
		if (!`gmatch $animCurves[$y] "*_R*"`)
			$animCurves[$y]=`rename $animCurves[$y] ($animCurves[$y]+"_R")`;
	for ($y=0;$y<size($animCurves);$y++)
		{
		$newAnimCurve=`substitute "_R" $animCurves[$y] "_L"`;
		$tempString=`listConnections -p 1 ($animCurves[$y]+".output")`;
		$connectionOutPlug=$tempString[0];
		$oppositeConnectionOutPlug=`substitute "_R" $connectionOutPlug "_L"`;
		$tempString=`listConnections -p 1 ($animCurves[$y]+".input")`;
		$connectionInPlug=$tempString[0];
		$oppositeConnectionInPlug=`substitute "_R" $connectionInPlug "_L"`;

		$tempString=`listConnections ($animCurves[$y]+".input")`;
		$driver=`substitute "_R" $tempString[0] ""`;

		if (`objExists $newAnimCurve`)
			delete $newAnimCurve;

		duplicate -n $newAnimCurve $animCurves[$y];
		connectAttr ($newAnimCurve+".output") $oppositeConnectionOutPlug;
		connectAttr -f $connectionInPlug ($newAnimCurve+".input");

		select -cl;
		if (`gmatch $newAnimCurve "*_translateX*"`)
			{
			selectKey -add -k $newAnimCurve;
			scaleKey -iub false -ts 1 -tp 0 -fs 1 -fp 0 -vs -1 -vp 0 -animation keys;
			}
		if (`gmatch $newAnimCurve "*_rotateY*"`)
			{
			selectKey -add -k $newAnimCurve;
			scaleKey -iub false -ts 1 -tp 0 -fs 1 -fp 0 -vs -1 -vp 0 -animation keys;
			}
		if (`gmatch $newAnimCurve "*_rotateZ*"`)
			{
			selectKey -add -k $newAnimCurve;
			scaleKey -iub false -ts 1 -tp 0 -fs 1 -fp 0 -vs -1 -vp 0 -animation keys;
			}
		}
	}

//Infinity
string $sdkControls[]=`listConnections -s 0 -d 1 faceCtrlDriven.drawInfo`;
string $jawControl=`textField -q -tx asFsJawControlTextField`;
if (`objExists ($jawControl+"_aimConstraint")`)
	$sdkControls[size($sdkControls)]=($jawControl+"_aimConstraint");
string $animCurves[];
for ($i=0;$i<size($sdkControls);$i++)
	{
	$animCurves=`listConnections -scn 1 -s 1 -d 0 -type animCurve $sdkControls[$i]`;
	for ($y=0;$y<size($animCurves);$y++)
		{
		setAttr ($animCurves[$y]+".preInfinity") 1;
		setAttr ($animCurves[$y]+".postInfinity") 1;
		}
	}
}
*/

global proc asFaceToggleFaceFitSkeleton ()
{
if (!`objExists FaceMotionSystem`)
	return;
setAttr -l 0 FaceFitSkeleton.visibility;
setAttr -l 1 FaceFitSkeleton.visibility (!`getAttr FaceFitSkeleton.visibility`);
setAttr FaceMotionSystem.visibility (!`getAttr FaceMotionSystem.visibility`);
}

/*
global proc asFaceGoToBuildPose ()
{
eval `getAttr faceBuildPose.udAttr`;
}
*/

global proc asFaceJointToVtxCopy ()
{
int $vtx;
float $pos[];
string $cmd;
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $joints[]=`listRelatives -c -type joint FaceFitSkeleton`;
createNode -n closestSampler closestPointOnMesh;
string $tempString[]=`listRelatives -ni -s $geometry`;
connectAttr -f ($tempString[0]+".outMesh") closestSampler.inMesh;
connectAttr -f ($geometry+".xformMatrix") closestSampler.inputMatrix;

for ($i=0;$i<size($joints);$i++)
	{
	$pos=`xform -q -ws -t $joints[$i]`;
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$vtx=`getAttr closestSampler.result.closestVertexIndex`;
	$cmd+="asFaceSnapJoint "+$joints[$i]+" "+$geometry+".vtx["+$vtx+"];";
	}
delete closestSampler;
button -e -en 1 -c $cmd asFSJointToVtxPasteButton;
print ("Joints realation to vertex copied\n");
}

global proc asFaceSnapJoint (string $joint, string $objVtx)
{
float $pos[]=`xform -q -ws -t $objVtx`;
xform -ws -t $pos[0] $pos[1] $pos[2] $joint;
}

global proc string asFaceNrToLetter (int $nr)
{
string $letter;
if ($nr==0) $letter="";
if ($nr==1) $letter="A";
if ($nr==2) $letter="B";
if ($nr==3) $letter="C";
if ($nr==4) $letter="D";
if ($nr==5) $letter="E";
if ($nr==6) $letter="F";
if ($nr==7) $letter="G";
if ($nr==8) $letter="H";
if ($nr==9) $letter="I";
return $letter;
}

global proc int asFaceLetterToNr (string $letter)
{
int $nr;
if ($letter=="") $nr=0;
if ($letter=="A") $nr=1;
if ($letter=="B") $nr=2;
if ($letter=="C") $nr=3;
if ($letter=="D") $nr=4;
if ($letter=="E") $nr=5;
if ($letter=="F") $nr=6;
if ($letter=="G") $nr=7;
if ($letter=="H") $nr=8;
if ($letter=="I") $nr=9;
return $nr;
}

global proc asFaceAddJoints (string $region)
{
string $sel[]=`ls -sl`;
int $upperLowerFactor,$vtx,$middleRowNr;
string $ms;
string $tempString[];
int $rowNum=`intField -q -v ("asFs"+$region+"MiddleNum")`;
int $pointSnap=`checkBox -q -v ("asFs"+$region+"MiddlePointSnap")`;
string $upperLower;
int $color;
float $mag;
float $pos[3],$posInner[3],$posOuter[3];
string $geometry=`textField -q -tx asFsGeometryTextField`;

$tempString=`listRelatives -c -type joint FaceFitSkeleton`;
for ($joint in $tempString)
	if (`gmatch $joint ("*"+$region+"Middle*")`)
		delete $joint;

createNode -n closestSampler closestPointOnMesh;
string $tempString[]=`listRelatives -ni -s $geometry`;
connectAttr -f ($tempString[0]+".outMesh") closestSampler.inMesh;
connectAttr -f ($geometry+".xformMatrix") closestSampler.inputMatrix;

for ($i=1;$i<99;$i++)
	{
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1)
			$upperLower="upper";
		else
			$upperLower="lower";
	if (!`objExists ($upperLower+$region+"Inner"+$i)`)
		break;

		for ($y=1;$y<$rowNum+1;$y++)
			{
			select FaceFitSkeleton;
			$ms=`asFaceNrToLetter $y`;
			$color=24+$y;
			asFaceCreateFitJoint ($upperLower+$region+"Middle"+$ms+$i) 0.02 $color;
			pointConstraint ($upperLower+$region+"Inner"+$i) ($upperLower+$region+"Outer"+$i) ($upperLower+$region+"Middle"+$ms+$i);
			setAttr ($upperLower+$region+"Middle"+$ms+$i+"_pointConstraint1."+$upperLower+$region+"Inner"+$i+"W0") ($y*(1.0/($rowNum+1)));
			setAttr ($upperLower+$region+"Middle"+$ms+$i+"_pointConstraint1."+$upperLower+$region+"Outer"+$i+"W1") (1-($y*(1.0/($rowNum+1))));
			delete ($upperLower+$region+"Middle"+$ms+$i+"_pointConstraint1");
			setAttr ($upperLower+$region+"Middle"+$ms+$i+".overrideEnabled") 1;
			setAttr ($upperLower+$region+"Middle"+$ms+$i+".overrideColor") $color;
	
			if ($pointSnap)
				{
				$pos=`xform -q -ws -t ($upperLower+$region+"Middle"+$ms+$i)`;
				setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
				if ($region=="Lip")
					{
					//lip bulge
					$posInner=`xform -q -ws -t ($upperLower+$region+"Inner"+$i)`;
					$posOuter=`xform -q -ws -t ($upperLower+$region+"Outer"+$i)`;
					$mag=`mag <<($posOuter[0]-$posInner[0]),($posOuter[1]-$posInner[1]),($posOuter[2]-$posInner[2])>>`;
					setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] ($pos[2]+($mag/4.0));
					}
				$vtx=`getAttr closestSampler.result.closestVertexIndex`;
				select ($geometry+".vtx["+$vtx+"]");
				$pos=`xform -q -ws -t`;
				xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+$region+"Middle"+$ms+$i);
				}
			}
		}
	}
delete closestSampler;
select -cl;
for ($i=1;$i<size($sel);$i++)
	if (`objExists $sel[$i]`)
		select -add $sel[$i];
}

global proc asChooseInput (string $textField)
{
if (!`objExists FaceGroup`)
	asFaceCreateTopNode;

string $txt;
string $sel[]=`ls -sl`;

$txt=$sel[0];

//if (`gmatch $textField "*All*"`)
	if (size($sel)>1)
		for ($i=1;$i<size($sel);$i++)
			$txt+=" "+$sel[$i];	

string $skinCluster;
if ($textField=="asFsGeometryTextField" && $sel[0]!="")
	{
	string $tempString[]=`listHistory $sel[0]`;
	for ($i=0;$i<size($tempString);$i++)
		if (`objectType $tempString[$i]`=="skinCluster")
			{
			$skinCluster=$tempString[$i];
			textField -e -tx $skinCluster asFsSkinClusterTextField;
			optionVar -sv asFsSkinClusterTextField $tempString[$i];
			}
	if ($skinCluster=="")
		error "No skinCluster Found, You should BindSkin the Geometry to HeadJoint first";
	}

textField -e -tx $txt $textField;
optionVar -sv $textField $txt;
asFaceUpdateInfo 0;
}

global proc asFacePreBuildCheck ()
{
string $skinCluster=`textField -q -tx asFsSkinClusterTextField`;
if (!`objExists $skinCluster`)
	error "skinCluster not found";
if (`objExists PcageGroup`)
	if (!`objExists cageHead`)
		error "Found FaceCage, but not HeadCage..You must create a HeadCage";
string $jawControl=`textField -q -tx asFsJawControlTextField`;
if (`getAttr ($jawControl+".rz")`!=0)
	{
	select $jawControl;
	error ($jawControl+".rotateZ is not zero , it is: "+`getAttr ($jawControl+".rz")`+", Zero out this first.");
	}

/*
//Jaw joint should NOT be skinned
if (`objExists Jaw_M` && `objExists cageFace`)
	{
	string $tempString[]=`listConnections Jaw_M.worldMatrix`;
	if (`stringArrayCount $skinCluster $tempString`)
		error "Found \"Jaw_M\" joint skinned AND you are using FaceCage, Remove Jaw_M influence before building FaceSetup";
	}
*/
}

global proc asFaceFirstBuild ()
{
if (`objExists FaceMotionSystem`)
	error "AdvancedSkeleton FaceSetup already exists in the scene, use \"Rebuild\" instead if you want to re-generate the rig\n";
asFaceReBuild;
}

global proc asFaceReBuild ()
{
string $allSetMembers[],$faceControlSetMembers[];
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
//string $jawJoint=`textField -q -tx asFsJawJointTextField`;
string $jawControl=`textField -q -tx asFsJawControlTextField`;

asFacePreBuildCheck;

if (`objExists FaceMotionSystem`)
	{
	$skinCluster=`textField -q -tx asFsSkinClusterTextField`;
	$tempString=`listRelatives -ad -type joint "FaceMotionSystem"`;
	for ($node in $tempString)
		{
		$tempString2=`listConnections ($node+".worldMatrix[0]")`;
		if ($tempString2[0]==$skinCluster)
			skinCluster -e -ri $node $skinCluster;
		}
	$allSetMembers=`sets -q FaceAllSet`;
	$allSetMembers[size($allSetMembers)]="FaceAllSet";
	$allSetMembers[size($allSetMembers)]="FaceControlSet";

	//Pre rebuild - connections
	string $cmds[],$connections[],$connectionsObj[];
	$faceControlSetMembers=`sets -q FaceControlSet`;
	for ($i=0;$i<size($faceControlSetMembers);$i++)
		{
		//incoming connections
		$connections=`listConnections -p 1 -c 1 -s 1 -d 0 $faceControlSetMembers[$i]`;
		$connectionsObj=`listConnections -c 1 -s 1 -d 0 $faceControlSetMembers[$i]`;
		for ($y=0;$y<size($connections);$y=$y+2)
			{
		if (`sets -im FaceAllSet $connectionsObj[$y+1]`)
			continue;
			if (`gmatch $connectionsObj[$y+1] ($headJoint+"*")` || `gmatch $connectionsObj[$y+1] ($jawControl+"*")`)
				continue;
			$cmds[size($cmds)]="connectAttr -f "+$connections[$y+1]+" "+$connections[$y]+";";
			}
		//Outgoing connections
		$connections=`listConnections -p 1 -c 1 -s 0 -d 1 $faceControlSetMembers[$i]`;
		$connectionsObj=`listConnections -c 1 -s 0 -d 1 $faceControlSetMembers[$i]`;
		for ($y=0;$y<size($connections);$y=$y+2)
			{
			if (`sets -im FaceAllSet $connectionsObj[$y+1]`)
				continue;
			if (`gmatch $connections[$y] "*instObjGroups*"` || `gmatch $connections[$y+1] "*instObjGroups*"`)
				continue;
			$cmds[size($cmds)]="connectAttr -f "+$connections[$y]+" "+$connections[$y+1]+";";
			}
		}

	//prefix_
	for ($i=0;$i<size($allSetMembers);$i++)
		if (`objExists $allSetMembers[$i]`)
			$allSetMembers[$i]=`rename $allSetMembers[$i] ("prefix_"+$allSetMembers[$i])`;
		else
			$allSetMembers[$i]="";

	asFaceBuild;

	//Post rebuild - incoming connections
	for ($cmd in $cmds)
		if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

	for ($i=0;$i<size($allSetMembers);$i++)
		if (`objExists $allSetMembers[$i]`)
			delete $allSetMembers[$i];

	asGoToBuildPose faceSetup;//there might be info in the .run attribute
	}
else
	asFaceBuild;
}

global proc asSnapVtx (string $vtx, string $destination)
{
float $pos[3]=`xform -q -ws -t $destination`;
xform -ws -t $pos[0] $pos[1] $pos[2] $vtx;
}

global proc asAveraveSnapVtx(string $vtx, string $destination1, string $destination2, float $portion)
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $tempString[]=`spaceLocator -n tempLocator`;
string $tempLoc=$tempString[0];
geometryConstraint $geometry $tempLoc;
if ($portion<=1)
	{
	$tempString=`pointConstraint $destination1 $destination2 $tempLoc`;
	setAttr ($tempString[0]+"."+$destination1+"W0") (1-$portion);
	setAttr ($tempString[0]+"."+$destination2+"W1") $portion;
	}
else
	{
	float $pos1[3]=`xform -q -ws -t $destination1`;
	float $pos2[3]=`xform -q -ws -t $destination2`;
	float $delta[3]={$pos2[0]-$pos1[0],$pos2[1]-$pos1[1],$pos2[2]-$pos1[2]};
	xform -ws -t ($pos1[0]+($delta[0]*$portion)) ($pos1[1]+($delta[1]*$portion)) ($pos1[2]+($delta[2]*$portion)) $tempLoc;
	}
float $pos[]=`xform -q -ws -t $tempLoc`;
xform -ws -t $pos[0] $pos[1] $pos[2] $vtx;
delete $tempLoc;
}

global proc asFaceCageBuild ()
{
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
string $jawJoint=`textField -q -tx asFsJawJointTextField`;
string $skinCluster=`textField -q -tx asFsSkinClusterTextField`;
string $geometry=`textField -q -tx asFsGeometryTextField`;
int $numUpperEyeOuter;
for ($i=1;$i<99;$i++)
	if(!`objExists ("upperEyeOuter"+$i)`)
		{
		$numUpperEyeOuter=$i-1;
		break;
		}
int $halwWayUppEyeOuterNr=$numUpperEyeOuter/2;
float $scale=`asFaceGetScale`;
float $browHeight=$scale/10;
float $pos[3];
string $side;
string $tempString[];
string $browSCRequireds[]={"browMiddle","browInner","browHalf","browOuter","foreheadOuter","foreheadMiddle","noseMiddle"};
int $buildBrowSC=1;
for ($i=1;$i<size($browSCRequireds);$i++)
	if (!`objExists $browSCRequireds[$i]`)
		$buildBrowSC=0;

//$numEye $numLips
for ($i=1;$i<99;$i++)
		if (!`objExists ("lowerEyeOuter"+$i)`)
			break;
int $numEye=$i-1;
int $numEyeHalfWay=$numEye/2;
for ($i=1;$i<99;$i++)
		if (!`objExists ("lowerLipOuter"+$i)`)
			break;
int $numLip=$i-1;
int $numLipHalfWay=$numLip/2;

//browSkinCage
if ($buildBrowSC)
	{
	if(`objExists browSkinCage`)
		delete browSkinCage;
	polyPlane -n browSkinCage -w 1 -h 1 -sx 4 -sy 3 -ax 0 1 0 -cuv 2 -ch 0;
	parent browSkinCage FaceFitSkeleton;
	$pos=`xform -q -ws -t $headJoint`;
	xform -ws -t $pos[0] $pos[1] $pos[2] browSkinCage;

	asSnapVtx browSkinCage.vtx[4] noseMiddle;
	asSnapVtx browSkinCage.vtx[19] foreheadMiddle;
	asSnapVtx browSkinCage.vtx[16] foreheadOuter;
	asSnapVtx browSkinCage.vtx[13] browInner; move -r 0 $browHeight 0 browSkinCage.vtx[13];
	asSnapVtx browSkinCage.vtx[8] browInner; move -r 0 (-1*$browHeight) 0 browSkinCage.vtx[8];
	asSnapVtx browSkinCage.vtx[12] browHalf; move -r 0 $browHeight 0 browSkinCage.vtx[12];
	asSnapVtx browSkinCage.vtx[7] browHalf; move -r 0 (-4*$browHeight) 0 browSkinCage.vtx[7];
	asSnapVtx browSkinCage.vtx[11] browOuter; move -r 0 $browHeight 0 browSkinCage.vtx[11];
	asSnapVtx browSkinCage.vtx[6] browOuter; move -r 0 (-1*$browHeight) 0 browSkinCage.vtx[6];
	asSnapVtx browSkinCage.vtx[14] browMiddle; move -r 0 $browHeight 0 browSkinCage.vtx[14];
	asSnapVtx browSkinCage.vtx[9] browMiddle; move -r 0 (-1*$browHeight) 0 browSkinCage.vtx[9];

	asSnapVtx browSkinCage.vtx[2] ("upperEyeOuter"+$halwWayUppEyeOuterNr);
	asSnapVtx browSkinCage.vtx[3] upperEyeOuter1;
	asSnapVtx browSkinCage.vtx[1] ("upperEyeOuter"+$numUpperEyeOuter);

	asAveraveSnapVtx browSkinCage.vtx[18] foreheadMiddle foreheadOuter (1/3.0);
	asAveraveSnapVtx browSkinCage.vtx[17] foreheadMiddle foreheadOuter (2/3.0);
	asAveraveSnapVtx browSkinCage.vtx[15] foreheadMiddle foreheadOuter (4/3.0);
	asAveraveSnapVtx browSkinCage.vtx[10] browHalf browOuter (4/3.0); move -r 0 (2*$browHeight) 0 browSkinCage.vtx[10];	
	asAveraveSnapVtx browSkinCage.vtx[5] browHalf browOuter (4/3.0); move -r 0 (-2*$browHeight) 0 browSkinCage.vtx[5];
	asAveraveSnapVtx browSkinCage.vtx[0] upperEyeOuter1 ("upperEyeOuter"+$numUpperEyeOuter) (3.5/3.0);

	select -r browSkinCage $headJoint;
	$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
	string $browSkinCageSkinCluster=$tempString[0];
	skinCluster -e -ai browInnerJoint_R -ai browHalfJoint_R -ai browOuterJoint_R -ai browMiddleJoint_M -lw false -wt 0 $browSkinCageSkinCluster;
	skinPercent -tv browInnerJoint_R 1 $browSkinCageSkinCluster browSkinCage.vtx[8] browSkinCage.vtx[13];
	skinPercent -tv browHalfJoint_R 1 $browSkinCageSkinCluster browSkinCage.vtx[7] browSkinCage.vtx[12];
	skinPercent -tv browOuterJoint_R 1 $browSkinCageSkinCluster browSkinCage.vtx[6] browSkinCage.vtx[11];
	skinPercent -tv browMiddleJoint_M 1 $browSkinCageSkinCluster browSkinCage.vtx[9] browSkinCage.vtx[14];

	$pos=`xform -q -ws -t browHalf`;
	select $geometry;
	polySelectConstraint -m 3 -t 1 -d 1 -db 0 (`getAttr browOuter.tx`*-1) -dp $pos[0] $pos[1] $pos[2];
	//ensure not including any vtx affected by jaw
	string $vtxs[]=`ls -sl -fl`;
	for ($i=0;$i<size($vtxs);$i++)
		{
		$tempString=`skinPercent -ignoreBelow 0.01 -q -t $skinCluster $vtxs[$i]`;
		if (`stringArrayCount $jawJoint $tempString`)
			select -d $vtxs[$i];
		}
	
	string $vtxs[]=`ls -sl -fl`;
	polySelectConstraint -m 0;
	if (!size($vtxs))
		error "Too strong Jaw weighting at the brow area";

	select -r browSkinCage.vtx[0:19];
	select -add $vtxs;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	delete browSkinCage;

	asFaceAddIn {"browInnerJoint_R","browInnerJoint_L"} browMiddleJoint_M 1;
	asFaceAddIn {"browInnerJoint_R","browOuterJoint_R"} browHalfJoint_R 1;
	asFaceAddIn {"browInnerJoint_L","browOuterJoint_L"} browHalfJoint_L 1;
	select -cl;
	}

//cheekSkinCage
if ($buildBrowSC)
	{
	if(`objExists cheekSkinCage`)
		delete cheekSkinCage;
	string $asScriptLocation=`asScriptLocation`;
	file -import -type "mayaAscii" -rpr "cage2" -options "v=0"  -pr -loadReferenceDepth "all" ($asScriptLocation+"asCage2.ma");
//	polyPlane -n cheekSkinCage -w 1 -h 1 -sx 6 -sy 4 -ax 0 1 0 -cuv 2 -ch 0;
	polyNormalPerVertex -ufn true cheekSkinCage;
	parent cheekSkinCage FaceFitSkeleton;
	$pos=`xform -q -ws -t $headJoint`;
	xform -ws -t $pos[0] $pos[1] $pos[2] cheekSkinCage;

	asSnapVtx cheekSkinCage.vtx[26] noseMiddle;
	asSnapVtx cheekSkinCage.vtx[25] noseTip;
	asSnapVtx cheekSkinCage.vtx[11] noseLower;
	asSnapVtx cheekSkinCage.vtx[36] chinMiddle;move -r 0 (2*$browHeight) 0 cheekSkinCage.vtx[36];
	asSnapVtx cheekSkinCage.vtx[27] chinMiddle;move -r 0 (-2*$browHeight) 0 cheekSkinCage.vtx[27];
	asSnapVtx cheekSkinCage.vtx[19] chin;move -r 0 (2*$browHeight) 0 cheekSkinCage.vtx[19];
	asSnapVtx cheekSkinCage.vtx[20] chin;move -r 0 (-2*$browHeight) 0 cheekSkinCage.vtx[20];

	asAveraveSnapVtx cheekSkinCage.vtx[34] chinMiddle chin (1/3.0); move -r 0 (2*$browHeight) 0 cheekSkinCage.vtx[34];	
	asAveraveSnapVtx cheekSkinCage.vtx[35] chinMiddle chin (1/3.0); move -r 0 (-2*$browHeight) 0 cheekSkinCage.vtx[35];	
	asAveraveSnapVtx cheekSkinCage.vtx[13] chinMiddle chin (2/3.0); move -r 0 (2*$browHeight) 0 cheekSkinCage.vtx[13];	
	asAveraveSnapVtx cheekSkinCage.vtx[12] chinMiddle chin (2/3.0); move -r 0 (-2*$browHeight) 0 cheekSkinCage.vtx[12];	

	asAveraveSnapVtx cheekSkinCage.vtx[23] chin jaw (1/3.0); move -r 0 (2*$browHeight) 0 cheekSkinCage.vtx[23];	
	asAveraveSnapVtx cheekSkinCage.vtx[24] chin jaw (1/3.0); move -r 0 (-2*$browHeight) 0 cheekSkinCage.vtx[24];	
	asAveraveSnapVtx cheekSkinCage.vtx[29] chin jaw (2/3.0); move -r 0 (2*$browHeight) 0 cheekSkinCage.vtx[29];	
	asAveraveSnapVtx cheekSkinCage.vtx[28] chin jaw (2/3.0); move -r 0 (-2*$browHeight) 0 cheekSkinCage.vtx[28];	

	asSnapVtx cheekSkinCage.vtx[0] jaw;
	asSnapVtx cheekSkinCage.vtx[6] jaw; move -r 0 (-2*$browHeight) (-2*$browHeight) cheekSkinCage.vtx[6];	
	asSnapVtx cheekSkinCage.vtx[2] cheekOuter;
	asSnapVtx cheekSkinCage.vtx[7] cheekOuter; move -r 0 (2*$browHeight) (-8*$browHeight) cheekSkinCage.vtx[7];	

	asSnapVtx cheekSkinCage.vtx[16] lowerEyeOuter1;
	asSnapVtx cheekSkinCage.vtx[17] lowerEyeOuter1; move -r 0 (-2*$browHeight) 0 cheekSkinCage.vtx[17];
	asSnapVtx cheekSkinCage.vtx[21] ("lowerEyeOuter"+$numEyeHalfWay);
	asSnapVtx cheekSkinCage.vtx[22] ("lowerEyeOuter"+$numEyeHalfWay); move -r 0 (-2*$browHeight) 0 cheekSkinCage.vtx[22];
	asSnapVtx cheekSkinCage.vtx[32] ("lowerEyeOuter"+$numEye);
	asSnapVtx cheekSkinCage.vtx[31] ("lowerEyeOuter"+$numEye); move -r 0 (-2*$browHeight) 0 cheekSkinCage.vtx[31];

	asAveraveSnapVtx cheekSkinCage.vtx[4] ("lowerEyeOuter"+$numEye) cheekOuter  (1/2.0);	
	asAveraveSnapVtx cheekSkinCage.vtx[10] ("lowerEyeOuter"+$numEye) cheekOuter  (1/2.0); move -r 0 (2*$browHeight) 0 cheekSkinCage.vtx[10];

	asSnapVtx cheekSkinCage.vtx[15] noseCorner;
	asAveraveSnapVtx cheekSkinCage.vtx[9] upperLipOuter0 lowerLipOuter0 (1/2.0); move -r 0 0 (2*$browHeight) cheekSkinCage.vtx[9];	
	asAveraveSnapVtx cheekSkinCage.vtx[33] ("lowerLipOuter"+$numLipHalfWay) ("upperLipOuter"+$numLipHalfWay) (1/2.0); move -r 0 0 (2*$browHeight) cheekSkinCage.vtx[33];	
	asAveraveSnapVtx cheekSkinCage.vtx[8] lowerLipOuter0 chinMiddle (1/2.0);

	asSnapVtx cheekSkinCage.vtx[1] ("lowerLipOuter"+$numLipHalfWay);
	asSnapVtx cheekSkinCage.vtx[3] ("lowerLipOuter"+$numLip);
	asSnapVtx cheekSkinCage.vtx[5] ("upperLipOuter"+$numLipHalfWay);

	asAveraveSnapVtx cheekSkinCage.vtx[14] noseCorner ("lowerLipOuter"+$numLip) (1/4.0);

	asSnapVtx cheekSkinCage.vtx[18] smile;
	asAveraveSnapVtx cheekSkinCage.vtx[30] smile cheekOuter (1/2.0);	

	asAveraveSnapVtx cheekSkinCage.vtx[37] lowerEyeOuter1 noseCorner (1/2.0);
	asAveraveSnapVtx cheekSkinCage.vtx[38] noseMiddle lowerLipOuter0 (1/4.0);

	//Change parent for cheekJoints
	parent smileJointOffset_R smileJointOffset_L noseCornerJointOffset_R noseCornerJointOffset_L cheekHead;

	select -r cheekSkinCage cheekHead;
	$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
	string $cheekSkinCageSkinCluster=$tempString[0];
	skinCluster -e -ai smileJoint_R -ai smileJoint_L -ai cheekMouthCorner_R -ai noseCornerJoint_R -lw false -wt 0 $cheekSkinCageSkinCluster;
	skinPercent -tv smileJoint_R 1 $cheekSkinCageSkinCluster cheekSkinCage.vtx[18];
	skinPercent -tv cheekMouthCorner_R 1 $cheekSkinCageSkinCluster cheekSkinCage.vtx[3];
	skinPercent -tv noseCornerJoint_R 1 $cheekSkinCageSkinCluster cheekSkinCage.vtx[15];

	skinCluster -e -ai smileJoint_R -ai smileJoint_L -ai cheekMouthCorner_R -ai cheekMouthCorner_L -ai noseCornerJoint_R -ai noseCornerJoint_L -lw false -wt 0 cheekDeformSkinCluster;
	select -r cheekSkinCage;
	select -add cheekDeform;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	delete cheekSkinCage;
	}
}

global proc asFaceAddIn (string $targets[], string $transform, int $mo)
{
string $trAddIn=$transform+"AddIn";
createNode -n $trAddIn transform;
string $tempString[]=`listRelatives -p $transform`;
parent $trAddIn $tempString[0];
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $trAddIn;
string $cmd="parentConstraint";
if($mo)
	$cmd+=" -mo";
for ($i=0;$i<size($targets);$i++)
	$cmd+=" "+$targets[$i];
$cmd+=" "+$trAddIn;
eval $cmd;

string $trs[]={"t","r","s"};
for ($i=0;$i<size($trs);$i++)
	{
	createNode -n ($trAddIn+$trs[$i]+"plusMinusAverage") plusMinusAverage;
	if ($trs[$i]=="s")
		setAttr ($trAddIn+$trs[$i]+"plusMinusAverage.operation") 3;
	connectAttr ($trAddIn+"."+$trs[$i]+"x") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dx");
	connectAttr ($trAddIn+"."+$trs[$i]+"y") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dy");
	connectAttr ($trAddIn+"."+$trs[$i]+"z") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dz");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"x")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dx");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"y")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dy");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"z")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dz");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dx") ($transform+"."+$trs[$i]+"x");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dy") ($transform+"."+$trs[$i]+"y");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dz") ($transform+"."+$trs[$i]+"z");
	}
}

global proc asFaceBuild ()
{
asSetRefreshOptionVar;
if (!`objExists FaceFitSkeleton`)
	error "FaceFitSkeleton not found";
string $allBefore[]=`ls`;
int $upperLowerFactor,$lip2Nr,$numLip;
float $outMidDist,$distance,$previousDistance,$dv,$div;
float $scale=`asFaceGetScale`;
float $posA[3],$posB[3],$posC[3],$temp[3];
float $rotFactor[],$divY[],$divZ[],$pos[];
string $side,$ctrlSide,$oppositeCtrlSide,$eyeJoint,$eyeLidPivot,$upperLower,$upperLowerOpposite,$iom,$jointName,$innerMiddle;
string $vtxs[],$tempString[],$tempString2[],$sdkCurves[];
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $tongue=`textField -q -tx asFsTongueTextField`;
string $allFaceGeoString=`textField -q -tx asFsAllFaceGeoTextField`;
string $skinCluster=`textField -q -tx asFsSkinClusterTextField`;
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
string $jawJoint=`textField -q -tx asFsJawJointTextField`;
string $jawControl=`textField -q -tx asFsJawControlTextField`;

string $checkObjects[]={$geometry,$skinCluster,$headJoint,$jawControl};
tokenize $allFaceGeoString $tempString;
$checkObjects=`stringArrayCatenate $checkObjects $tempString`;
for ($obj in $checkObjects)
	if (!`objExists $obj`)
		error ("\""+$obj+"\" does not exists");

string $asScriptLocation=`asScriptLocation`;
string $sourceAsProcedures=("source \""+$asScriptLocation+"asProcedures.mel\"");
if (!`exists asCharSize`)
	eval ($sourceAsProcedures);

asFaceUpdateInfo 0;

setAttr -l 0 FaceFitSkeleton.v;
setAttr -l 1 FaceFitSkeleton.v 0;
refresh;

global string $gMainProgressBar;
global string $gMove;
setToolTo $gMove;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st ("Building face") -bp -ii 1 -min 0 -max 100 $gMainProgressBar;

//if rebuilding, remove prefix jointWeights, but first assign the weights to head
select -r ($geometry+".vtx[0:999999]");
$vtxs=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($vtxs);$i++)
	{
	$tempString=`skinPercent -q -t $skinCluster $vtxs[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`gmatch $tempString[$y] "prefix_*"`)
			skinPercent -tv $headJoint 1 $skinCluster $vtxs[$i];
	}
$tempString=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "prefix_*"`)
		skinCluster -e -ri $tempString[$i] $skinCluster;
if (`objExists prefix_lipLidBS`)
	setAttr prefix_lipLidBS.envelope 0;
if (`objExists ("prefix_"+$jawControl+"_rotateZ")`)
	delete ("prefix_"+$jawControl+"_rotateZ");

//--Import Curves--//
string $iconsFile=$asScriptLocation+"asIcons.ma";
createNode -n "iconsGroup" transform;
setAttr "iconsGroup.visibility" 0;
if (`file -q -ex $iconsFile`)
	asReadIconsFile $iconsFile;

//determine $numEye
for ($i=1;$i<99;$i++)
		if (!`objExists ("lowerEyeInner"+$i)`)
			break;
int $numEye=$i-1;
for ($y=1;$y<99;$y++)
		{
		$joint="upperEyeMiddle"+`asFaceNrToLetter $y`+"1";
		if (!`objExists $joint`) break;
		}
int $numEyeMiddleRows=$y-1;

//determine $numLip upper/lower & numLipMiddleRows & $hasLip
for ($i=0;$i<99;$i++)
		if (!`objExists ("upperLipOuter"+$i)`)
			break;
int $numLipUpper=$i-1;
for ($i=0;$i<99;$i++)
		if (!`objExists ("lowerLipOuter"+$i)`)
			break;
int $numLipLower=$i-1;
for ($y=1;$y<99;$y++)
		{
		$joint="upperLipMiddle"+`asFaceNrToLetter $y`+"0";
		if (!`objExists $joint`) break;
		}
int $numLipMiddleRows=$y-1;
int $hasLip=1;
if (!`objExists upperLipOuter0`)
	$hasLip=0;
int $hasLid=1;
if (!`objExists upperEyeOuter1`)
	$hasLid=0;

//sampling utility
createNode -n closestSampler closestPointOnMesh;
createNode -n closestSurfaceSampler closestPointOnSurface;
$tempString=`listRelatives -ni -s $geometry`;
connectAttr -f ($tempString[0]+".outMesh") closestSampler.inMesh;
connectAttr -f ($geometry+".xformMatrix") closestSampler.inputMatrix;
asFaceCreateDistanceMessure;


//top level nodes
createNode -n FaceMotionSystem transform;
parent FaceMotionSystem FaceGroup;
createNode -n EyeSetup transform;
parent EyeSetup FaceMotionSystem;
createNode -n EyeJoints transform;
parent EyeJoints EyeSetup;
createNode -n EyeSetupGeometry transform;
parent EyeSetupGeometry EyeSetup;
createNode -n LipSetup transform;
parent LipSetup FaceMotionSystem;
createNode -n LipSetupGeometry transform;
parent LipSetupGeometry LipSetup;
createNode -n LipJoints transform;
parent LipJoints LipSetup;
createNode -n LipLocators transform;
parent  LipLocators LipSetup;
createNode -n LipSurfaces transform;
parent LipSurfaces LipSetup;
createNode -n LipClusters transform;
delete `pointConstraint $headJoint LipClusters`;
parent  LipClusters LipSetup;
createNode -n CheekSetup transform;
parent CheekSetup FaceMotionSystem;
createNode -n CheekSetupGeometry transform;
parent CheekSetupGeometry CheekSetup;
createNode -n CheekJoints transform;
parent CheekJoints CheekSetup;
createNode -n JawSetup transform;
parent JawSetup FaceMotionSystem;
if ($jawControl=="FKExtraJaw_M" && `objExists FKJaw_M`)
	parentConstraint FKJaw_M JawSetup;
else
	parentConstraint $jawControl JawSetup;
scaleConstraint $headJoint JawSetup;
setAttr -l 1 EyeSetup.v 0;
setAttr -l 1 LipSetup.v 0;
setAttr -l 1 CheekSetup.v 0;
setAttr -l 1 JawSetup.v 0;

createNode -n ClusterSetup transform;
parent ClusterSetup FaceMotionSystem;
createNode -n ControlsSetup transform;
parent ControlsSetup FaceMotionSystem;
createNode -n RegionSetup transform;
parent RegionSetup FaceMotionSystem;
createNode -n FollowHead transform;
parent FollowHead RegionSetup;
parentConstraint $headJoint FollowHead;
scaleConstraint $headJoint FollowHead;
createNode -n Acontrols transform;
createNode -n Bcontrols transform;
createNode -n Ccontrols transform;
parent Acontrols Bcontrols Ccontrols ControlsSetup;

createNode -n Brs transform;
parent Brs Bcontrols;

orientConstraint -mo $headJoint Brs;
scaleConstraint -mo $headJoint Brs;

//duplicate FaceFitSkeletonJoints to deformJoints for EyeInner* & Lips* & browMiddleJoint_M
string $deformJoints[],$lidJoints[],$lipJoints[];
string $fitJoints[]=`listRelatives -c -type joint FaceFitSkeleton`;
for ($b=1;$b>-2;$b=$b-2)
	{
	for ($i=0;$i<size($fitJoints);$i++)
		{
		//determine $side
		$pos=`xform -q -ws -t $fitJoints[$i]`;
		if ($pos[0]<-0.001) $side="_R"; else $side="_M"; if ($b==-1 && $side=="_R") $side="_L"; if ($b==-1 && $side=="_M") continue;

		if (`gmatch $fitJoints[$i] "*EyeInner[0-9]*"` || `gmatch $fitJoints[$i] "*Lip*"`)
			{
			duplicate -n ($fitJoints[$i]+$side) $fitJoints[$i];
			if (size(`listRelatives -ad ($fitJoints[$i]+$side)`))
				delete `listRelatives -ad -f ($fitJoints[$i]+$side)`;
			xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($fitJoints[$i]+$side);
			setAttr ($fitJoints[$i]+$side+".overrideEnabled") 0;
			setAttr -k 0 ($fitJoints[$i]+$side+".falloffRadius");
			setAttr -k 0 ($fitJoints[$i]+$side+".falloffMode");
			setAttr -k 0 ($fitJoints[$i]+$side+".interpolation");
			parent -w ($fitJoints[$i]+$side);

			$deformJoints[size($deformJoints)]=($fitJoints[$i]+$side);
			if (`gmatch $fitJoints[$i] "lowerEye*"` || `gmatch $fitJoints[$i] "upperEye*"`)
				$lidJoints[size($lidJoints)]=($fitJoints[$i]+$side);
			if (`gmatch $fitJoints[$i] "lowerLip*"` || `gmatch $fitJoints[$i] "upperLip*"`)
				$lipJoints[size($lipJoints)]=($fitJoints[$i]+$side);
			}
		}
	}

//L/R EyeSetup
spaceLocator -n tempAimAtLoc;
for ($b=1;$b>-2;$b=$b-2)
	{
	if (!`objExists upperEyeInner1`)
		continue;
	if ($b==1) $side="_R"; else $side="_L";
	$eyeJoint=`textField -q -tx ("asFsEyeJoint"+$side+"TextField")`;

	float $pos[3]=`xform -q -ws -t $eyeJoint`;
	float $rot[3]=`xform -q -ws -ro $eyeJoint`;
	$eyeLidPivot=`textField -q -tx ("asFsEyeLidPivot"+$side+"TextField")`;
	if ($eyeLidPivot!="")
		$pos=`xform -q -ws -t $eyeLidPivot`;

	createNode -n ("EyeSetup"+$side) transform;
	parent ("EyeSetup"+$side) EyeSetup;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("EyeSetup"+$side);
	xform -ws -ro $rot[0] $rot[1] $rot[2] ("EyeSetup"+$side);
	setAttr ("EyeSetup"+$side+".rotateOrder") `getAttr ($eyeJoint+".rotateOrder")`;
	createNode -n ("EyeOrientOffset"+$side) transform;
	parent ("EyeOrientOffset"+$side) ("EyeSetup"+$side);
	xform -ws -t $pos[0] $pos[1] $pos[2] ("EyeOrientOffset"+$side);
	if ($side=="_R")
		delete `pointConstraint upperEyeInner1 ("upperEyeInner"+$numEye) tempAimAtLoc`;
	else
		setAttr tempAimAtLoc.tx (`getAttr tempAimAtLoc.tx `*-1);
	delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "scene" tempAimAtLoc ("EyeOrientOffset"+$side)`;
 	}
delete tempAimAtLoc;

select -cl;
sets -name FaceAllSet;
sets -name FaceControlSet;
if (`objExists "Sets"`)
	{
	sets -add "Sets" FaceAllSet;
	sets -add "Sets" FaceControlSet;
	}

//Tongue setup
int $haveAllTongueJoints=1;
string $tongueSkinCluster="";
for ($i=0;$i<5;$i++)
	{
	if (!`objExists ("faceRigTongue"+$i)`)
		{
		$haveAllTongueJoints=0;
		continue;
		}
	duplicate -n ("faceRigTongue"+$i+"_M") ("faceRigTongue"+$i);
	if ($i<4)
		delete `listRelatives -c -f ("faceRigTongue"+$i+"_M")`;
	parent -w ("faceRigTongue"+$i+"_M");
	if ($i<4)
		delete `aimConstraint -worldUpType objectrotation -worldUpObject $headJoint -worldUpVector -1 0 0 ("faceRigTongue"+($i+1)) ("faceRigTongue"+$i+"_M")`;
	if ($i>0)
		parent ("faceRigTongue"+$i+"_M") ("faceRigTongue"+($i-1)+"_M");
	makeIdentity -a 1 -t 0 -r 1 -s 0 ("faceRigTongue"+$i+"_M");
	if ($i==0)
		parent ("faceRigTongue"+$i+"_M") JawSetup;
	}
if ($haveAllTongueJoints && `objExists $tongue`)
	{
	//Polycube skin method
	polyCube -n tempWeightCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 4 -ax 0 1 0 -cuv 4 -ch 1;
	xform -s $scale $scale $scale tempWeightCube;
	
	select -r tempWeightCube.vtx[10:13] ;
	$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
	$pos=`xform -q -ws -t faceRigTongue0`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
	
	select -r tempWeightCube.vtx[8:9] tempWeightCube.vtx[14:15] ;
	$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
	$pos=`xform -q -ws -t faceRigTongue1`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
	
	select -r tempWeightCube.vtx[6:7] tempWeightCube.vtx[16:17] ;
	$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
	$pos=`xform -q -ws -t faceRigTongue2`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
	
	select -r tempWeightCube.vtx[4:5] tempWeightCube.vtx[18:19] ;
	$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
	$pos=`xform -q -ws -t faceRigTongue3`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
	
	select -r tempWeightCube.vtx[0:3] ;
	$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
	$pos=`xform -q -ws -t faceRigTongue4`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];

	duplicate -n tempWeightCube2 tempWeightCube;
	select -r tempWeightCube2 faceRigTongue3_M faceRigTongue2_M faceRigTongue1_M faceRigTongue0_M;
	$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
	rename $tempString[0] tongueBoxSC;
//	skinCluster -n tongueBoxSC -dr 4 -lw false -wt 1 -mi 1;
	select -r tempWeightCube2.vtx[10:13] ;
	skinPercent -tv faceRigTongue0_M 1 tongueBoxSC `ls -sl`;
	select -r tempWeightCube2.vtx[8:9] tempWeightCube2.vtx[14:15] ;
	skinPercent -tv faceRigTongue0_M 1 tongueBoxSC `ls -sl`;
	skinPercent -tv faceRigTongue1_M 0.5 tongueBoxSC `ls -sl`;
	select -r tempWeightCube2.vtx[6:7] tempWeightCube2.vtx[16:17] ;
	skinPercent -tv faceRigTongue1_M 1 tongueBoxSC `ls -sl`;
	skinPercent -tv faceRigTongue2_M 0.5 tongueBoxSC `ls -sl`;
	select -r tempWeightCube2.vtx[4:5] tempWeightCube2.vtx[18:19] ;
	skinPercent -tv faceRigTongue2_M 1 tongueBoxSC `ls -sl`;
	skinPercent -tv faceRigTongue3_M 0.5 tongueBoxSC `ls -sl`;
	select -r tempWeightCube2.vtx[0:3] ;
	skinPercent -tv faceRigTongue3_M 1 tongueBoxSC `ls -sl`;

	string $historyNodes[]=`listHistory $tongue`;
	tokenize $tongue $tempString;
	if(size($tempString))
		$historyNodes=`listHistory $tempString[0]`;
	for ($i=0;$i<size($historyNodes);$i++)
		if (`objectType $historyNodes[$i]`=="skinCluster")
			if (!`gmatch $historyNodes[$i] "prefix_*"`)
				$tongueSkinCluster=$historyNodes[$i];
	if ($tongueSkinCluster=="")
		{
		select -r $tongue faceRigTongue3_M faceRigTongue2_M faceRigTongue1_M faceRigTongue0_M;
		$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
		rename $tempString[0] tongueSC;
//		skinCluster -n tongueSC -dr 4 -lw false -wt 1 -mi 1;
		$tongueSkinCluster="tongueSC";
		}
	else
		skinCluster -e -wt 0 -ai faceRigTongue3_M -ai faceRigTongue2_M -ai faceRigTongue1_M -ai faceRigTongue0_M $tongueSkinCluster;

	//move prefix_ inf joints, since in a rebuild case, weights gets copied to these joints instead of new ones
	string $tempString[]=`listConnections -type joint -s 1 -d 0 $tongueSkinCluster`;
	skinCluster -e -moveJointsMode 1 $tongueSkinCluster;
	for ($i=0;$i<size($tempString);$i++)
		if (`gmatch $tempString[$i] "prefix_*"`)
			if(`objExists $tempString[$i]`)
				move -r 0 0 -10 $tempString[$i];
	skinCluster -e -moveJointsMode 0 $tongueSkinCluster;

	eval ("select tempWeightCube2 "+$tongue);
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	skinCluster -e -removeUnusedInfluence 1 $tongueSkinCluster;
	delete tempWeightCube tempWeightCube2;
	}

//Separate mesh for lip/eye/cheek deform
string $lipLid="lip";
string $joints[]=$lipJoints;
for ($a=0;$a<3;$a++)
	{
	if ($a==0 && $hasLip==0)
		continue;
	if ($a==1 && $hasLid==0)
		continue;
	if($a==1)
		{
		$lipLid="lid";
		$joints=$lidJoints;
		}
	if($a==2)
		{
		$lipLid="cheek";
		clear $joints;
		}
	//Deform lips on separate mesh
	polyCube -n ($lipLid+"Deform") -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
	float $m[16]=`xform -q -m $geometry`;
	xform -m $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15] ($lipLid+"Deform");

	//base upon 1st mesh in history
	$tempString=`listHistory $geometry`;
	for ($i=0;$i<size($tempString);$i++)
		if(`objectType $tempString[$i]`=="mesh")
			{
			connectAttr ($tempString[$i]+".worldMesh") ($lipLid+"Deform.inMesh");
			refresh;
			disconnectAttr ($tempString[$i]+".worldMesh") ($lipLid+"Deform.inMesh");
			break;
			}
	select -cl;
	$pos=`xform -q -ws -t $headJoint`;
	joint -n ($lipLid+"Head");
	xform -ws -t $pos[0] $pos[1] $pos[2] ($lipLid+"Head");
	if($lipLid=="lip") {parent ($lipLid+"Deform") LipSetupGeometry;parent ($lipLid+"Head") LipJoints;}
	if($lipLid=="lid") {parent ($lipLid+"Deform") EyeSetupGeometry;parent ($lipLid+"Head") EyeJoints;}
	if($lipLid=="cheek") {parent ($lipLid+"Deform") CheekSetupGeometry;parent ($lipLid+"Head") CheekJoints;}
	//bind to ($lipLid+"Head")
	select ($lipLid+"Deform") ($lipLid+"Head");
	$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
	rename $tempString[0] ($lipLid+"DeformSkinCluster");
	//add influence joints
	string $skinClusterCmd="skinCluster -e -dr 4 -lw false -wt 0";
	for ($i=0;$i<size($joints);$i++)
		$skinClusterCmd+=" -ai "+$joints[$i];
	$skinClusterCmd+=" "+$lipLid+"DeformSkinCluster";
	if (size($joints))
		eval $skinClusterCmd;
	//weight according to .falloffRadius
	for ($i=0;$i<size($joints);$i++)
		{
		$pos=`xform -q -ws -t $joints[$i]`;
		$maxDist=`getAttr ($joints[$i]+".falloffRadius")`;
		select ($lipLid+"Deform");
		polySelectConstraint -m 3 -t 1 -d 1 -db 0 $maxDist -dp $pos[0] $pos[1] $pos[2];
		$vtxs=`ls -sl -fl`;
		if (`optionVar -q asRefresh`)
			refresh;
		polySelectConstraint -m 0;
		if(size($vtxs))
			skinPercent -tv $joints[$i] 1 ($lipLid+"DeformSkinCluster") $vtxs;
		else
			warning ("Found no vtx for \""+$joints[$i]+"\"");
		}
	}

//Dual Quat for lids to better bulge
if (`objExists lidDeformSkinCluster`)
	setAttr lidDeformSkinCluster.skinningMethod 1;

//BS $lipLid back to $geo
if(`objExists lidDeform` && `objExists lipDeform` && `objExists cheekDeform`)
	{
	select -r lidDeform lipDeform cheekDeform $geometry;
	blendShape -n lipLidBS -frontOfChain;
	setAttr lipLidBS.lipDeform 1;
	setAttr lipLidBS.lidDeform 1;
	setAttr lipLidBS.cheekDeform 1;
	}

//PingPongs
for ($b=1;$b>-2;$b=$b-2)
	{
	for ($i=0;$i<size($fitJoints);$i++)
		{
		//determine $side
		$pos=`xform -q -ws -t $fitJoints[$i]`;
		if ($pos[0]<-0.001) $side="_R"; else $side="_M"; if ($b==-1 && $side=="_R") $side="_L"; if ($b==-1 && $side=="_M") continue;
		int $color=`getAttr ($fitJoints[$i]+".overrideColor")`;
		if ($color==6 || $color==7 || $color==10)
			pingPong $fitJoints[$i] $fitJoints[$i] $b $side `getAttr ($fitJoints[$i]+".overrideColor")`;
		}
	}


//CheekSetup
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	if (!$hasLip)
		break;
	select -cl;
	joint -n ("cheekMouthCorner"+$side);
	createNode -n ("cheekMouthCornerOffset"+$side) transform;
	parent ("cheekMouthCorner"+$side) ("cheekMouthCornerOffset"+$side);
	parent ("cheekMouthCornerOffset"+$side) cheekHead;
	$pos=`xform -q -ws -t ("lowerLipOuter"+$numLipLower)`;
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ("cheekMouthCornerOffset"+$side);
	}



//cageWeighting
asFaceCageBuild;



//Setup Eye Lid
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	if (!`objExists upperEyeInner1`)
		continue;

	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blink"+$side) -at double EyeSetup;
	addAttr -dv 0.2 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blinkCenter"+$side) -at double EyeSetup;
	addAttr -dv 1.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidFollow"+$side) -at double EyeSetup;
	addAttr -dv 1.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidFollow"+$side) -at double EyeSetup;
	createNode -n ("blinkReverse"+$side) reverse;
	createNode -n ("blinkCenterReverse"+$side) reverse;
	connectAttr ("EyeSetup.blink"+$side) ("blinkReverse"+$side+".inputX");
	connectAttr ("EyeSetup.blinkCenter"+$side) ("blinkCenterReverse"+$side+".inputX");

	createNode -n ("eyeLocs"+$side) transform;
	setAttr ("eyeLocs"+$side+".inheritsTransform") 0;
	parent ("eyeLocs"+$side) EyeSetup;
	setAttr -l 1 ("eyeLocs"+$side+".v") 0;
	createNode -n ("eyeCurves"+$side) transform;
	parent ("eyeCurves"+$side) EyeSetup;

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper"; $upperLowerOpposite="lower";}
		else {$upperLower="lower"; $upperLowerOpposite="upper";}


		$curveCmd="curve -d 1 ";

		for ($i=1;$i<($numEye+1);$i++)
			{
			//determine $side
			$pos=`xform -q -ws -t ($upperLower+"EyeInner"+$i)`;
			if ($pos[0]<-0.001) $side="_R"; else $side="_M"; if ($b==-1 && $side=="_R") $side="_L"; if ($b==-1 && $side=="_M") continue;
			//progress
			if (`progressBar -q -ic $gMainProgressBar`) return;
			progressBar -e -s 1 $gMainProgressBar;

			$eyeJoint=`textField -q -tx ("asFsEyeJoint"+$side+"TextField")`;

			if (!`objExists ("lowerEyeInner"+$i+$side)`)
				continue;

			$curveCmd+=" -p "+$pos[0]*$b+" "+$pos[1]+" "+$pos[2];
			spaceLocator -n ($upperLower+"EyeLoc"+$i+$side);
			parent ($upperLower+"EyeLoc"+$i+$side) ("eyeLocs"+$side);
			createNode -n ($upperLower+"EyePoci"+$i+$side) pointOnCurveInfo;
			setAttr ($upperLower+"EyePoci"+$i+$side+".turnOnPercentage") 1;
			setAttr ($upperLower+"EyePoci"+$i+$side+".parameter") (($i-1)/($numEye-1.00));
			connectAttr ($upperLower+"EyePoci"+$i+$side+".position") ($upperLower+"EyeLoc"+$i+$side+".translate");
			}
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] ($upperLower+"EyeCurve1"+$side);
		parent ($upperLower+"EyeCurve1"+$side) ("eyeCurves"+$side);
		duplicate -n ($upperLower+"EyeCurve2"+$side) ($upperLower+"EyeCurve1"+$side);
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.00393701 ($upperLower+"EyeCurve2"+$side);
		if ($upperLower=="upper")
			duplicate -n ("closedEyeCurve2"+$side) ("upperEyeCurve2"+$side);
		if ($upperLower=="lower")
			{
			select -r ("upperEyeCurve2"+$side) ("lowerEyeCurve2"+$side) ("closedEyeCurve2"+$side);
			blendShape -n ("closedEyeCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;
			connectAttr ("EyeSetup.blinkCenter"+$side) ("closedEyeCurveCloseBS"+$side+".upperEyeCurve2"+$side);
			connectAttr ("blinkCenterReverse"+$side+".outputX") ("closedEyeCurveCloseBS"+$side+".lowerEyeCurve2"+$side);
			}
		duplicate -n ($upperLower+"EyeCurveClose"+$side) ($upperLower+"EyeCurve2"+$side);
		select -r ($upperLower+"EyeCurve2"+$side) ("closedEyeCurve2"+$side) ($upperLower+"EyeCurveClose"+$side);
		blendShape -n ($upperLower+"EyeCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;
		connectAttr ("EyeSetup.blink"+$side) ($upperLower+"EyeCurveCloseBS"+$side+".closedEyeCurve2"+$side);
		connectAttr ("blinkReverse"+$side+".outputX") ($upperLower+"EyeCurveCloseBS"+$side+"."+$upperLower+"EyeCurve2"+$side);
		wire -n ($upperLower+"EyeCurveWire"+$side) -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w ($upperLower+"EyeCurveClose"+$side) ($upperLower+"EyeCurve1"+$side);
		connectAttr ("blinkReverse"+$side+".outputX") ($upperLower+"EyeCurveWire"+$side+".scale[0]");

		if ($upperLower=="upper")
			{
			pingPong ($upperLower+"EyeInner1"+$side) "EyeCorner1" 1 $side 7;
			pingPong ($upperLower+"EyeInner"+$numEye+$side) "EyeCorner2" 1 $side 7;
			}

//		createNode -n ($upperLower+"Eye1Follow"+$side) transform;
//		parent ($upperLower+"Eye1Follow"+$side) Bcontrols;

		//$upperLower (1)
		pingPong ($upperLower+"EyeCurve2"+$side+".cv[2]") ($upperLower+"Eye1") 1 $side 7;
		delete `geometryConstraint ($upperLower+"EyeCurve1"+$side) ($upperLower+"Eye1Offset"+$side)`;
		$temp=`xform -q -ws -t ($upperLower+"Eye1Offset"+$side)`;
		$temp2=`xform -q -ro ($upperLower+"Eye1Offset"+$side)`;
//		parent ($upperLower+"Eye1Attach"+$side) Bcontrols;

		//$upperLower (2)
		pingPong ($upperLower+"EyeCurve2"+$side+".cv[1]") ($upperLower+"Eye2") 1 $side 10;
		delete `geometryConstraint ($upperLower+"EyeCurve1"+$side) ($upperLower+"Eye2Offset"+$side)`;
		setAttr -type float3 ($upperLower+"Eye2"+$side+".s") 0.5 0.5 0.5;
		makeIdentity -a 1 -t 0 -r 0 -s 1 ($upperLower+"Eye2"+$side);
		asFaceAddIn {($upperLower+"Eye1Joint"+$side),("EyeCorner1Joint"+$side)} ($upperLower+"Eye2Joint"+$side) 1;
		//$upperLower (3)
		pingPong ($upperLower+"EyeCurve2"+$side+".cv[3]") ($upperLower+"Eye3") 1 $side 10;
		delete `geometryConstraint ($upperLower+"EyeCurve1"+$side) ($upperLower+"Eye3Offset"+$side)`;
		setAttr -type float3 ($upperLower+"Eye3"+$side+".s") 0.5 0.5 0.5;
		makeIdentity -a 1 -t 0 -r 0 -s 1 ($upperLower+"Eye3"+$side);
		asFaceAddIn {($upperLower+"Eye1Joint"+$side),("EyeCorner2Joint"+$side)} ($upperLower+"Eye3Joint"+$side) 1;


		//Bind the curves
		select ("EyeCorner1Joint"+$side) ("EyeCorner2Joint"+$side) ($upperLower+"Eye1Joint"+$side)
			($upperLower+"Eye2Joint"+$side) ($upperLower+"Eye3Joint"+$side) ($upperLower+"EyeCurve2"+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
		rename $tempString[0] ($upperLower+"EyeCurveSC"+$side);
//		skinCluster -n ($upperLower+"EyeCurveSC"+$side) -dr 4 -lw false -wt 1 -mi 1
//			("EyeCorner1Joint"+$side) ("EyeCorner2Joint"+$side) ($upperLower+"Eye1Joint"+$side)
//			($upperLower+"Eye2Joint"+$side) ($upperLower+"Eye3Joint"+$side) ($upperLower+"EyeCurve2"+$side);
		skinPercent -tv ("EyeCorner1Joint"+$side) 1 ($upperLower+"EyeCurveSC"+$side) ($upperLower+"EyeCurve2"+$side+".cv[0]");
		skinPercent -tv ($upperLower+"Eye2Joint"+$side) 1 ($upperLower+"EyeCurveSC"+$side) ($upperLower+"EyeCurve2"+$side+".cv[1]");
		skinPercent -tv ($upperLower+"Eye1Joint"+$side) 1 ($upperLower+"EyeCurveSC"+$side) ($upperLower+"EyeCurve2"+$side+".cv[2]");
		skinPercent -tv ($upperLower+"Eye3Joint"+$side) 1 ($upperLower+"EyeCurveSC"+$side) ($upperLower+"EyeCurve2"+$side+".cv[3]");
		skinPercent -tv ("EyeCorner2Joint"+$side) 1 ($upperLower+"EyeCurveSC"+$side) ($upperLower+"EyeCurve2"+$side+".cv[4]");

		//now after binding the curve, we can parent the joints
		if ($upperLower=="upper")
			parent ("EyeCorner1JointOffset"+$side) ("EyeCorner2JointOffset"+$side) lidHead;
		parent ($upperLower+"Eye1JointOffset"+$side) ($upperLower+"Eye2JointOffset"+$side) ($upperLower+"Eye3JointOffset"+$side) lidHead;

		for ($i=1;$i<($numEye+1);$i++)
			{
			connectAttr ($upperLower+"EyeCurve1"+$side+"Shape.worldSpace[0]") ($upperLower+"EyePoci"+$i+$side+".inputCurve");

			createNode -n ($upperLower+"EyeInner"+$i+"Aim"+$side) transform;
			parent ($upperLower+"EyeInner"+$i+"Aim"+$side) ("EyeSetup"+$side);
			setAttr -type float3 ($upperLower+"EyeInner"+$i+"Aim"+$side+".t") 0 0 0;
			aimConstraint -worldUpType objectrotation -worldUpObject $headJoint -worldUpVector 1 0 0 ($upperLower+"EyeLoc"+$i+$side) ($upperLower+"EyeInner"+$i+"Aim"+$side);
			parent ($upperLower+"EyeInner"+$i+$side) ($upperLower+"EyeInner"+$i+"Aim"+$side);
			}

		// EyeControlFollow
		createNode -n ($upperLower+"Eye1JointFollow"+$side) transform;
		$pos=`xform -q -ws -t ($upperLower+"Eye1Joint"+$side)`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Eye1JointFollow"+$side);
		$tempString=`listRelatives -p ($upperLower+"Eye1Joint"+$side)`;
		parent ($upperLower+"Eye1JointFollow"+$side) $tempString[0];
		duplicate -n ($upperLower+"Eye1JointFollowBlended"+$side) ($upperLower+"Eye1JointFollow"+$side);
		createNode -n ($upperLower+"Eye1JointFollowEyeRot"+$side) transform;
		parent ($upperLower+"Eye1JointFollowEyeRot"+$side) $tempString[0];
		$pos=`xform -q -ws -t $eyeJoint`;
		$rot=`xform -q -ws -ro $eyeJoint`;
		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ($upperLower+"Eye1JointFollowEyeRot"+$side);
//		if ($side=="_L")
//			rotate -r -os 0 -180 0 ($upperLower+"Eye1JointFollowEyeRot"+$side);
		setAttr ($upperLower+"Eye1JointFollowEyeRot"+$side+".rotateOrder") `getAttr ($eyeJoint+".rotateOrder")`;
		duplicate -n ($upperLower+"Eye1JointFollowEyeRotOffset"+$side) ($upperLower+"Eye1JointFollowEyeRot"+$side);
		parent ($upperLower+"Eye1JointFollowEyeRot"+$side) ($upperLower+"Eye1JointFollowEyeRotOffset"+$side);
		parentConstraint -mo ($upperLower+"Eye1JointFollowEyeRot"+$side) ($upperLower+"Eye1JointFollow"+$side);
		connectAttr ($eyeJoint+".rx") ($upperLower+"Eye1JointFollowEyeRot"+$side+".rx");
		connectAttr ($eyeJoint+".ry") ($upperLower+"Eye1JointFollowEyeRot"+$side+".ry");
		connectAttr ($eyeJoint+".rz") ($upperLower+"Eye1JointFollowEyeRot"+$side+".rz");
//		parentConstraint -mo $eyeJoint ($upperLower+"Eye1JointFollow"+$side);
		createNode -n ($upperLower+"EyeFollowMultiply"+$side) multiplyDivide;
		connectAttr ($upperLower+"Eye1JointFollow"+$side+".t") ($upperLower+"EyeFollowMultiply"+$side+".input1");
		connectAttr ("EyeSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"EyeFollowMultiply"+$side+".input2X");
		connectAttr ("EyeSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"EyeFollowMultiply"+$side+".input2Y");
		connectAttr ("EyeSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"EyeFollowMultiply"+$side+".input2Z");
		connectAttr ($upperLower+"EyeFollowMultiply"+$side+".output") ($upperLower+"Eye1JointFollowBlended"+$side+".t");
		asFaceAddIn {($upperLower+"Eye1JointFollowBlended"+$side)} ($upperLower+"Eye1Joint"+$side) 1;

		
/*
//		orientConstraint $eyeJoint ($upperLower+"Eye1NotFollow"+$side) ($upperLower+"Eye1Follow"+$side);
		createNode -n ($upperLower+"EyeFollowMultiply"+$side) multiplyDivide;
		connectAttr ($eyeJoint+".ry") ($upperLower+"EyeFollowMultiply"+$side+".input1Y");
		connectAttr ($eyeJoint+".rz") ($upperLower+"EyeFollowMultiply"+$side+".input1Z");
		connectAttr ("EyeSetup.lidFollow"+$side) ($upperLower+"EyeFollowMultiply"+$side+".input2Y");
		connectAttr ("EyeSetup.lidFollow"+$side) ($upperLower+"EyeFollowMultiply"+$side+".input2Z");
//?		connectAttr ($upperLower+"EyeFollowMultiply"+$side+".outputY") ($upperLower+"Eye1Follow"+$side+".ry");
//?		connectAttr ($upperLower+"EyeFollowMultiply"+$side+".outputZ") ($upperLower+"Eye1Follow"+$side+".rz");
*/
		}
	}

addAttr -k 1 -ln "ACtrlVis" -at bool -dv true EyeSetup;
connectAttr EyeSetup.ACtrlVis Acontrols.v;
addAttr -k 1 -ln "BCtrlVis" -at bool -dv true EyeSetup;
connectAttr EyeSetup.BCtrlVis Bcontrols.v;
addAttr -k 1 -ln "CCtrlVis" -at bool -dv true EyeSetup;
connectAttr EyeSetup.CCtrlVis Ccontrols.v;
addAttr -k 1 -ln "SquashCtrlVis" -at bool -dv true EyeSetup;
connectAttr EyeSetup.SquashCtrlVis RegionSetup.v;
//delete EyeTemplateControlOffset;


//Weighting Eyelid 
int $numExtras=$i-1;
string $ms;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper"; $upperLowerOpposite="lower";}
		else {$upperLower="lower"; $upperLowerOpposite="upper";}
		//innerExtra/middle(s) loop, $ms=middleRowSuffix
		for ($y=1;$y<($numEyeMiddleRows+$numExtras+1);$y++)
			{
			if ($y<($numEyeMiddleRows+1))
				{
				$ms=`asFaceNrToLetter $y`;
				$innerMiddle="Middle";
				}
			else
				{
				$ms=`asFaceNrToLetter ($y-$numEyeMiddleRows)`;
				$innerMiddle="InnerExtra";
				}
			for ($i=1;$i<($numEye+1);$i++)
				{
				$fitJoint=$upperLower+"Eye"+$innerMiddle+$ms+$i;
				if (!`objExists $fitJoint`)
					continue;
				$pos=`xform -q -ws -t ($upperLower+"Eye"+$innerMiddle+$ms+$i)`;
				$maxDist=`getAttr ($upperLower+"Eye"+$innerMiddle+$ms+$i+".falloffRadius")`;
				select lidDeform;
				polySelectConstraint -m 3 -t 1 -d 1 -db 0 $maxDist -dp ($pos[0]*$b) $pos[1] $pos[2];
				$vtxs=`ls -sl -fl`;
				polySelectConstraint -m 0;

				if ($y<($numEyeMiddleRows+1))
					$value = $y/($numEyeMiddleRows+1.00);
				else
					$value = 1.00;
				if (size($vtxs))
					skinPercent -tv ($upperLower+"EyeInner"+$i+$side) $value lidDeformSkinCluster `ls -sl`;
				}
			}
		}
	}



//Setup Lip
int $nr;
string $parentCmd,$crvCmd,$cluster,$clusterHandle,$clusterHandleShape,$clusterGroupParts,$clusterGroupId,$clusterSet,$jointSide;
string $tempTrns[],$clusters[];
if ($hasLip)
	{
	$pos=`xform -q -ws -t ("upperLipOuter"+$numLipUpper)`;

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper"; $upperLowerOpposite="lower";}
		else {$upperLower="lower"; $upperLowerOpposite="upper";}

		if ($upperLower=="upper")
			$numLip=$numLipUpper;
		if ($upperLower=="lower")
			$numLip=$numLipLower;

		for ($b=1;$b>-2;$b=$b-2)
			{
			for ($i=0;$i<($numLip+1);$i++)
				{
				if ($b==1) $side="_R"; else $side="_L";
				if ($i==0) $side="_M";

				//inner/middle(s) loop, $ms=middleRowSuffix
				for ($y=0;$y<($numLipMiddleRows+1);$y++)
					{
					if($i==0 && $b==-1)
						continue;
					$ms=`asFaceNrToLetter $y`;
					if ($y==0)
						$innerMiddle="Outer";
					else
						$innerMiddle="Middle";
	
					//progress
					if (`progressBar -q -ic $gMainProgressBar`) return;progressBar -e -s 1 $gMainProgressBar;
					if ($y==0)
						{
						select -cl;
						joint -n ($upperLower+"LipCenter"+$i+$side);
						}
					if (`objExists ($upperLower+"Lip"+$innerMiddle+$ms+$i+$side)`)
						{
						pointConstraint ($upperLower+"Lip"+$innerMiddle+$ms+$i+$side) ($upperLower+"LipCenter"+$i+$side);
						setAttr ($upperLower+"Lip"+$innerMiddle+$ms+$i+$side+".v") 0;
						$parentCmd+="parent "+$upperLower+"Lip"+$innerMiddle+$ms+$i+$side+" "+$upperLower+"LipCenter"+$i+$side+";";
//						$parentCmd+="disconnectAttr "+$upperLower+"LipCenter"+$i+$side+".scale "+$upperLower+"Lip"+$innerMiddle+$ms+$i+$side+".inverseScale;";
						}
					}
				if (`objExists ($upperLower+"LipCenter"+$i+$side+"_pointConstraint1")`)
					delete ($upperLower+"LipCenter"+$i+$side+"_pointConstraint1");
				}
			}
		//ribbon
		$crvCmd="curve -n "+$upperLower+"LipRibbonCurve -d 3 ";
		clear $tempTrns;
		for ($i=0;$i<(($numLip+1)*2);$i++)
			{
			if ($i<($numLip+1))
				{
				$nr=$numLip-$i;
				$side="_R";
				}
			else
				{
				$nr=$i-$numLip-1;
				$side="_L";
				}
			//tangent extensions
			if ($i==0 || $i==($numLip+2))
				{
				createNode -n ($upperLower+"LipCenter"+($numLip+1)+$side) transform;
				$tempTrns[size($tempTrns)]=$upperLower+"LipCenter"+($numLip+1)+$side;
				$posA=`xform -q -ws -t ($upperLower+"LipCenter"+$numLip+$side)`;
				$posB=`xform -q -ws -t ($upperLower+"LipCenter"+($numLip-1)+$side)`;
				$pos[0]=$posA[0]+($posA[0]-$posB[0]);$pos[1]=$posA[1]+($posA[1]-$posB[1]);$pos[2]=$posA[2]+($posA[2]-$posB[2]);
				xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LipCenter"+($numLip+1)+$side);
				}
			if ($nr==0)
				$posA=`xform -q -ws -t ($upperLower+"LipCenter"+$nr+"_M")`;
			else
				$posA=`xform -q -ws -t ($upperLower+"LipCenter"+$nr+$side)`;
			$posB=`xform -q -ws -t ($upperLower+"LipCenter"+($nr+1)+$side)`;
			$pos[0]=($posA[0]+$posB[0])/2.0;$pos[1]=($posA[1]+$posB[1])/2.0;$pos[2]=($posA[2]+$posB[2])/2.0;
			$crvCmd+="-p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		eval $crvCmd;
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.01 ($upperLower+"LipRibbonCurve");
		offsetCurve -n ($upperLower+"LipRibbonCurveOffset1") -ch 0 -rn false -cb 2 -st true -cl true -cr 0 -d -0.02 -tol 0.01 -sd 5 -ugn false ($upperLower+"LipRibbonCurve");
		offsetCurve -n ($upperLower+"LipRibbonCurveOffset2") -ch 0 -rn false -cb 2 -st true -cl true -cr 0 -d 0.02 -tol 0.01 -sd 5 -ugn false ($upperLower+"LipRibbonCurve");
		loft -n ($upperLower+"LipRibbonSurface") -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true ($upperLower+"LipRibbonCurveOffset1") ($upperLower+"LipRibbonCurveOffset2");
		delete $tempTrns ($upperLower+"LipRibbonCurveOffset1") ($upperLower+"LipRibbonCurveOffset2") ($upperLower+"LipRibbonCurve");
		rebuildSurface -n ($upperLower+"LipRibbonSurfaceRebuilt") -ch 0 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kc 0 -su 4 -du 3 -sv 0 -dv 3 -tol 0.01 -fr 0  -dir 2 ($upperLower+"LipRibbonSurface");
		parent ($upperLower+"LipRibbonSurface") ($upperLower+"LipRibbonSurfaceRebuilt") LipSurfaces;
		//clusters
		select -r ($upperLower+"LipRibbonSurfaceRebuilt.cv[0][0:3]");
		$tempString=`cluster -n ($upperLower+"LipRibbonClusterA_R") -envelope 1`;
		select -r ($upperLower+"LipRibbonSurfaceRebuilt.cv[1][0:3]");
		$tempString=`cluster -n ($upperLower+"LipRibbonClusterB_R") -envelope 1`;
		select -r ($upperLower+"LipRibbonSurfaceRebuilt.cv[2][0:3]");
		$tempString=`cluster -n ($upperLower+"LipRibbonClusterC_R") -envelope 1`;
		select -r ($upperLower+"LipRibbonSurfaceRebuilt.cv[3][0:3]");
		$tempString=`cluster -n ($upperLower+"LipRibbonCluster_M") -envelope 1`;
		select -r ($upperLower+"LipRibbonSurfaceRebuilt.cv[4][0:3]");
		$tempString=`cluster -n ($upperLower+"LipRibbonClusterC_L") -envelope 1`;
		select -r ($upperLower+"LipRibbonSurfaceRebuilt.cv[5][0:3]");
		$tempString=`cluster -n ($upperLower+"LipRibbonClusterB_L") -envelope 1`;
		select -r ($upperLower+"LipRibbonSurfaceRebuilt.cv[6][0:3]");
		$tempString=`cluster -n ($upperLower+"LipRibbonClusterA_L") -envelope 1`;
		createNode -n ($upperLower+"LipRibbonClusterHandleOffset_M") transform;
		parent ($upperLower+"LipRibbonClusterHandleOffset_M") LipClusters;
		parent ($upperLower+"LipRibbonCluster_MHandle") ($upperLower+"LipRibbonClusterHandleOffset_M");
		
		$clusters={($upperLower+"LipRibbonClusterA_R"),($upperLower+"LipRibbonClusterB_R"),($upperLower+"LipRibbonClusterC_R"),
			($upperLower+"LipRibbonCluster_M"),
			($upperLower+"LipRibbonClusterA_L"),($upperLower+"LipRibbonClusterB_L"),($upperLower+"LipRibbonClusterC_L")};
		for ($z=0;$z<size($clusters);$z++)
			{
			string $cluster=$clusters[$z];
			string $clusterHandle=$clusters[$z]+"Handle";
			$tempString=`listRelatives -s $clusterHandle`;
			string $clusterHandleShape=$tempString[0];
			$tempString=`listConnections ($cluster+".input[0].inputGeometry")`;
			string $clusterGroupParts=$tempString[0];
			$tempString=`listConnections ($cluster+".input[0].groupId")`;
			string $clusterGroupId=$tempString[0];
			$tempString=`listConnections ($cluster+".message")`;
			string $clusterSet=$tempString[0];
			}

		//wrap
		deformer -type wrap ($upperLower+"LipRibbonSurface");
		select -r ($upperLower+"LipRibbonSurface");
		select -add ($upperLower+"LipRibbonSurfaceRebuilt");
//		string $temptring[]=`deformer -type wrap`;
//		rename $tempString[0] ($upperLower+"LipRibbonWrap");
		AddWrapInfluence;
		$tempString=`listConnections ($upperLower+"LipRibbonSurfaceShape.create")`;
		rename $tempString[0] ($upperLower+"LipRibbonWrap");
		select ($upperLower+"LipRibbonSurfaceRebuiltShape");
		setAttr ($upperLower+"LipRibbonWrap.autoWeightThreshold") 1;
		setAttr ($upperLower+"LipRibbonWrap.exclusiveBind") 0;

//		$offset=1/(($numLip*2.0)-1);
		connectAttr -f ($upperLower+"LipRibbonSurfaceShape.worldSpace") closestSurfaceSampler.inputSurface;
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==1) $side="_R"; else $side="_L";
			//clusterGrps
			createNode -n ($upperLower+"LipRibbonClusterGrpOffset"+$side) -p LipClusters transform;
			createNode -n ($upperLower+"LipRibbonClusterGrpCtrl"+$side) -p ($upperLower+"LipRibbonClusterGrpOffset"+$side) transform;
			createNode -n ($upperLower+"LipRibbonClusterGrpAutoSmooth"+$side) -p ($upperLower+"LipRibbonClusterGrpCtrl"+$side) transform;
			createNode -n ($upperLower+"LipRibbonClusterGrpManualSmooth"+$side) -p ($upperLower+"LipRibbonClusterGrpAutoSmooth"+$side) transform;
			$pos=`xform -q -ws -piv ($upperLower+"LipRibbonClusterA"+$side+"Handle")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LipRibbonClusterGrpOffset"+$side);
			delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 ($upperLower+"LipRibbonClusterC"+$side+"Handle") ($upperLower+"LipRibbonClusterGrpAutoSmooth"+$side)`;
			createNode -n ($upperLower+"LipRibbonClusterCHandleOffset"+$side) transform;
			parent ($upperLower+"LipRibbonClusterC"+$side+"Handle") ($upperLower+"LipRibbonClusterCHandleOffset"+$side);
//			parent ($upperLower+"LipRibbonClusterAHandle"+$side) ($upperLower+"LipRibbonClusterBHandle"+$side) ($upperLower+"LipRibbonClusterCHandleOffset"+$side) ($upperLower+"LipRibbonClusterGrpAutoSmooth"+$side);
			parent ($upperLower+"LipRibbonClusterA"+$side+"Handle") ($upperLower+"LipRibbonClusterB"+$side+"Handle") ($upperLower+"LipRibbonClusterCHandleOffset"+$side) ($upperLower+"LipRibbonClusterGrpManualSmooth"+$side);
			parent ($upperLower+"LipRibbonClusterCHandleOffset"+$side) LipClusters;

			for ($i=0;$i<($numLip+1);$i++)
				{
				if ($b==1) $side="_R"; else $side="_L";if ($i==0) $side="_M";
				if ($side=="_M" && $b==-1)
					continue;
				//pointOnSurfaceInfo
				createNode -n ($upperLower+"LipInfo"+$i+$side) pointOnSurfaceInfo;
				setAttr ($upperLower+"LipInfo"+$i+$side+".turnOnPercentage") 1;

				$pos=`xform -q -ws -t ($upperLower+"LipCenter"+$i+$side)`;
				setAttr -type float3 closestSurfaceSampler.inPosition ($pos[0]*$b) $pos[1] $pos[2];
				$parameterU=`getAttr closestSurfaceSampler.result.parameterU`;
				if ($b==-1)
					$parameterU=1-$parameterU;
//				$parameterU=0.5-(($i*$offset)*$b);
				if ($parameterU<0.01)	$parameterU=0.02;
				if ($parameterU>0.99)	$parameterU=0.98;
				setAttr ($upperLower+"LipInfo"+$i+$side+".parameterU") $parameterU;
				setAttr ($upperLower+"LipInfo"+$i+$side+".parameterV") 0.5;

					connectAttr ($upperLower+"LipRibbonSurfaceShape.worldSpace[0]") ($upperLower+"LipInfo"+$i+$side+".inputSurface");
				createNode -n ($upperLower+"LipSurfaceAttach"+$i+$side) transform;
				connectAttr ($upperLower+"LipInfo"+$i+$side+".position") ($upperLower+"LipSurfaceAttach"+$i+$side+".translate");
				}

			for ($i=0;$i<($numLip+1);$i++)
				{
				if ($b==1) $side="_R"; else $side="_L";if ($i==0) $side="_M";
				if ($side=="_M" && $b==-1)
					continue;
				$upObj=($upperLower+"LipSurfaceAttach"+($i+1)+$side);
				if ($i>$numLip-2)
					$upObj=$upperLower+"LipRibbonClusterGrpAutoSmooth"+$side;
//				normalConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $upObj ($upperLower+"LipRibbonSurface") ($upperLower+"LipSurfaceAttach"+$i+$side);
				parent ($upperLower+"LipCenter"+$i+$side) ($upperLower+"LipSurfaceAttach"+$i+$side);
				parent ($upperLower+"LipSurfaceAttach"+$i+$side) LipJoints;
				}

				//Lip_$ control
				if ($upperLower=="upper")
					pingPong ($upperLower+"LipCenter"+$numLip+"_R") Lip $b $side 7;
				connectAttr ("LipJoint"+$side+".t") ($upperLower+"LipRibbonClusterGrpCtrl"+$side+".t");
				connectAttr ("LipJoint"+$side+".r") ($upperLower+"LipRibbonClusterGrpCtrl"+$side+".r");

				//LipMid_$ control (temp set a xform since pingPong dont know about `cluster -piv`)
				createNode -n ($upperLower+"LipMid") transform;
				$pos=`xform -q -ws -piv ($upperLower+"LipRibbonClusterC"+$side+"Handle")`;
				xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($upperLower+"LipMid");
				pingPong ($upperLower+"LipMid") ($upperLower+"LipMid") $b $side 10;
				delete ($upperLower+"LipMid");
//				connectAttr ($upperLower+"LipMid"+$side+".t") ($upperLower+"LipRibbonClusterC"+$side+"Handle.translate");
//				connectAttr ($upperLower+"LipMid"+$side+".r") ($upperLower+"LipRibbonClusterC"+$side+"Handle.rotate");
				connectAttr ($upperLower+"LipMidJoint"+$side+".t") ($upperLower+"LipRibbonClusterC"+$side+"Handle.t");
				connectAttr ($upperLower+"LipMidJoint"+$side+".r") ($upperLower+"LipRibbonClusterC"+$side+"Handle.r");

				//Lip manual rot
				addAttr -ln ($upperLower+"rot") -k 1 -at double -dv 0 ("Lip"+$side);
				createNode -n ($upperLower+"LipRotManualUnitConversion"+$side) unitConversion;
				if ($upperLower=="upper")
					setAttr ($upperLower+"LipRotManualUnitConversion"+$side+".conversionFactor") 0.1;
				if ($upperLower=="lower")
					setAttr ($upperLower+"LipRotManualUnitConversion"+$side+".conversionFactor") -0.1;
				connectAttr ("Lip"+$side+"."+$upperLower+"rot") ($upperLower+"LipRotManualUnitConversion"+$side+".input");
				connectAttr ($upperLower+"LipRotManualUnitConversion"+$side+".output") ($upperLower+"LipRibbonClusterGrpManualSmooth"+$side+".rz"); 
			}
		//Lip_M control (temp set a xform since pingPong dont know about `cluster -piv`)
		createNode -n ($upperLower+"Lip") transform;
		delete `pointConstraint ($upperLower+"LipRibbonCluster_MHandle") ($upperLower+"Lip")`;

		pingPong ($upperLower+"Lip") ($upperLower+"Lip") 1 "_M" 7;
		connectAttr ($upperLower+"Lip_M.t") ($upperLower+"LipRibbonCluster_MHandle.translate");
		connectAttr ($upperLower+"Lip_M.r") ($upperLower+"LipRibbonCluster_MHandle.rotate");
		delete ($upperLower+"Lip");

		//autoribbonsmoothers
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==1) $side="_R"; else $side="_L";

			//clusterGrp Scale - ry
			createNode -n ($upperLower+"LipDistance"+$side) distanceBetween;
			$tempString=`spaceLocator`;
			rename $tempString[0] ($upperLower+"LipRibbonLocatorA"+$side);
			setAttr ($upperLower+"LipRibbonLocatorA"+$side+".v") 0;
			parent ($upperLower+"LipRibbonLocatorA"+$side) LipLocators;
			pointConstraint ($upperLower+"LipRibbonClusterGrpAutoSmooth"+$side) ($upperLower+"LipRibbonLocatorA"+$side);
			if ($side=="_R")
				{
				$tempString=`spaceLocator`;
				rename $tempString[0] ($upperLower+"LipRibbonLocator_M");
				setAttr ($upperLower+"LipRibbonLocator_M.v") 0;
				parent ($upperLower+"LipRibbonLocator_M") LipLocators;
				pointConstraint ($upperLower+"LipRibbonCluster_MHandle") ($upperLower+"LipRibbonLocator_M");
				}
			connectAttr ($upperLower+"LipRibbonLocatorA"+$side+"Shape.worldPosition") ($upperLower+"LipDistance"+$side+".point1");
			connectAttr ($upperLower+"LipRibbonLocator_MShape.worldPosition") ($upperLower+"LipDistance"+$side+".point2");
			createNode -n ($upperLower+"LipDistanceNormalize"+$side) multiplyDivide;
			setAttr ($upperLower+"LipDistanceNormalize"+$side+".operation") 2;
			connectAttr ($upperLower+"LipDistance"+$side+".distance") ($upperLower+"LipDistanceNormalize"+$side+".input1X");
			setAttr ($upperLower+"LipDistanceNormalize"+$side+".input2X") `getAttr ($upperLower+"LipDistance"+$side+".distance")`;
			createNode -n ($upperLower+"LipDistanceRange"+$side) setRange;
			connectAttr ($upperLower+"LipDistanceNormalize"+$side+".outputX") ($upperLower+"LipDistanceRange"+$side+".valueX");
			setAttr ($upperLower+"LipDistanceRange"+$side+".minX") 0.001;
			setAttr ($upperLower+"LipDistanceRange"+$side+".maxX") 1;
			setAttr ($upperLower+"LipDistanceRange"+$side+".oldMaxX") 1;
			//(ry)
			createNode -n ($upperLower+"LipRotYMultiply"+$side) multiplyDivide;
			connectAttr ($upperLower+"LipDistanceRange"+$side+".outValueX") ($upperLower+"LipRotYMultiply"+$side+".input1X");
			setAttr ($upperLower+"LipRotYMultiply"+$side+".input2X") `getAttr ($upperLower+"LipRibbonClusterGrpAutoSmooth"+$side+".ry")`;
			connectAttr ($upperLower+"LipRotYMultiply"+$side+".outputX") ($upperLower+"LipRibbonClusterGrpAutoSmooth"+$side+".ry");

			//jointToAttacherOffset
			for ($i=1;$i<$numLip;$i++)
				{
				createNode -n ($upperLower+"LipJointOffsetMultiply"+$i+$side) multiplyDivide;
				connectAttr ($upperLower+"LipDistanceRange"+$side+".outValueX") ($upperLower+"LipJointOffsetMultiply"+$i+$side+".input1X");
				connectAttr ($upperLower+"LipDistanceRange"+$side+".outValueX") ($upperLower+"LipJointOffsetMultiply"+$i+$side+".input1Y");
				connectAttr ($upperLower+"LipDistanceRange"+$side+".outValueX") ($upperLower+"LipJointOffsetMultiply"+$i+$side+".input1Z");
				setAttr ($upperLower+"LipJointOffsetMultiply"+$i+$side+".input2X") `getAttr ($upperLower+"LipCenter"+$i+$side+".tx")`;
				setAttr ($upperLower+"LipJointOffsetMultiply"+$i+$side+".input2Y") `getAttr ($upperLower+"LipCenter"+$i+$side+".ty")`;
				setAttr ($upperLower+"LipJointOffsetMultiply"+$i+$side+".input2Z") `getAttr ($upperLower+"LipCenter"+$i+$side+".tz")`;
				connectAttr ($upperLower+"LipJointOffsetMultiply"+$i+$side+".output") ($upperLower+"LipCenter"+$i+$side+".t");

				}

			//scaleConstraint
			if ($upperLower=="upper")
				{
				createNode -n ("LipBlender"+$side) -p ($upperLower+"LipRibbonClusterGrpCtrl"+$side) transform;
				connectAttr ("Lip"+$side+".r") ("LipBlender"+$side+".r");
				connectAttr ("Lip"+$side+".s") ("LipBlender"+$side+".s");
				}
			createNode -n ($upperLower+"LipMidScaler"+$side) -p ($upperLower+"LipRibbonClusterCHandleOffset"+$side) transform;
			connectAttr ($upperLower+"LipMid"+$side+".r") ($upperLower+"LipMidScaler"+$side+".r");
			connectAttr ($upperLower+"LipMid"+$side+".s")($upperLower+"LipMidScaler"+$side+".s");
			if ($side=="_R")
				{
				createNode -n ($upperLower+"LipBlender_M") -p ($upperLower+"LipRibbonClusterHandleOffset_M") transform;
				connectAttr ($upperLower+"Lip_M.r") ($upperLower+"LipBlender_M.r");
				connectAttr ($upperLower+"Lip_M.s") ($upperLower+"LipBlender_M.s");
				}
			for ($i=0;$i<($numLip+1);$i++)
				{
				$jointSide=$side;
				if ($i==0) $jointSide="_M";
				$factor=($i/($numLip+0.0));

				orientConstraint -w $factor ("LipBlender"+$side) ("LipBlender"+$side) ($upperLower+"LipCenter"+$i+$jointSide);
				orientConstraint -w (1-$factor) ($upperLower+"LipBlender_M") ($upperLower+"LipCenter"+$i+$jointSide);
				orientConstraint -w ((abs(0.5-(abs($factor-0.5))))*2) ($upperLower+"LipMidScaler"+$side) ($upperLower+"LipCenter"+$i+$jointSide);

				scaleConstraint -w $factor ("LipBlender"+$side) ($upperLower+"LipCenter"+$i+$jointSide);
				scaleConstraint -w (1-$factor) ($upperLower+"LipBlender_M") ($upperLower+"LipCenter"+$i+$jointSide);
				scaleConstraint -w ((abs(0.5-(abs($factor-0.5))))*2) ($upperLower+"LipMidScaler"+$side) ($upperLower+"LipCenter"+$i+$jointSide);
				}

			//Mids affected by corner in center
			asFaceAddIn {($upperLower+"LipJoint_M"),("LipJoint"+$side)} ($upperLower+"LipMidJoint"+$side) 1;
			}
		}
	eval $parentCmd;
	}


//intersystem relations :)  lipCorner -> cheek
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	if (`objExists Lip_R` && `objExists cheekMouthCorner_R`)
		{
		connectAttr ("Lip"+$side+".tx") ("cheekMouthCorner"+$side+".tx");connectAttr ("Lip"+$side+".ty") ("cheekMouthCorner"+$side+".ty");connectAttr ("Lip"+$side+".tz") ("cheekMouthCorner"+$side+".tz");
		connectAttr ("Lip"+$side+".rx") ("cheekMouthCorner"+$side+".rx");connectAttr ("Lip"+$side+".ry") ("cheekMouthCorner"+$side+".ry");connectAttr ("Lip"+$side+".tz") ("cheekMouthCorner"+$side+".rz");
		connectAttr ("Lip"+$side+".sx") ("cheekMouthCorner"+$side+".sx");connectAttr ("Lip"+$side+".sy") ("cheekMouthCorner"+$side+".sy");connectAttr ("Lip"+$side+".sz") ("cheekMouthCorner"+$side+".sz");

		//Follow
		addAttr -dv 5 -k 1 -smn 0 -hsn 1 -smx 10 -hsx 1 -ln smileFollow -at double ("Lip"+$side);
		createNode -n ("smileFollowUnitConversion"+$side) unitConversion;
		setAttr ("smileFollowUnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("Lip"+$side+".smileFollow") ("smileFollowUnitConversion"+$side+".input");

		createNode -n ("smileFollowmultiplyDivide"+$side) multiplyDivide;
		connectAttr ("Lip"+$side+".t") ("smileFollowmultiplyDivide"+$side+".input1");
		connectAttr ("smileFollowUnitConversion"+$side+".output") ("smileFollowmultiplyDivide"+$side+".input2X");
		connectAttr ("smileFollowUnitConversion"+$side+".output") ("smileFollowmultiplyDivide"+$side+".input2Y");
		connectAttr ("smileFollowUnitConversion"+$side+".output") ("smileFollowmultiplyDivide"+$side+".input2Z");
	
		createNode -n ("smileFollowplusMinusAverage"+$side) plusMinusAverage;
		connectAttr ("smile"+$side+".t") ("smileFollowplusMinusAverage"+$side+".input3D[0]");
		connectAttr ("smileFollowmultiplyDivide"+$side+".output") ("smileFollowplusMinusAverage"+$side+".input3D[1]");
		connectAttr -f ("smileFollowplusMinusAverage"+$side+".output3D.output3Dx") ("smileJoint"+$side+".tx");
		connectAttr -f ("smileFollowplusMinusAverage"+$side+".output3D.output3Dy") ("smileJoint"+$side+".ty");
		connectAttr -f ("smileFollowplusMinusAverage"+$side+".output3D.output3Dz") ("smileJoint"+$side+".tz");

		//Bulge
		addAttr -dv 3 -k 1 -smn 0 -hsn 1 -smx 10 -hsx 1 -ln smileBulge -at double ("Lip"+$side);
/*
		createNode -n ("smileBulgeUnitConversion"+$side) unitConversion;
		setAttr ("smileBulgeUnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("Lip"+$side+".smileBulge") ("smileBulgeUnitConversion"+$side+".input");
*/		
		createNode -n ("smileBulge"+$side) transform;
		$pos=`xform -q -ws -t ("smile"+$side)`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ("smileBulge"+$side);
		parent ("smileBulge"+$side) cheekHead;
		parent ("smileJointOffset"+$side) ("smileBulge"+$side);

		createNode -n ("smileDistance"+$side) distanceBetween;
		connectAttr ("Lip"+$side+".t ") ("smileDistance"+$side+".point2");

		createNode -n ("smileBulgeNormalize"+$side) multiplyDivide;
		connectAttr ("smileDistance"+$side+".distance") ("smileBulgeNormalize"+$side+".input1X");
//		setAttr ("smileBulgeNormalize"+$side+".input2X") $scale;
		setAttr ("smileBulgeNormalize"+$side+".input2X") 0.185457;

		createNode -n ("smileBulgemultiplyDivide"+$side) multiplyDivide;
		connectAttr ("smileBulgeNormalize"+$side+".outputX") ("smileBulgemultiplyDivide"+$side+".input1X");
		connectAttr ("Lip"+$side+".smileBulge") ("smileBulgemultiplyDivide"+$side+".input2X");
/*
		createNode -n ("smileBulgePlusOne"+$side) plusMinusAverage;
		connectAttr ("smileBulgemultiplyDivide"+$side+".outputX") ("smileBulgePlusOne"+$side+".input1D[0]");
		setAttr ("smileBulgePlusOne"+$side+".input1D[1]") 1;

		connectAttr ("smileBulgePlusOne"+$side+".output1D") ("smileJointOffset"+$side+".sx");
		connectAttr ("smileBulgePlusOne"+$side+".output1D") ("smileJointOffset"+$side+".sy");
		connectAttr ("smileBulgePlusOne"+$side+".output1D") ("smileJointOffset"+$side+".sz");
*/
		connectAttr ("smileBulgemultiplyDivide"+$side+".outputX") ("smileJointOffset"+$side+".tz");
		}
	}


//hammer edgeLevels out from lips (until reach noseCorner)
if (`objExists noseCornerJoint_R`)
	{
	select noseCornerJoint_R;
	asFaceSelectVtxFromJoint lipDeform;
	$tempString=`ls -sl`;
	string $noseCornerVtx=$tempString[0];
	select `ls -type joint "*Lip*_*"`;
	select -d `ls -type joint "*LipCenter*_*"`;
	asFaceSelectVtxFromJoint lipDeform;
	string $lipVtxs[]=`ls -sl`;
	select `ls "*LipOuter*_*"`;
	asFaceSelectVtxFromJoint lipDeform;
	for ($i=0;$i<10;$i++)
		{
		GrowPolygonSelectionRegion;
		$tempString=`ls -sl -fl`;
		if (`stringArrayCount $noseCornerVtx $tempString`)
			break;
		}
	select -d $lipVtxs;
	if (size(`ls -sl`))
		weightHammerVerts ;
	}

//mirrorSkinWeights
string $mirrorClusters[]={$skinCluster,"lipDeformSkinCluster","lidDeformSkinCluster","cheekDeformSkinCluster"};
for ($i=0;$i<size($mirrorClusters);$i++)
	if (`objExists $mirrorClusters[$i]`)
		copySkinWeights -ss $mirrorClusters[$i] -ds $mirrorClusters[$i] -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//remove unUsed influences
select $geometry;
removeUnusedInfluences;

if (`objExists squashBase` && `objExists squashTop`)
	asFaceSoftRegions;

//Cleanup
//setAttr -l 1 RegionSetup.v 0;
if (`objExists closestSampler`)
	delete closestSampler;
delete closestSurfaceSampler;
delete "iconsGroup";
select -cl;

refresh;//To hint that there are more controllers than what is visible by default
int $cageFace=`objExists PcageGroup`;
if ($cageFace)
	asFaceProcessor;

asFaceCtrlBox;
asFaceBsSdkSetup;

//$tongueSkinCluster seems to go `dud` after rebuild..
if (`objExists $tongueSkinCluster`)
	dgdirty $tongueSkinCluster;

//hide controls from bodySetup
/*
if (`objExists Main`)
	{
	if (`attributeExists eyeVis Main`)
		setAttr Main.eyeVis 0;
	if (`attributeExists aimVis Main`)
	 setAttr Main.aimVis 0;
	if (`attributeExists arrowVis Main`)
	 setAttr Main.arrowVis 0;
	}
*/

//buildPose
createNode -n faceBuildPose dagPose;
select `sets -q FaceControlSet`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controlSetMembers[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
addAttr -ln udAttr -dt "string"  faceBuildPose;
setAttr -type "string" faceBuildPose.udAttr $setAttrCmd;

//FaceAllset
string $allAfter[]=`ls`;
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $allBefore $myIntersector;
stringArrayIntersector -edit -intersect $allAfter $myIntersector;
string $allSame[]=`stringArrayIntersector -query $myIntersector`;
deleteUI $myIntersector;

select $allAfter;
select -d $allSame;
select -d `ls -type objectSet`;
select -d `listRelatives -ad FaceFitSkeleton`;
if (`objExists $tongue`)
	select -d $tongue;
sets -add FaceAllSet `ls -sl`;
select FaceControlSet;
sets -add FaceAllSet `ls -sl`;
if (`objExists jawArea`)
	sets -add "Sets" jawArea;

clear $allBefore;clear $allAfter;clear $allSame;

polySelectConstraint -m 0;
delete faceBuildStartPoint faceBuildEndPoint faceBuildDist;
setAttr FaceMotionSystem.template 0;

//setAttr "ctrlBox.CCtrlVis" 0;
//setAttr "ctrlBox.BCtrlVis" 0;

//Remove FKExtraJaw_M from body controlSet, if this is now driven by face.
if (`objExists FKExtraJaw_M` && `objExists ControlSet` && `objExists buildPose`)
	{
	$tempString=`listConnections -s 1 -d 0 -type animCurve FKExtraJaw_M`;
	if ($tempString[0]!="")
		sets -rm ControlSet FKExtraJaw_M;
	//remove from buildPose..udAttr
	string $setAttrCmd=`getAttr buildPose.udAttr`;
	string $newSetAttrCmd;
	tokenize $setAttrCmd ";" $tempString;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (!`gmatch $tempString[$y] "setAttr FKExtraJaw_M*"`)
			$newSetAttrCmd+=$tempString[$y]+";";
		}
	setAttr -type "string" buildPose.udAttr $newSetAttrCmd;
	}
select -cl;
}

global proc float asFaceGetScale ()
{
float $scale=0.346;
for ($i=1;$i<99;$i++)
	if (`objExists ("upperLipOuter"+$i)`)
		$scale=(`getAttr ("upperLipOuter"+$i+".tx")`*-1);
return $scale;
}

global proc asFaceCreateCtrl (string $name, string $side, string $controlLevel)
{
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
string $geometry=`textField -q -tx asFsGeometryTextField`;
if ($controlLevel=="B" || $controlLevel=="D")
	{
	createNode -n ($name+"Attach"+$side) transform;
	createNode -n ($name+"Subtract"+$side) transform;
	}
createNode -n ($name+"Offset"+$side) transform;
string $templateIcon=("Face"+$controlLevel+"_icon");
string $tempString[];
if (`objExists $templateIcon`)
	duplicate -n ($name+$side) $templateIcon;
else
	{
	string $curve=`curve -d 3 -p 0 4.00000122 0 -p 2.655399974e-017 3.923881127 0.3826834667 -p 4.906546435e-017 3.707107862 0.7071078623 -p 6.410713118e-017 3.382683467 0.9238811267 -p 6.938902366e-017 3 1.00000122 -p 6.410713118e-017 2.617316533 0.9238811267 -p 4.906546435e-017 2.292892138 0.7071078623 -p 2.655399974e-017 2.076118873 0.3826834667 -p 0 1.99999878 0 -p -2.655399974e-017 2.076118873 -0.3826834667 -p -4.906546435e-017 2.292892138 -0.7071078623 -p -6.410713118e-017 2.617316533 -0.9238811267 -p -6.938902366e-017 3 -1.00000122 -p -6.410713118e-017 3.382683467 -0.9238811267 -p -4.906546435e-017 3.707107862 -0.7071078623 -p -2.655399974e-017 3.923881127 -0.3826834667 -p 0 4.00000122 0 -p 0.3826834667 3.923881127 -2.655399974e-017 -p 0.7071078623 3.707107862 -4.906546435e-017 -p 0.9238811267 3.382683467 -6.410713118e-017 -p 1.00000122 3 -6.938902366e-017 -p 0.9238811267 2.617316533 -6.410713118e-017 -p 0.7071078623 2.292892138 -4.906546435e-017 -p 0.3826834667 2.076118873 -2.655399974e-017 -p 0 1.99999878 0 -p -0.3826834667 2.076118873 2.655399974e-017 -p -0.7071078623 2.292892138 4.906546435e-017 -p -0.9238811267 2.617316533 6.410713118e-017 -p -1.00000122 3 6.938902366e-017 -p -0.9238811267 3.382683467 6.410713118e-017 -p -0.7071078623 3.707107862 4.906546435e-017 -p -0.3826834667 3.923881127 2.655399974e-017 -p 0 4.00000122 0 -p -2.655399974e-017 3.923881127 -0.3826834667 -p -4.906546435e-017 3.707107862 -0.7071078623 -p -6.410713118e-017 3.382683467 -0.9238811267 -p -6.938902366e-017 3 -1.00000122 -p -0.3826834667 3 -0.9238811267 -p -0.7071078623 3 -0.7071078623 -p -0.9238811267 3 -0.3826834667 -p -1.00000122 3 6.938902366e-017 -p -0.9238811267 3 0.3826834667 -p -0.7071078623 3 0.7071078623 -p -0.3826834667 3 0.9238811267 -p 6.938902366e-017 3 1.00000122 -p 0.3826834667 3 0.9238811267 -p 0.7071078623 3 0.7071078623 -p 0.9238811267 3 0.3826834667 -p 1.00000122 3 -6.938902366e-017 -p 0.9238811267 3 -0.3826834667 -p 0.7071078623 3 -0.7071078623 -p 0.3826834667 3 -0.9238811267 -p -6.938902366e-017 3 -1.00000122`;
	rename $curve ($name+$side);
	setAttr ($name+$side+"Shape.overrideEnabled") 1;
	setAttr ($name+$side+"Shape.overrideColor") 18;
	}
xform -ws -t 0 0 0 ($name+$side);
sets -add "FaceControlSet" ($name+$side);
setAttr ($name+$side+".ry") 90;
string $tempString[]=`listRelatives -s ($name+$side)`;
string $tempString2[]=`listConnections -p 1 ($tempString[0]+".instObjGroups[0]")`;
string $fitJoint=$name;
float $scale=`asFaceGetScale`;
//setAttr ($tempString[0]+".overrideColor") `getAttr ($fitJoint+".overrideColor")`;
if ($controlLevel=="B" || $controlLevel=="D")
	{
	parent ($name+"Offset"+$side) ($name+"Attach"+$side);
	parent ($name+"Subtract"+$side) ($name+"Offset"+$side);
	parent ($name+$side) ($name+"Subtract"+$side);
	}
else
	parent ($name+$side) ($name+"Offset"+$side);
if ($controlLevel=="D")
	parent ($name+"Attach"+$side) Bcontrols;
if ($controlLevel=="B")
	parent ($name+"Attach"+$side) Acontrols;
else
	parent ($name+"Offset"+$side) Acontrols;
xform -ws -s ($scale*0.15) ($scale*0.15) ($scale*0.15) ($name+$side);
if ($controlLevel=="D")
	{
	xform -ws -s ($scale*0.08) ($scale*0.08) ($scale*0.08) ($name+$side);
	select -r ($name+$side+".cv[0:999]");
	move -r 0 0 ($scale*0.15);
	}
makeIdentity -a 1 -t 0 -r 1 -s 1 ($name+$side);

//Place
float $pos[3]=`xform -q -ws -t $fitJoint`;
int $b=1;
if ($side=="_L")
	$b=-1;
if ($controlLevel=="B" || $controlLevel=="D")
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"Attach"+$side);
else
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"Offset"+$side);


if ($controlLevel=="A")
	{
	if ($side=="_L")
		//placeHolder, to simplyfy poseMirroring
		addAttr -ln "mirror" -k 0 -at double -min 0 -max 10 -dv 0 ($name+"_L");
	if ($side!="_L")
		return;
	$oppositeSide=`substitute "_L" $side "_R"`;

	createNode -n ($name+"Mirror"+$side) transform;
	parent ($name+"Mirror"+$side) ($name+"Offset"+$side);
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 ($name+"Mirror"+$side);
	parent ($name+$side) ($name+"Mirror"+$side);
	createNode -n ($name+"PlusMinusAverageMirrorT"+$side) plusMinusAverage;
	connectAttr -f ($name+"Mirror"+$side+".t") ($name+"PlusMinusAverageMirrorT"+$side+".input3D[0]");
	connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverageMirrorT"+$side+".input3D[1]");
	createNode -n ($name+"PlusMinusAverageMirrorR"+$side) plusMinusAverage;
	connectAttr -f ($name+"Mirror"+$side+".r") ($name+"PlusMinusAverageMirrorR"+$side+".input3D[0]");
	connectAttr -f ($name+$side+".r") ($name+"PlusMinusAverageMirrorR"+$side+".input3D[1]");
	createNode -n ($name+"PlusMinusAverageMirrorS"+$side) plusMinusAverage;
	connectAttr -f ($name+"Mirror"+$side+".s") ($name+"PlusMinusAverageMirrorS"+$side+".input3D[0]");
	connectAttr -f ($name+$side+".s") ($name+"PlusMinusAverageMirrorS"+$side+".input3D[1]");

	addAttr -ln "mirror" -k 1 -at double -min 0 -max 10 -dv 0 ($name+$oppositeSide);
	createNode -n ($name+"MouthMirrorUnitConversion"+$oppositeSide) unitConversion;
	setAttr ($name+"MouthMirrorUnitConversion"+$oppositeSide+".conversionFactor") 0.1;
	connectAttr ($name+$oppositeSide+".mirror") ($name+"MouthMirrorUnitConversion"+$oppositeSide+".input");

	//MultiplyDivideXFactor (mirror multiplier)
	createNode -n ($name+"MultiplyDivideTFactor"+$side) multiplyDivide;
	createNode -n ($name+"MultiplyDivideRFactor"+$side) multiplyDivide;
	connectAttr ($name+$oppositeSide+".t") ($name+"MultiplyDivideTFactor"+$side+".input1");
	connectAttr ($name+$oppositeSide+".r") ($name+"MultiplyDivideRFactor"+$side+".input1");
	connectAttr ($name+"MouthMirrorUnitConversion"+$oppositeSide+".output") ($name+"MultiplyDivideTFactor"+$side+".input2X");
	connectAttr ($name+"MouthMirrorUnitConversion"+$oppositeSide+".output") ($name+"MultiplyDivideTFactor"+$side+".input2Y");
	connectAttr ($name+"MouthMirrorUnitConversion"+$oppositeSide+".output") ($name+"MultiplyDivideTFactor"+$side+".input2Z");
	connectAttr ($name+"MouthMirrorUnitConversion"+$oppositeSide+".output") ($name+"MultiplyDivideRFactor"+$side+".input2X");
	connectAttr ($name+"MouthMirrorUnitConversion"+$oppositeSide+".output") ($name+"MultiplyDivideRFactor"+$side+".input2Y");
	connectAttr ($name+"MouthMirrorUnitConversion"+$oppositeSide+".output") ($name+"MultiplyDivideRFactor"+$side+".input2Z");


	//MultiplyDivideX (rot & trans - axis multiplier)
	createNode -n ($name+"MultiplyDivideT"+$side) multiplyDivide;
	createNode -n ($name+"MultiplyDivideR"+$side) multiplyDivide;
	setAttr -type float3 ($name+"MultiplyDivideT"+$side+".input2") -1 1 1;
	setAttr -type float3 ($name+"MultiplyDivideR"+$side+".input2") 1 -1 -1;
	connectAttr ($name+"MultiplyDivideTFactor"+$side+".output") ($name+"MultiplyDivideT"+$side+".input1");
	connectAttr ($name+"MultiplyDivideRFactor"+$side+".output") ($name+"MultiplyDivideR"+$side+".input1");

	connectAttr ($name+"MultiplyDivideT"+$side+".output") ($name+"Mirror"+$side+".t");
	connectAttr ($name+"MultiplyDivideR"+$side+".output") ($name+"Mirror"+$side+".r");
	
	//`Blend` scale 
	createNode -n ($name+"blendTwoAttr"+$side) blendColors;
	setAttr ($name+"blendTwoAttr"+$side+".color1") -type double3 1 1 1;
	connectAttr ($name+$oppositeSide+".s") ($name+"blendTwoAttr"+$side+".color1");
	setAttr ($name+"blendTwoAttr"+$side+".color2") -type double3 1 1 1;
	connectAttr ($name+"MouthMirrorUnitConversion"+$oppositeSide+".output") ($name+"blendTwoAttr"+$side+".blender");
	connectAttr ($name+"blendTwoAttr"+$side+".output") ($name+"Mirror"+$side+".s");

	return;
	}

//Attach
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $tempString[]=`listRelatives -ni -s $geometry`;
if (!`objExists closestSampler`)
	createNode -n closestSampler closestPointOnMesh;
if (!`isConnected ($tempString[0]+".outMesh") closestSampler.inMesh`)
	connectAttr -f ($tempString[0]+".outMesh") closestSampler.inMesh;
if (!`isConnected ($geometry+".xformMatrix") closestSampler.inputMatrix`)
	connectAttr -f ($geometry+".xformMatrix") closestSampler.inputMatrix;

float $geoWsPos[]=`xform -q -ws -t $geometry`;
setAttr -type float3 closestSampler.inPosition (($pos[0]*$b)-$geoWsPos[0]) ($pos[1]-$geoWsPos[1]) ($pos[2]-$geoWsPos[2]);
string $vtx=`getAttr closestSampler.result.closestVertexIndex`;
delete closestSampler;
select ($geometry+".vtx["+$vtx+"]");
ConvertSelectionToEdges;
string $edges[]=`ls -sl -fl`;
select $edges[0];
$tempString=`duplicateCurve -ch 1 -rn 0 -local 0`;
string $dupCurve=$tempString[0];
rename $dupCurve ($name+"Curve"+$side);
rename $tempString[1] ($name+"CurveEdge"+$side);
setAttr -l 1 ($name+"Curve"+$side+".v") 0;
parent ($name+"Curve"+$side) ClusterSetup;
createNode -n ($name+"PointOnCurveInfo"+$side) pointOnCurveInfo;
setAttr ($name+"PointOnCurveInfo"+$side+".turnOnPercentage") 1;
connectAttr -f ($name+"Curve"+$side+"Shape.worldSpace[0]") ($name+"PointOnCurveInfo"+$side+".inputCurve");
//determine PointOnCurveInfo.parameter
float $tempFloatA[]=`xform -q -ws -t ($name+$side)`;
float $tempFloatB[]=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
float $magAB=`mag<<$tempFloatA[0]-$tempFloatB[0],$tempFloatA[1]-$tempFloatB[1],$tempFloatA[2]-$tempFloatB[2]>>`;
setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 1;
float $tempFloatC[]=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
float $magAC=`mag<<$tempFloatA[0]-$tempFloatC[0],$tempFloatA[1]-$tempFloatC[1],$tempFloatA[2]-$tempFloatC[2]>>`;
if ($magAB<$magAC)
	setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 0;

//avoid double Xform
createNode -n ($name+"PlusMinusAverage"+$side) plusMinusAverage;
setAttr ($name+"PlusMinusAverage"+$side+".operation") 2;
connectAttr -f ($name+"PointOnCurveInfo"+$side+".position") ($name+"Attach"+$side+".t");
connectAttr -f Brs.r ($name+"Attach"+$side+".r");
connectAttr -f Brs.s ($name+"Attach"+$side+".s");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[1]");
disconnectAttr ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
parent -w ($name+"Offset"+$side);
connectAttr -f ($name+"PlusMinusAverage"+$side+".output3D") ($name+"Subtract"+$side+".t");
//orientConstraint $headJoint ($name+"Attach"+$side);
xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);
}

global proc asFaceCreateDistanceMessure ()
{
string $sel[]=`ls -sl`;
select -cl;
string $temp=`distanceDimension -sp 1 1 1 -ep 2 2 2`;
rename $temp faceBuildDistShape;
string $tempString3[]=`listConnections faceBuildDistShape.startPoint`;
rename $tempString3[0] faceBuildStartPoint;
string $tempString3[]=`listConnections faceBuildDistShape.endPoint`;
rename $tempString3[0] faceBuildEndPoint;
string $tempString3[]=`listRelatives -p faceBuildDistShape`;
rename $tempString3[0] faceBuildDist;
select $sel;
}

global proc string asFaceGetNrFromJoint (string $joint)
{
string $nr;
int $subEnd=size($joint);
if (`gmatch $joint "*[0-9][0-9]"`)
	$subEnd--;
$nr=`substring $joint $subEnd 999`;
return $nr;
}

/*
global proc asFaceSkinAreaByVolume (string $geometry, string $skinCluster, string $posTrn, string $inf, float $falloffRadius, float $falloffMode, float $value)
{
//add inf if not already
string $connectedSkinClusters[]=`listConnections -type skinCluster ($inf+".worldMatrix")`;
if(!`stringArrayCount $skinCluster  $connectedSkinClusters`)
	skinCluster -e -ai $inf -lw false -wt 0 $skinCluster;
select $geometry;
float $pos[3]=`xform -q -ws -t $posTrn`;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
$vtxs=`ls -sl -fl`;
for ($vtx in $vtxs)
	skinPercent -tv $inf $value $skinCluster $vtx;
}
*/

global proc asFaceSkinAreaBySoftMod (string $geometry, string $skinCluster, string $posTrn, string $inf, float $falloffRadius, float $falloffMode, float $value)
{
select $geometry;
float $pos[3]=`xform -q -ws -t $posTrn`;

//softmod create
select -r $geometry;
string $tempString[]=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=$tempString[0];
string $softModHandle=$tempString[1];
string $tempString[]=`listConnections ($softMod+".message")`;
string $softModSet=$tempString[0];
setAttr -type float3 ($softModHandle+"Shape.origin") $pos[0] $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") $pos[0] $pos[1] $pos[2];
xform -piv $pos[0] $pos[1] $pos[2] $softModHandle;
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;

//softmod prune
setAttr -type float3 ($softModHandle+".t") 1 0 0;
softMod -e -pr $softMod;
string $tempString[]=`listConnections ($softMod+".message")`;
select `sets -q $tempString[0]`;
string $vtxs[]=`ls -sl -fl`;
setAttr -type float3 ($softModHandle+".t") 0 0 0;

//softmod to skinCluster
select `sets -q $softModSet`;
string $vtxs[]=`ls -sl -fl`;
move -r -ws 1 0 0 $softModHandle;
for ($i=0;$i<size($vtxs);$i++)
	{
	setAttr ($softMod+".envelope") 0;
	$posA=`xform -q -ws -t $vtxs[$i]`;
	setAttr ($softMod+".envelope") 1;
	$posB=`xform -q -ws -t $vtxs[$i]`;
	$mag=$posB[0]-$posA[0];
	catchQuiet (`skinPercent -tv $inf $mag $skinCluster $vtxs[$i]`);
	}
move -r -ws -1 0 0 $softModHandle;
delete $softMod;
}

global proc asCreateFaceFitJoint (string $region, float $size, int $color)
{
string $sel[]=`ls -sl -fl`;
float $pos[3]=`xform -q -ws -t $sel[0]`;
float $centerErrorMargin=0.001;
if ($region=="mouthUpper" || $region=="mouthLower" || $region=="noseTip" || $region=="eyeBrow0")
	if ($pos[0]>$centerErrorMargin || $pos[0]<(-1*$centerErrorMargin))
		error ($region+" needs to be in the center, currently:"+$pos[0]+"\n");
int $jointNumber;
string $jointName;
for ($i=1;$i<99;$i++)
	{
	$jointNumber=$i;
	$jointName=$region+$jointNumber;
	if (!`objExists $jointName`)
		break;
	}
if (!`objExists FaceGroup`)
	asFaceCreateTopNode;
for ($i=0;$i<size($sel);$i++)
	{
	$jointName=$region;
	if (size($sel)>1)
		$jointName=$region+$jointNumber;
	$jointNumber++;
	$jointName=`asFaceCreateFitJoint $jointName $size $color`;
	$pos=`xform -q -ws -t $sel[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $jointName;
	}

if (`checkBox -q -ex ("asFace"+$region)`)
	checkBox -e -v 1 -ed 1 ("asFace"+$region);
hilite -r `ls -o $sel`; 
select $sel;
repeatLast -addCommand ("asCreateFaceFitJoint "+$region+" "+$size+" "+$color);

if (`gmatch $region "eyeBrow[0-9]"`)
	asAutoEyeBrowFalloff $region;
}

global proc asAutoEyeBrowFalloff (string $region)
{
float $posA[3],$posB[3];
float $mag;
int $nr=`substring $region 8 8`;
string $previousRegion="eyeBrow"+($nr-1);
if (!`objExists $previousRegion`)
	return;
$posA=`xform -q -ws -t $region`;
$posB=`xform -q -ws -t $previousRegion`;
$mag=mag(<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>);
setAttr ($region+".falloffRadius") $mag;
float $previousRad=`getAttr ($previousRegion+".falloffRadius")`;
if ($mag>$previousRad || $previousRegion=="eyeBrow0")
	setAttr ($previousRegion+".falloffRadius") $mag;
}

global proc string asFaceCreateFitJoint (string $name, float $radius, int $color)
{
if (`objExists $name`)
	error ($name+" Already Exists");

select FaceFitSkeleton;
joint -n $name;
setAttr ($name+".overrideEnabled") 1;
setAttr ($name+".overrideColor") $color;
addAttr -k 1 -min 0 -dv $radius -ln "falloffRadius" -at double $name;
addAttr -k 1 -ln "falloffMode"  -at "enum" -en "volume:surface:" $name;
addAttr -k 1 -ln "interpolation"  -at "enum" -en "none:linear:smooth:spline:" $name;
if (`gmatch $name "lowerEye*"` || `gmatch $name "upperEye*"` || `gmatch $name "lowerLip*"` || `gmatch $name "upperLip*"`)
	;
else
	{
	setAttr ($name+".falloffMode") 1;
	setAttr ($name+".interpolation") 2;
	}
if (`gmatch $name "*Sculpt*"`)
	setAttr ($name+".falloffMode") 0;
return $name;
}

global proc asFaceCreateTopNode ()
{
createNode -n FaceGroup transform;
if (`objExists "|Group"`)
	parent FaceGroup "|Group";
createNode -n FaceFitSkeleton transform;
parent FaceFitSkeleton FaceGroup;
}

global proc asFaceUpdateInfo (int $read)
{
string $attrs[]={"Geometry","AllFaceGeo" ,"Eye_L","Eye_R","UpperTeeth","LowerTeeth","Tongue","HeadJoint","JawJoint","JawControl",
	"EyeJoint_L","EyeJoint_R","EyeControl_L","EyeControl_R","SkinCluster","EyeLidPivot_L","EyeLidPivot_R","UpperTeethJoint","LowerTeethJoint"};

for ($i=0;$i<size($attrs);$i++)
	{
	string $texField="asFs"+$attrs[$i]+"TextField";
	if(!`textField -q -ex $texField`)
		continue;
	if ($read)
		{
		if (!`attributeExists $attrs[$i] FaceFitSkeleton`)
			continue;
		textField -e -tx `getAttr ("FaceFitSkeleton."+$attrs[$i])` $texField;
		}
	else
		{
		if (!`attributeExists $attrs[$i] FaceFitSkeleton`)
			addAttr -ln $attrs[$i] -dt "string" FaceFitSkeleton;
		setAttr -type "string" ("FaceFitSkeleton."+$attrs[$i]) `textField -q -tx $texField`;
		}
	}
}

global proc asCreateFaceController (string $name, string $side, int $color)
{
float $scale=`asFaceGetScale`;
string $tempString[]=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r ($scale/10.0) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
rename $tempString[0] ($name+$side);
sets -add "FaceControlSet" ($name+$side);
disconnectAttr -na ($name+$side+"Shape.instObjGroups[0]") initialShadingGroup.dagSetMembers;
setAttr ($name+$side+"Shape.overrideEnabled") 1;
setAttr ($name+$side+"Shape.overrideColor") $color;
createNode -n ($name+"Attach"+$side) transform;
createNode -n ($name+"Offset"+$side) transform;
createNode -n ($name+"Subtract"+$side) transform;
parent ($name+$side) ($name+"Subtract"+$side);
parent ($name+"Subtract"+$side) ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);
if ($color==6)
	parent ($name+"Attach"+$side) Acontrols;
if ($color==7)
	parent ($name+"Attach"+$side) Bcontrols;
if ($color==10)
	parent ($name+"Attach"+$side) Ccontrols;
}
	
global proc pingPong (string $trnPos, string $name, int $b, string $side, int $color)
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
float $scale=`asFaceGetScale`;
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
string $skinCluster=`textField -q -tx asFsSkinClusterTextField`;

float $pos[]=`xform -q -ws -t $trnPos`;


//Alternative attach position (e.g eyeLid)
float $attachPos[]=$pos;
string $altAttPosXform="";
int $nrUpperEyeInner,$nrLowerEyeInner;
for ($nrUpperEyeInner=1;$nrUpperEyeInner<99;$nrUpperEyeInner++) if (!`objExists ("upperEyeInner"+($nrUpperEyeInner+1))`) break;
for ($nrLowerEyeInner=1;$nrLowerEyeInner<99;$nrLowerEyeInner++) if (!`objExists ("lowerEyeInner"+($nrLowerEyeInner+1))`) break;
if ($name=="upperEye1")
	$altAttPosXform="upperEyeInner"+($nrUpperEyeInner/2);
if ($name=="lowerEye1")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner/2);
if ($name=="upperEye2")
	$altAttPosXform="upperEyeInner"+($nrUpperEyeInner/4);	
if ($name=="lowerEye2")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner/4);	
if ($name=="upperEye3")
	$altAttPosXform="upperEyeInner"+($nrLowerEyeInner - ($nrLowerEyeInner/4));	
if ($name=="lowerEye3")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner - ($nrLowerEyeInner/4));	
if ($name=="upperLip")
	$altAttPosXform="upperEyeInner4";
if($altAttPosXform!="")
	{
	float $altAttachPos[]=`xform -q -ws -t $altAttPosXform`;
	$attachPos={$altAttachPos[0],$altAttachPos[1],$altAttachPos[2]};
	if ($side=="_L")
		$attachPos={$altAttachPos[0]*-1,$altAttachPos[1],$altAttachPos[2]};
	}

//Alternative control position (e.g lips)
float $controlPos[]=$pos;
string $altCtrlPosXform="";
int $nrUpperLipOuter,$nrLowerLipOuter;
for ($nrUpperLipOuter=1;$nrUpperLipOuter<99;$nrUpperLipOuter++) if (!`objExists ("upperLipOuter"+($nrUpperLipOuter+1))`) break;
for ($nrLowerLipOuter=1;$nrLowerLipOuter<99;$nrLowerLipOuter++) if (!`objExists ("lowerLipOuter"+($nrLowerLipOuter+1))`) break;
if ($name=="upperLip")
	$altCtrlPosXform="upperLipMiddle"+`lipLetterClosestToCenterInY upper`+"0";
if ($name=="lowerLip")
	$altCtrlPosXform="lowerLipMiddle"+`lipLetterClosestToCenterInY lower`+"0";
if ($name=="Lip")
	$altCtrlPosXform="lowerLipOuter"+$nrLowerLipOuter;
if ($name=="upperLipMid")
	$altCtrlPosXform="upperLipMiddle"+`lipLetterClosestToCenterInY upper`+($nrUpperLipOuter/2);
if($altCtrlPosXform!="" && `objExists $altCtrlPosXform`)
	{
	float $altControlPos[]=`xform -q -ws -t $altCtrlPosXform`;
	$controlPos=$altControlPos;
	$attachPos=$controlPos;
	}

//nurbsSphere controller
asCreateFaceController $name $side $color;
xform -ws -t ($controlPos[0]*$b) $controlPos[1] $controlPos[2] ($name+"Attach"+$side);

//Joint + Offset
select -cl;
joint -n ($name+"Joint"+$side);
createNode -n ($name+"JointOffset"+$side) transform;
parent ($name+"Joint"+$side) ($name+"JointOffset"+$side);
xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"JointOffset"+$side);
parent ($name+"JointOffset"+$side) $headJoint;
string $bindToSkinCluster=$skinCluster;

if (!(`gmatch $name "upperEye*"` || `gmatch $name "lowerEye*"` || `gmatch $name "smile**"` || `gmatch $name "chin**"`))
	skinCluster -e -ai ($name+"Joint"+$side) -lw false -wt 0 $skinCluster;


//Attach
string $tempString[]=`listRelatives -ni -s $geometry`;
if (!`objExists closestSampler`)
	createNode -n closestSampler closestPointOnMesh;
if (!`isConnected ($tempString[0]+".outMesh") closestSampler.inMesh`)
	connectAttr -f ($tempString[0]+".outMesh") closestSampler.inMesh;
if (!`isConnected ($geometry+".xformMatrix") closestSampler.inputMatrix`)
	connectAttr -f ($geometry+".xformMatrix") closestSampler.inputMatrix;

float $geoWsPos[]=`xform -q -ws -t $geometry`;
setAttr -type float3 closestSampler.inPosition (($attachPos[0]*$b)-$geoWsPos[0]) ($attachPos[1]-$geoWsPos[1]) ($attachPos[2]-$geoWsPos[2]);
string $vtx=`getAttr closestSampler.result.closestVertexIndex`;
delete closestSampler;
select ($geometry+".vtx["+$vtx+"]");
ConvertSelectionToEdges;
string $edges[]=`ls -sl -fl`;
select $edges[0];
$tempString=`duplicateCurve -ch 1 -rn 0 -local 0`;
string $dupCurve=$tempString[0];
rename $dupCurve ($name+"Curve"+$side);
rename $tempString[1] ($name+"CurveEdge"+$side);
setAttr -l 1 ($name+"Curve"+$side+".v") 0;
parent ($name+"Curve"+$side) ClusterSetup;
createNode -n ($name+"PointOnCurveInfo"+$side) pointOnCurveInfo;
setAttr ($name+"PointOnCurveInfo"+$side+".turnOnPercentage") 1;
connectAttr -f ($name+"Curve"+$side+"Shape.worldSpace[0]") ($name+"PointOnCurveInfo"+$side+".inputCurve");
//determine PointOnCurveInfo.parameter
float $tempFloatA[]=`xform -q -ws -t ($name+$side)`;
float $tempFloatB[]=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
float $magAB=`mag<<$tempFloatA[0]-$tempFloatB[0],$tempFloatA[1]-$tempFloatB[1],$tempFloatA[2]-$tempFloatB[2]>>`;
setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 1;
float $tempFloatC[]=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
float $magAC=`mag<<$tempFloatA[0]-$tempFloatC[0],$tempFloatA[1]-$tempFloatC[1],$tempFloatA[2]-$tempFloatC[2]>>`;
if ($magAB<$magAC)
	setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 0;

//avoid double Xform
createNode -n ($name+"PlusMinusAverage"+$side) plusMinusAverage;
setAttr ($name+"PlusMinusAverage"+$side+".operation") 2;
connectAttr -f ($name+"PointOnCurveInfo"+$side+".position") ($name+"Attach"+$side+".t");
connectAttr -f Brs.r ($name+"Attach"+$side+".r");
connectAttr -f Brs.s ($name+"Attach"+$side+".s");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[1]");
disconnectAttr ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
parent -w ($name+"Offset"+$side);
connectAttr -f ($name+"PlusMinusAverage"+$side+".output3D") ($name+"Subtract"+$side+".t");
xform -ws -t ($controlPos[0]*$b) $controlPos[1] $controlPos[2] ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);

connectAttr ($name+$side+".tx") ($name+"Joint"+$side+".tx");connectAttr ($name+$side+".ty") ($name+"Joint"+$side+".ty");connectAttr ($name+$side+".tz") ($name+"Joint"+$side+".tz");
connectAttr ($name+$side+".rx") ($name+"Joint"+$side+".rx");connectAttr ($name+$side+".ry") ($name+"Joint"+$side+".ry");connectAttr ($name+$side+".rz") ($name+"Joint"+$side+".rz");
connectAttr ($name+$side+".sx") ($name+"Joint"+$side+".sx");connectAttr ($name+$side+".sy") ($name+"Joint"+$side+".sy");connectAttr ($name+$side+".sz") ($name+"Joint"+$side+".sz");

//asFaceCreateCtrl (string $name, string $side, string $controlLevel)
if (`optionVar -q asRefresh`)
	refresh;
}

global proc string lipLetterClosestToCenterInY (string $upperLower)
{
string $letter;
string $tempString[]=`ls -type joint ($upperLower+"LipMiddle*0_M")`;
string $closestJoint=$tempString[0];
float $minValue=999;
float $centerPos[]=`xform -q -ws -t ($upperLower+"LipCenter0_M")`;
for ($i=0;$i<size($tempString);$i++)
	{
	float $pos[]=`xform -q -ws -t $tempString[$i]`;
	float $absY=abs($centerPos[1]-$pos[1]);
	if ($absY<$minValue)
		{
		$minValue=$absY;
		$closestJoint=$tempString[$i];
		}
	}
$tempString[0]=`substitute ($upperLower+"LipMiddle") $closestJoint ""`;
$letter=`substitute "0_M" $tempString[0] ""`;
return $letter;
}

global proc softCluster (string $trnPos, string $name, int $b, string $side)
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
string $skinCluster=`textField -q -tx asFsSkinClusterTextField`;
//string $jawJoint=`textField -q -tx asFsJawJointTextField`;
string $jawControl=`textField -q -tx asFsJawControlTextField`;
float $falloffRadius=`getAttr ($name+".falloffRadius")`;
float $falloffMode=`getAttr ($name+".falloffMode")`;
string $allFaceGeoString=`textField -q -tx asFsAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

select $allFaceGeo;
float $scale=`asFaceGetScale`;
float $pos[3]=`xform -q -ws -t $trnPos`;
float $tempFloat[];
int $numVtxs[];
int $infNr;
float $value;
float $skinPercents[];
string $skinClusterInfs[];
string $oppositeSide;
select -r $geometry;
string $tempString[]=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ($name+"SoftMod"+$side)`;
string $softModHandle=`rename $tempString[1] ($name+"SoftModHandle"+$side)`;
string $tempString[]=`listConnections ($name+"SoftMod"+$side+".message")`;
string $softModSet=`rename $tempString[0] ($name+"SoftModSet"+$side)`;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $softModHandle;
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;

//asFaceCreateCtrl $name $side "B";
pingPong $name $name $b $side 8;
parent ($name+"Attach"+$side) Acontrols;

if (`getAttr ($name+".overrideColor")`==9)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!=$geometry)
			sets -add $softModSet $allFaceGeo[$i];
	}

setAttr -type float3 ($softModHandle+".t") 1 0 0;
//softMod -e -pr fails in batch, when affecting multiple meshes
//no longer pruning , as this gets tricky when user want to paint outside prune area
//if (`getAttr ($name+".overrideColor")`!=9)
//	softMod -e -pr $softMod;
string $tempString[]=`listConnections ($softMod+".message")`;
select `sets -q $tempString[0]`;
string $vtxs[]=`ls -sl -fl`;
setAttr -type float3 ($softModHandle+".t") 0 0 0;

$tempString=`cluster -n ($name+"Cluster"+$side) -envelope 1`;
string $cluster=$tempString[0];
string $clusterHandle=$tempString[1];
$tempString=`listRelatives -s $clusterHandle`;
string $clusterHandleShape=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].inputGeometry")`;
string $clusterGroupParts=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].groupId")`;
string $clusterGroupId=$tempString[0];
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$tempString[0];
parent $clusterHandle ClusterSetup;
setAttr -type float3 ($clusterHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $clusterHandle;

asFaceSoftModToCluster $softMod $cluster $vtxs;
delete $softMod;

setAttr -l 1 ($clusterHandle+".v") 0;
connectAttr ($name+$side+".t") ($clusterHandle+".t");
connectAttr ($name+$side+".r") ($clusterHandle+".r");
connectAttr ($name+$side+".s") ($clusterHandle+".s");

catch (`reorderDeformers $skinCluster $cluster $geometry`);
}

global proc asFaceSoftModToCluster (string $softMod, string $cluster, string $vtxs[])
{
global string $gMainProgressBar;
string $tempString[]=`listConnections ($softMod+".matrix")`;
string $softModHandle=$tempString[0];
setAttr ($softModHandle+".ty") 1;
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
string $softMod=$tempString[0];

string $deformMeshs[]=`ls -o $vtxs`;
$deformMeshs=`stringArrayRemoveDuplicates $deformMeshs`;
string $deformXforms[];
for ($i=0;$i<size($deformMeshs);$i++)
	{
	$tempString=`listRelatives -p $deformMeshs[$i]`;
	$deformXforms[$i]=$tempString[0];
	}
setAttr ($softMod+".envelope") 0;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshA"+$i) $deformMeshs[$i];
setAttr ($softMod+".envelope") 1;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshB"+$i) $deformMeshs[$i];
float $sofModDefaultPos[3]=`xform -q -os -piv $softModHandle`;
float $posA[3];
float $posB[3];
for ($i=0;$i<size($deformMeshs);$i++)
    {
    string $historyNodes[]=`listHistory $deformMeshs[$i]`;
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	setAttr ($historyNodes[$y]+".nodeState") 1;
    percent -v 0 $cluster ($deformMeshs[$i]+".vtx[0:999999]");
    progressBar -e -st "softModToCluster" -bp -ii 0 -min 0 -max `size($vtxs)` $gMainProgressBar;
    for ($y=0;$y<size($vtxs);$y++)
        {
				progressBar -e -s 1 $gMainProgressBar;
        if (!`gmatch $vtxs[$y] ($deformXforms[$i]+"[.]vtx*")`)
            continue;
        tokenize $vtxs[$y] "." $tempString;
        $posA=`xform -q -ws -t ("tempMeshA"+$i+"."+$tempString[1])`;
        $posB=`xform -q -ws -t ("tempMeshB"+$i+"."+$tempString[1])`;
        percent -v ($posB[1]-$posA[1]) $cluster $vtxs[$y];
        }
    progressBar -e -ep $gMainProgressBar;
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	setAttr ($historyNodes[$y]+".nodeState") 0;
     }
for ($i=0;$i<size($deformMeshs);$i++)
    delete ("tempMeshA"+$i) ("tempMeshB"+$i);
clear $vtxs;
}

/*
global proc asFaceSoftModToCluster (string $softMod, string $cluster, string $vtxs[])
{
global string $gMainProgressBar;
int $dirWeights;
int $doProgressBar;
if (`progressBar -q -st $gMainProgressBar`=="")
	{
	$doProgressBar=1;
	progressBar -e -st "converting" -bp -ii 0 -min 0 -max `size($vtxs)` $gMainProgressBar;
	}
float $mag,$radius,$vecX,$vecY;
float $posA[3],$posB[3],$posSoftMod[3],$posBX[3],$posBY[3],$v0[3];
string $tempString[]=`listConnections ($softMod+".matrix")`;
string $softModHandle=$tempString[0];
int $numLetters=`size $cluster`;
string $fitJoint=`substring $cluster 1 ($numLetters-9)`;
if (`attributeExists radiusUp $fitJoint`)
	$dirWeights=1;
string $deformSet,$direction;
$tempString=`listConnections ($cluster+".message")`;
for ($y=0;$y<size($tempString);$y++)
	if ($tempString[$y]!="FaceAllSet")
		$deformSet=$tempString[$y];
select $vtxs;
catch (`sets -add $deformSet`);

$posSoftMod=`xform -q -ws -piv $softModHandle`;
move -r -ws 1 0 0 $softModHandle;
for ($i=0;$i<size($vtxs);$i++)
	{
	if ($doProgressBar)
		progressBar -e -s 1 $gMainProgressBar;
	setAttr ($softMod+".envelope") 0;
	$posA=`xform -q -ws -t $vtxs[$i]`;
	setAttr ($softMod+".envelope") 1;
	if ($dirWeights)
		{
		$relX=$posA[0]-$posSoftMod[0];
		$relY=$posA[1]-$posSoftMod[1];
		if ($relX>0)
			{
			if ($relY>0)
				{
				if ($relX>$relY)
					$direction="Right";
				else
					$direction="Up";
				}
			else
				{
				if ($relX>(-1*$relY))
					$direction="Right";
				else
					$direction="Down";
				}
			}
		else
			{
			if ($relY>0)
				{
				if ((-1*$relX)>$relY)
					$direction="Left";
				else
					$direction="Up";
				}
			else
				{
				if ((-1*$relX)>(-1*$relY))
					$direction="Right";
				else
					$direction="Down";
				}
			}

		$radius=`getAttr ($fitJoint+".radius"+$direction)`;
		setAttr ($softMod+".falloffRadius") $radius;
		$posB=`xform -q -ws -t $vtxs[$i]`;
		$mag=$posB[0]-$posA[0];
		}
	else
		{
		$posB=`xform -q -ws -t $vtxs[$i]`;
		$mag=$posB[0]-$posA[0];
		}
	percent -v $mag $cluster $vtxs[$i];
	}
move -r -ws -1 0 0 $softModHandle;

//smoothDirweights
if ($dirWeights)
	{
	select -r $vtxs;
	ArtPaintBlendShapeWeightsTool;
	artAttrInitPaintableAttr;
	artSetToolAndSelectAttr( "artAttrCtx", ("cluster."+$cluster+".weights") );
	artAttrPaintOperation artAttrCtx Smooth;
	}

if ($doProgressBar)
	progressBar -e -ep $gMainProgressBar;
}
*/

global proc asFaceAddBlendShape ()
{
select blendShapeEmotions;
addAttr -ln "angry"  -at double -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1;
}

global proc string asFaceMirror ()
{
string $restoreCmd,$oppositeControl;
int $autoKeyState=`autoKeyframe -q -state`;
if ($autoKeyState)
	autoKeyframe -state 0;
string $mirrorAttrs[]={"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
string $controls[]=`sets -q FaceControlSet`;
for ($i=0;$i<size($controls);$i++)
	{
	if (!`gmatch $controls[$i] "*_L"`)
		continue;
	for ($attr in $mirrorAttrs)
		{
		if (`getAttr -l ($controls[$i]+"."+$attr)`)
			continue;
		$oppositeControl=`substitute "_L" $controls[$i] "_R"`;
		$multiply=1;
		if ($attr=="tx" || $attr=="ry" || $attr=="rz")
			$multiply=-1;
	
		$restoreCmd+="setAttr "+$controls[$i]+"."+$attr+" "+`getAttr ($controls[$i]+"."+$attr)`+";";
		setAttr ($controls[$i]+"."+$attr) (`getAttr ($oppositeControl+"."+$attr)`*$multiply);
		}
	}
if ($autoKeyState)
	$restoreCmd+="autoKeyframe -state 1;";
return $restoreCmd;
}

global proc asFaceMirrorAllClusterWeights ()
{
string $sel[]=`ls -sl`;
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a faceControl";
asFaceMirrorClusterWeights $sel[0];
/*
string $controls[]=`sets -q FaceControlSet`;
string $onlyThis="";
string $sel[]=`ls -sl`;
if (size($sel)==1)
	{
	string $cluster=`substitute "_R" $sel[0] "Cluster_R"`;
	if (`objExists $cluster`)
		$onlyThis=$sel[0];
	}

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] "*_R"`)
		{
		if ($onlyThis!="" && $controls[$i]!=$onlyThis)
			continue;
		asFaceMirrorClusterWeights $controls[$i];
		}
*/
}

global proc asFaceMirrorClusterWeights (string $control)
{
string $restorePoseCmd;
string $geometry=`textField -q -tx asFsGeometryTextField`;
int $multiply;
int $numVtxs[]=`polyEvaluate -v $geometry`;
float $maxDist,$mag;
float $posA[3],$posB[3],$tempFloat[];
string $tempString[],$rightVtxs[];
string $cluster=`substitute "_R" $control "Cluster_R"`;
string $oppositeControl=`substitute "_R" $control "_L"`;
string $oppositeCluster=`substitute "_R" $cluster "_L"`;
if (!`gmatch $control "*_R"` || !`objExists $oppositeCluster`)
	return;
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$cluster+"Set";
string $oppositeClusterSet=`substitute "_R" $clusterSet "_L"`;
if (!`objExists $oppositeClusterSet`)
	return;

//Mirror pose before doing left to ensure identical attachment
string $restoreCmd=`asFaceMirror`;

percent -v 0 $oppositeCluster ($geometry+".vtx[0:"+$numVtxs[0]+"]");
select `sets -q ($cluster+"Set")`;
$rightVtxs=`ls -sl -fl`;
$posA=`xform -q -ws -t $control`;
$maxDist=0;
for ($i=0;$i<size($rightVtxs);$i++)
	{
	$posB=`xform -q -ws -t $rightVtxs[$i]`;
	$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
	if ($mag>$maxDist)
		$maxDist=$mag;
	}
$maxDist=$maxDist+($maxDist/20.0);

select $geometry;
sets -add ($oppositeCluster+"Set") $geometry;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $maxDist -dp ($posA[0]*-1) $posA[1] $posA[2];
string $vtxs[]=`ls -sl -fl`;
polySelectConstraint -m 0;
//sets -add ($oppositeCluster+"Set") $vtxs;
createNode -n closestSampler closestPointOnMesh;
string $tempString[]=`listRelatives -ni -s $geometry`;
connectAttr -f ($tempString[0]+".outMesh") closestSampler.inMesh;
connectAttr -f ($geometry+".xformMatrix") closestSampler.inputMatrix;
int $closestOppositeVtxNr;
global string $gMainProgressBar;
progressBar -e -st ("Mirroring Cluster for: "+$control) -bp -ii 1 -min 0 -max `size($vtxs)` $gMainProgressBar;
for ($i=0;$i<size($vtxs);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		break;
	progressBar -e -s 1 $gMainProgressBar;
	$posB=`xform -q -ws -t $vtxs[$i]`;
	setAttr -type float3 closestSampler.inPosition ($posB[0]*-1) $posB[1] $posB[2];
	$closestOppositeVtxNr=`getAttr closestSampler.result.closestVertexIndex`;
	$tempFloat=`percent -q -v $cluster ($geometry+".vtx["+$closestOppositeVtxNr+"]")`;

	if (!`sets -im $clusterSet ($geometry+".vtx["+$closestOppositeVtxNr+"]")`)
		$tempFloat[0]=0;

	percent -v $tempFloat[0] $oppositeCluster $vtxs[$i];
	}
progressBar -e -ep $gMainProgressBar;
setAttr -type float3 ($oppositeControl+".t") 1 1 1;
cluster -e -pr $oppositeCluster;
setAttr -type float3 ($oppositeControl+".t") 0 0 0;
delete closestSampler;

eval ($restoreCmd);
}

/*
global proc asFaceSdk (int $set, string $driver, string $driverAttr, float $driverValue)
{
float $value;
string $drivenAttrs[];
string $exludedDrivenMatchString;
if ($driver=="eyeBrow_R")
	{
	$exludedDrivenMatchString="*mouth*";
	$drivenAttrs={"tx","ty","tz","rx","ry","rz"};
	}
string $allDrivenControls[]=`listConnections faceCtrlDriven.drawInfo`;
string $drivenControls[];
for ($i=0;$i<size($allDrivenControls);$i++)
	{
	if (`gmatch $allDrivenControls[$i] $exludedDrivenMatchString` || `gmatch $allDrivenControls[$i] "*_L"`)
		;
	else
		$drivenControls[size($drivenControls)]=$allDrivenControls[$i];
	}

//confirm if driver value is not 1 or -1
string $dialog;
float $currentDriverValue=`getAttr ($driver+"."+$driverAttr)`;
if (!$set)
	setAttr ($driver+"."+$driverAttr) 0 ;
if ($set)
	if ($currentDriverValue!=1 && $currentDriverValue!=-1)
		$dialog=`confirmDialog -t "Confirm"
	-m ($driver+"."+$driverAttr+" is "+$currentDriverValue+",\nwhich can cause undesired effects.\n"
		+"Unless you are intentionally setting advanced inbetween setDrivenKeyframes.")
	-b "Continue" -db "Continue"
	-b "Cancel" -ds "Cancel"`;

if ($dialog=="Cancel")
	return;

//visibility
for ($i=0;$i<size($allDrivenControls);$i++)
	{
	setAttr ($allDrivenControls[$i]+".v") 1;
	if (`gmatch $allDrivenControls[$i] $exludedDrivenMatchString` || `gmatch $allDrivenControls[$i] "*_L"`)
		if (!$set)
			setAttr ($allDrivenControls[$i]+".v") 0;
	}

for ($i=0;$i<size($drivenControls);$i++)
	for ($y=0;$y<size($drivenAttrs);$y++)
		{
		if ($set)
			{
			$value=`getAttr ($drivenControls[$i]+"."+$drivenAttrs[$y])`;
			}
		else
			{
			$value=0;
			if (`gmatch $drivenAttrs[$y] "s*"`)
				$value=1;
			}
		setDrivenKeyframe -currentDriver ($driver+"."+$driverAttr) -value $value ($drivenControls[$i]+"."+$drivenAttrs[$y]);
		}

if ($set)
	setAttr ($driver+"."+$driverAttr) 0;
else
	setAttr ($driver+"."+$driverAttr) $driverValue;

setAttr faceCtrlA.v $set;
setAttr faceCtrlB.v $set;
setAttr faceCtrlDriven.v (!$set);
if ($set)
	select $driver;
}
*/

global proc int [] asFaceSelVtxIntArray ()
{
int $intArray[];
string $tempString[];
string $sel[]=`ls -sl -fl`;
for ($i=0;$i<size($sel);$i++)
	{
	tokenize $sel[$i] "[" $tempString;
	$intArray[$i]=`substitute "]" $tempString[1] ""`;
    	}
return $intArray;
}

global proc asCreateFaceFitJointsFromEdgeLoop (string $region, float $size, int $color)
{
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$tempString3[];
string $startVtx,$vtxNr,$joint;
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] "*[.]e[[]*"`)
		if (`gmatch $sel[$i] "*[.]vtx[[]*"`)
			$startVtx=$sel[$i];
		else
			error "Select edgeLoop";

$tempString=`ls -sl -o`;
string $object=$tempString[0];
ConvertSelectionToVertices;
int $loopVtxsNrs[]=`asFaceSelVtxIntArray`;
float $tyz;
float $tyzMax=-999;
float $pos[3],$connectedVtxPos[3];
float $xs[],$ys[],$zs[];
float $centerErrorMargin=0.001;
int $startVtxNr;
int $startNr=0;
if (`gmatch $region "Eye*"`)
	$startNr=1;
for ($i=0;$i<size($loopVtxsNrs);$i++)
	{
	$pos=`xform -q -ws -t ($object+".vtx["+$loopVtxsNrs[$i]+"]")`;
	$xs[$i]=$pos[0];$ys[$i]=$pos[1];$zs[$i]=$pos[2];
	}

//determin $startVtxNr
if ($startVtx!="")
	{
	if (`gmatch $startVtx "*[[]*:*[]]*"`)
		error "More than 1 `start-vertex` selected"; 
	tokenize $startVtx "[" $tempString;
	$startVtxNr=`substitute "]" $tempString[1] ""`;
	}
else
	{
	createNode -n tempTransform transform;
	if (`gmatch $region "*Lip*"`)
		setAttr "tempTransform.rotateZ" -45;
	if (`gmatch $region "*Eye*"`)
		setAttr "tempTransform.rotateZ" -90;
	for ($i=0;$i<size($loopVtxsNrs);$i++)
		{
		if ($xs[$i]>$centerErrorMargin)
			continue;
		createNode -n ("tempTransform"+$loopVtxsNrs[$i]) transform;
		xform -ws -t $xs[$i] $ys[$i] $zs[$i] ("tempTransform"+$loopVtxsNrs[$i]);
		parent ("tempTransform"+$loopVtxsNrs[$i]) tempTransform;
		$tyz=`getAttr ("tempTransform"+$loopVtxsNrs[$i]+".ty")`;
		if ($tyz>$tyzMax)
			{
			$startVtxNr=$loopVtxsNrs[$i];
			$tyzMax=$tyz;
			}
		}
	delete tempTransform;
	//reConsider $startVtxNr if finding neighbour startNr (so overlapping lips do not run in reverse)
    if (`gmatch $region "*Middle"` || `gmatch $region "*Inner"`)
        for ($i=0;$i<size($loopVtxsNrs);$i++)
        	{
        	select ($object+".vtx["+$loopVtxsNrs[$i]+"]");
        	ConvertSelectionToEdges;
        	ConvertSelectionToVertices;
        	$tempString=`ls -sl -fl`;
        	for ($y=0;$y<size($tempString);$y++)
        	    {
            	tokenize $tempString[$y] "[" $tempString2;
            	$vtxNr=`substitute "]" $tempString2[1] ""`;
            	$pos=`xform -q -ws -t ($object+".vtx["+$vtxNr+"]")`;
            	if (`objExists FaceFitSkeleton`)
	            	$tempString3=`listRelatives -c -type joint FaceFitSkeleton`;
            	for ($z=0;$z<size($tempString3);$z++)
            	    {
            	    if (!`gmatch $tempString3[$z] ("upper*"+$startNr)`)
            	        continue;
            	    if (`gmatch $tempString3[$z] ("upper*[0-9]"+$startNr)`) //make sure to catch 0, not 10,20,etc
            	    	continue;
									$pos2=`xform -q -ws -t $tempString3[$z]`;
									if ($pos2[0]==$pos[0] && $pos2[1]==$pos[1] && $pos2[2]==$pos[2])
										$startVtxNr=$loopVtxsNrs[$i];
            	    }
                }	
        	}
	}
select ($object+".vtx["+$startVtxNr+"]");

int $sortedVtxs[];
int $connectedVtxNr,$foundConnectedVtxInLoop,$previousVtxNr;
int $loopCompleted=0;
int $currentVtxNr=$startVtxNr;
int $previousVtxNr=-1;
int $nr=0;
int $maxNr;
int $innerExtra;
for ($i=0;$i<99;$i++)
	{
	$sortedVtxs[size($sortedVtxs)]=$currentVtxNr;
	
	select ($object+".vtx["+$currentVtxNr+"]");
	$pos=`xform -q -ws -t ($object+".vtx["+$currentVtxNr+"]")`;
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	$connectedVtxNrs=`asFaceSelVtxIntArray`;
	//avoid starting downwards for Eye
	if ($i==0 && `gmatch $region "*Eye*"`)
		$connectedVtxNrs=`asFaceFigureOutFirstEyeConnectVtx $connectedVtxNrs $loopVtxsNrs $currentVtxNr $object`;
	for ($y=0;$y<size($connectedVtxNrs);$y++)
		{
		$foundConnectedVtxInLoop=0;
		$connectedVtxPos=`xform -q -ws -t ($object+".vtx["+$connectedVtxNrs[$y]+"]")`;
		if ($connectedVtxPos[0]>$centerErrorMargin)
			if ($i==0)
				continue;
			else
				{
				$foundConnectedVtxInLoop=1;
				$i=99;
				$y=99;
				break;
				}
		//do not start out going `down` for Eye
//		if ($i==0 && `gmatch $region "*Eye*"` && $connectedVtxPos[1]<$pos[1])
//			continue;
		for ($z=0;$z<size($loopVtxsNrs);$z++)
			{
			if ($connectedVtxNrs[$y]==$loopVtxsNrs[$z] && $connectedVtxNrs[$y]!=$currentVtxNr && $connectedVtxNrs[$y]!=$previousVtxNr)
				{
				$foundConnectedVtxInLoop=1;
		            	$previousVtxNr=$currentVtxNr;
				$currentVtxNr=$connectedVtxNrs[$y];
				$y=99;
				break;
				}
			}
		}
	if (!$foundConnectedVtxInLoop)
		error ("Failed to find loopVtx connected to "+$currentVtxNr);
	//loop completed
	if ($i>0 && $currentVtxNr==$startVtxNr)
		break;
	}

string $middlePrefix;
int $letterNr;
if (`gmatch $region "*Middle"`)
	{
	$middlePrefix=`textField -q -tx ("asFS"+$region+"PrefixTextField")`;
	if (!`gmatch $middlePrefix "[A-Z]"`)
		error ("Middle prefix must be capital letter between A-Z, currently set to:\""+$middlePrefix+"\"");
	$letterNr=`asFaceLetterToNr $middlePrefix`;
	textField -e -tx (`asFaceNrToLetter ($letterNr+1)`) ("asFS"+$region+"PrefixTextField");
	}

string $curveName,$targetCurveName;
string $upperLower="upper";
for ($i=0;$i<size($sortedVtxs);$i++)
	{
	select ($object+".vtx["+$sortedVtxs[$i]+"]");
	
	if ($upperLower=="upper" && $i>(`size($sortedVtxs)`-1)/2)
		{
		$upperLower="lower";
		$nr=size($sortedVtxs)-$i-1;
		}
	$joint=$upperLower+$region+$middlePrefix+($nr+$startNr);
	if ($upperLower=="upper")
		$nr++;
	else
		$nr--;
	//Allow for additional Inner EyeLids
	if ($region=="EyeInner" && `objExists $joint`)
		{$joint=`substitute "Inner" $joint "InnerExtraA"`;$innerExtra=1;}
	if ($region=="EyeInner" && `objExists $joint` && $innerExtra==1)
		{$joint=`substitute "InnerExtraA" $joint "InnerExtraB"`;$innerExtra=2;}
	if ($region=="EyeInner" && `objExists $joint` && $innerExtra==2)
		{$joint=`substitute "InnerExtraB" $joint "InnerExtraC"`;$innerExtra=3;}
	if (`objExists $joint`)
		error ("Joint: "+$joint+" already exists");
	asCreateFaceFitJoint $joint $size ($color+$letterNr);
	//Create Targets
/*
	if ($region=="EyeInner" && $innerExtra==0)
		{
		spaceLocator -n ($joint+"Target");
		parent ($joint+"Target") $joint;
		setAttr -type float3 ($joint+"Target.t") 0 0 0;
		setAttr -type float3 ($joint+"TargetShape.localScale") 0 0 0;
		parent ($joint+"Target") FitFaceTargets;
		}
*/

	if (!`gmatch $region "Eye*"`)
		continue;

	//mark start
	if ($i==0 || $i==(`size($sortedVtxs)`-1)/2)
		{
		setAttr ($joint+".drawLabel") 1;
		setAttr ($joint+".type") 18;
		setAttr -type "string" ($joint+".otherType") $nr;
		setAttr ($joint+".overrideColor") 22;
		$maxNr=$nr;
		}
	}

//temporary lip falloff method
if ($region=="LipOuter")
	for ($y=99;$y>0;$y--)
		if (`objExists ("upperLipOuter"+$y)`)
			{
			setAttr ("upperLipOuter"+$y+".falloffRadius") 0.5;
			break;
			}

string $extra="";
if ($innerExtra==1) $extra="ExtraA";
if ($innerExtra==2) $extra="ExtraB";
if ($innerExtra==3) $extra="ExtraC";

if (`checkBox -q -ex ("asFace"+$region+$extra+$middlePrefix)`)
	checkBox -e -v 1 -ed 1 ("asFace"+$region+$extra+$middlePrefix);


select $sel;
}

global proc int[] asFaceFigureOutFirstEyeConnectVtx (int $connectedVtxNrs[], int $loopVtxsNrs[], int $currentVtxNr, string $object)
{
int $resolvedVtxs[];
int $twoCandidateVtxNrs[];
for ($i=0;$i<size($connectedVtxNrs);$i++)
	if ($connectedVtxNrs[$i]!=$currentVtxNr)
		if (`asIntArrayCount $connectedVtxNrs[$i] $loopVtxsNrs`)
			$twoCandidateVtxNrs[size($twoCandidateVtxNrs)]=$connectedVtxNrs[$i];
float $pos1[]=`xform -q -ws -t ($object+".vtx["+$twoCandidateVtxNrs[0]+"]")`;
float $pos2[]=`xform -q -ws -t ($object+".vtx["+$twoCandidateVtxNrs[1]+"]")`;
if ($pos1[1]>$pos2[1])
	$resolvedVtxs[0]=$twoCandidateVtxNrs[0];
else
	$resolvedVtxs[0]=$twoCandidateVtxNrs[1];
return $resolvedVtxs;
}

global proc int asIntArrayCount(int $item, int $list[])
{
	int $result = 0;

	int $listItem;
	for ($listItem in $list)
	{
		if ($item == $listItem)
			$result++;
	}
	
	return $result;
}

global proc asFaceHelpImage (string $region)
{
string $asScriptLocation=`asScriptLocation`;
if (`window -q -ex faceHelpImage`)
	deleteUI faceHelpImage;
window faceHelpImage;
columnLayout;
image -i ($asScriptLocation+"/Images/faceHelp/"+$region+".jpg") asFaceHelpImage;
if (`gmatch $region "asBSWizardStep*"`)
	button -l "Toggle Default" -c asFaceTglDefault;
showWindow;
}

global proc asFaceTglDefault ()
{
string $asScriptLocation=`asScriptLocation`;
string $curImage=`image -q -i asFaceHelpImage`;
string $ann=`image -q -ann asFaceHelpImage`;
if (!`gmatch $curImage "*asBSWizardStep*[0-9][.]*"`)
	return;
if ($ann=="")
	{
	image -e -ann $curImage asFaceHelpImage;
	image -e -i ($asScriptLocation+"/Images/faceHelp/asBSWizardStep0.jpg") asFaceHelpImage;
	}
else
	{
	image -e -ann "" asFaceHelpImage;
	image -e -i $ann asFaceHelpImage;
	}
}


//-------------------------------   ShapeSolve   -------------------------------//




global proc asFaceSurfacer ()
{
global string $gMainProgressBar;
string $requiredJoints[]={"browOuter","browInner","foreheadOuter","foreheadMiddle","noseMiddle","noseOuter","cheekInner","cheekOuter","jaw","chinMiddle","noseLower","noseTip","noseCorner","chin","smile"};
for ($i=0;$i<size($requiredJoints);$i++)
	if (!`objExists $requiredJoints[$i]`)
		{
		print ($requiredJoints[$i]+" Not found, skipping FaceSurfacer");
		return;
		}
string $geometry=`textField -q -tx asFsGeometryTextField`;
if (!`objExists $geometry`)
	error ("Face Geometry:\""+$geometry+"\" Not found");
if (`objExists PcageGroup`)
	delete PcageGroup cageFace cageHead cageFaceOriginal cageLambert cageLambertSG;

string $asScriptLocation=`asScriptLocation`;
file -import -type "mayaAscii" -rpr "cage" -options "v=0"  -pr -loadReferenceDepth "all" ($asScriptLocation+"asCage.ma");
if (`objExists cage_sceneConfigurationScriptNode`)
	delete cage_sceneConfigurationScriptNode;
if (`objExists cage_uiConfigurationScriptNode`)
	delete cage_uiConfigurationScriptNode;
float $scale=`asFaceGetScale`;

//reassign shader for existing influences
string $influences[]=`ls -type transform "faceCageInfluence*"`;
for ($i=0;$i<size($influences);$i++)
	sets -e -forceElement cageLambertSG $influences;

createNode -n cageGroup transform;
createNode -n cageLevelAGroup transform;
createNode -n cageLevelBGroup transform;
createNode -n cageLevelCGroup transform;
createNode -n cageOnMesh transform;
parent cageLevelAGroup cageGroup;
parent cageLevelBGroup cageGroup;
parent cageLevelCGroup cageGroup;
parent cageOnMesh cageGroup;
parent GcageGroup cageGroup;
parent PcageGroup FaceFitSkeleton;

//PcageGroup.s
float $faceSizeFactor=`getAttr foreheadMiddle.ty`-`getAttr chinMiddle.ty`;
float $pcageScale=$faceSizeFactor/6.514;
parent -w upperGlips lowerGlips;
setAttr -type float3 PcageGroup.s $pcageScale $pcageScale $pcageScale;

//ForeHead
asVertSnapToPoint foreheadOuter "" cageForeHead 20 0;
asVertSnapToPoint foreheadMiddle "" cageForeHead 24 0;
asVertSnapToPoint foreheadOuter foreheadMiddle cageForeHead 21 0.6;
asVertSnapToPoint foreheadOuter foreheadMiddle cageForeHead 22 0.35;
asVertSnapToPoint foreheadOuter foreheadMiddle cageForeHead 23 0.15;

asVertSnapToPoint browOuter "" cageForeHead 0 0;
asVertSnapToPoint foreheadOuter browOuter cageForeHead 15 0.6;
asVertSnapToPoint foreheadOuter browOuter cageForeHead 10 0.35;
asVertSnapToPoint foreheadOuter browOuter cageForeHead 5 0.15;

asVertSnapToPoint browInner "" cageForeHead 2 0;
asVertSnapToPoint browOuter browInner cageForeHead 1 0.5;

asVertSnapToPoint noseOuter "" cageForeHead 25 0;
asVertSnapToPoint noseOuter browInner cageForeHead 3 0.333;
asVertSnapToPoint noseOuter browInner cageForeHead 4 0.666;

asVertSnapToPoint noseMiddle "" cageForeHead 27 0;
asVertSnapToPoint noseMiddle noseOuter cageForeHead 26 0.5;

asVertSnapToPoint foreheadMiddle noseMiddle cageForeHead 19 0.6;
asVertSnapToPoint foreheadMiddle noseMiddle cageForeHead 14 0.2;

asAverageInbetweenVerts "cageForeHead";
setAttr cageForeHeadClusterHandle.tz ($scale*1.5);

//cageNose
asVertSnapToPoint noseMiddle "" cageNose 25 0;
asVertSnapToPoint noseOuter "" cageNose 23 0;
asVertSnapToPoint cheekInner "" cageNose 21 0;
asVertSnapToPoint noseTip "" cageNose 10 0;
asVertSnapToPoint noseLower "" cageNose 4 0;
asVertSnapToPoint noseCorner "" cageNose 1 0;

asVertSnapToPoint noseMiddle noseOuter cageNose 24 0.5;
asVertSnapToPoint noseOuter cheekInner cageNose 22 0.5;
asVertSnapToPoint cheekInner noseCorner cageNose 16 0.66;
asVertSnapToPoint cheekInner noseCorner cageNose 11 0.33;
asVertSnapToPoint noseMiddle noseTip cageNose 20 0.66;
asVertSnapToPoint noseMiddle noseTip cageNose 15 0.33;
asVertSnapToPoint noseTip noseLower cageNose 7 0.5;
asVertSnapToPoint noseLower noseCorner cageNose 3 0.66;
asVertSnapToPoint noseLower noseCorner cageNose 2 0.33;

asAverageInbetweenVerts "cageNose";
setAttr cageNoseClusterHandle.tz ($scale*1);
setAttr cageNoseClusterHandle.tx ($scale*-0.2);

//cageCheek
asVertSnapToPoint cheekOuter "" cageCheek 32 0;
asVertSnapToPoint cheekInner "" cageCheek 27 0;
asVertSnapToPoint jaw "" cageCheek 4 0;
asVertSnapToPoint noseCorner "" cageCheek 34 0;
asVertSnapToPoint chin "" cageCheek 0 0;
asVertSnapToPoint smile "" cageCheek 10 0;

asVertSnapToPoint cheekOuter jaw cageCheek 26 0.8;
asVertSnapToPoint cheekOuter jaw cageCheek 20 0.6;
asVertSnapToPoint cheekOuter jaw cageCheek 14 0.4;
asVertSnapToPoint cheekOuter jaw cageCheek 9 0.2;
asVertSnapToPoint cheekOuter cheekInner cageCheek 31 0.8;
asVertSnapToPoint cheekOuter cheekInner cageCheek 30 0.6;
asVertSnapToPoint cheekOuter cheekInner cageCheek 29 0.4;
asVertSnapToPoint cheekOuter cheekInner cageCheek 28 0.2;
asVertSnapToPoint cheekInner noseCorner cageCheek 21 0.66;
asVertSnapToPoint cheekInner noseCorner cageCheek 15 0.33;
asVertSnapToPoint noseCorner smile cageCheek 33 0.66;
asVertSnapToPoint noseCorner smile cageCheek 35 0.33;
asVertSnapToPoint smile chin cageCheek 5 0.5;
asVertSnapToPoint jaw chin cageCheek 3 0.75;
asVertSnapToPoint jaw chin cageCheek 2 0.5;
asVertSnapToPoint jaw chin cageCheek 1 0.25;

asAverageInbetweenVerts "cageCheek";
setAttr cageCheekClusterHandle.tz ($scale*1);
setAttr cageCheekClusterHandle.tx ($scale*-1);

//cageMouth
asVertSnapToPoint noseLower "" cageMouth 23 0;
asVertSnapToPoint smile "" cageMouth 18 0;
asVertSnapToPoint chin "" cageMouth 16 0;
asVertSnapToPoint chinMiddle "" cageMouth 12 0;
//not sure about nosecorner
//asVertSnapToPoint noseCorner "" cageMouth 20 0;
asVertSnapToPoint chin smile cageMouth 17 0.5;
asVertSnapToPoint smile noseCorner cageMouth 19 0.66;
asVertSnapToPoint smile noseCorner cageMouth 20 0.33;
asVertSnapToPoint noseCorner noseLower cageMouth 21 0.66;
asVertSnapToPoint noseCorner noseLower cageMouth 22 0.33;
asVertSnapToPoint chin chinMiddle cageMouth 15 0.75;
asVertSnapToPoint chin chinMiddle cageMouth 14 0.5;
asVertSnapToPoint chin chinMiddle cageMouth 13 0.25;

string $lipInOuts[]=`asFaceCreateLipCurves`;
createNode -n lipOuter0 transform;
connectAttr -f ("lipCurveOuterPointOnCurveInfo.position") lipOuter0.t;

setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 0;
asVertSnapToPoint lipOuter0 "" cageMouth 35 0;

rename lipOuter0 lipOuter1;
setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 0.12;
asVertSnapToPoint lipOuter1 "" cageMouth 34 0;

rename lipOuter1 lipOuter2;
setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 0.25;
asVertSnapToPoint lipOuter2 "" cageMouth 33 0;

rename lipOuter2 lipOuter3;
setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 0.33;
asVertSnapToPoint lipOuter3 "" cageMouth 32 0;

rename lipOuter3 lipOuter4;
setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 0.43;
asVertSnapToPoint lipOuter4 "" cageMouth 31 0;

rename lipOuter4 lipOuter5;
setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 0.51;
asVertSnapToPoint lipOuter5 "" cageMouth 30 0;

rename lipOuter5 lipOuter6;
setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 0.59;
asVertSnapToPoint lipOuter6 "" cageMouth 29 0;

rename lipOuter6 lipOuter7;
setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 0.65;
asVertSnapToPoint lipOuter7 "" cageMouth 28 0;

rename lipOuter7 lipOuter8;
setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 0.72;
asVertSnapToPoint lipOuter8 "" cageMouth 27 0;

rename lipOuter8 lipOuter9;
setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 0.8;
asVertSnapToPoint lipOuter9 "" cageMouth 26 0;

rename lipOuter9 lipOuter10;
setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 0.89;
asVertSnapToPoint lipOuter10 "" cageMouth 25 0;

rename lipOuter10 lipOuter11;
setAttr ("lipCurveOuterPointOnCurveInfo.parameter") 1;
asVertSnapToPoint lipOuter11 "" cageMouth 24 0;

float $ty;
float $tyMax=9999;
int $MaxNr;
for ($i=0;$i<size($lipInOuts);$i++)
    {
    $ty=`getAttr ("upperLip"+$lipInOuts[$i]+"0.ty")`;
    if ($ty<$tyMax)
        {
        $tyMax=$ty;
        $MaxNr=$i;
        }
    }

rename lipOuter11 lipInner0;
connectAttr -f ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.position") lipInner0.t;

setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 0;
asVertSnapToPoint lipInner0 "" cageMouth 59 0;

rename lipInner0 lipInner1;
setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 0.195;
asVertSnapToPoint lipInner1 "" cageMouth 58 0;

rename lipInner1 lipInner2;
setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 0.295;
asVertSnapToPoint lipInner2 "" cageMouth 57 0;

rename lipInner2 lipInner3;
setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 0.385;
asVertSnapToPoint lipInner3 "" cageMouth 56 0;

rename lipInner3 lipInner4;
setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 0.445;
asVertSnapToPoint lipInner4 "" cageMouth 55 0;

rename lipInner4 lipInner5;
setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 0.5;
asVertSnapToPoint lipInner5 "" cageMouth 54 0;

rename lipInner5 lipInner6;
setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 0.53;
asVertSnapToPoint lipInner6 "" cageMouth 53 0;

rename lipInner6 lipInner7;
setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 0.58;
asVertSnapToPoint lipInner7 "" cageMouth 52 0;

rename lipInner7 lipInner8;
setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 0.635;
asVertSnapToPoint lipInner8 "" cageMouth 51 0;

rename lipInner8 lipInner9;
setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 0.725;
asVertSnapToPoint lipInner9 "" cageMouth 50 0;

rename lipInner9 lipInner10;
setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 0.82;
asVertSnapToPoint lipInner10 "" cageMouth 49 0;

rename lipInner10 lipInner11;
setAttr ("lipCurve"+$lipInOuts[$MaxNr]+"PointOnCurveInfo.parameter") 1;
asVertSnapToPoint lipInner11 "" cageMouth 48 0;

int $midNr=($MaxNr+1)/2;

rename lipInner11 lipMiddle0;
if (!`isConnected ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.position") lipMiddle0.t`)
	connectAttr -f ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.position") lipMiddle0.t;

setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 0;
asVertSnapToPoint lipMiddle0 "" cageMouth 47 0;

rename lipMiddle0 lipMiddle1;
setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 0.17;
asVertSnapToPoint lipMiddle1 "" cageMouth 46 0;

rename lipMiddle1 lipMiddle2;
setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 0.29;
asVertSnapToPoint lipMiddle2 "" cageMouth 45 0;

rename lipMiddle2 lipMiddle3;
setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 0.36;
asVertSnapToPoint lipMiddle3 "" cageMouth 44 0;

rename lipMiddle3 lipMiddle4;
setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 0.435;
asVertSnapToPoint lipMiddle4 "" cageMouth 43 0;

rename lipMiddle4 lipMiddle5;
setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 0.5;
asVertSnapToPoint lipMiddle5 "" cageMouth 42 0;

rename lipMiddle5 lipMiddle6;
setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 0.545;
asVertSnapToPoint lipMiddle6 "" cageMouth 41 0;

rename lipMiddle6 lipMiddle7;
setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 0.625;
asVertSnapToPoint lipMiddle7 "" cageMouth 40 0;

rename lipMiddle7 lipMiddle8;
setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 0.685;
asVertSnapToPoint lipMiddle8 "" cageMouth 39 0;

rename lipMiddle8 lipMiddle9;
setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 0.763;
asVertSnapToPoint lipMiddle9 "" cageMouth 38 0;

rename lipMiddle9 lipMiddle10;
setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 0.852;
asVertSnapToPoint lipMiddle10 "" cageMouth 37 0;

rename lipMiddle10 lipMiddle11;
setAttr ("lipCurve"+$lipInOuts[$midNr]+"PointOnCurveInfo.parameter") 1;
asVertSnapToPoint lipMiddle11 "" cageMouth 36 0;

asVertSnapToPoint noseLower lipOuter0 cageMouth 11 0.5;
asVertSnapToPoint chinMiddle lipOuter11 cageMouth 0 0.5;
asAverageInbetweenVerts "cageMouth";

delete lipMiddle11;
delete `ls "lipCurve*"`;

string $cageBits[]={"cageForeHead","cageNose","cageCheek","cageMouth"};
for ($i=0;$i<size($cageBits);$i++)
    {
    select -r $cageBits[$i] ("P"+$cageBits[$i]);
    blendShape -n ($cageBits[$i]+"BS1") -frontOfChain;
    setAttr ($cageBits[$i]+"BS1.origin") 0;
    setAttr ($cageBits[$i]+"BS1."+$cageBits[$i]) 1;
    }

setAttr "GcageGroup.visibility" 0;

//pop locs out to surface
string $bLocs[]=`listRelatives -c cageLevelBGroup`;
string $onMeshLoc;
string $midLocs[]={"cageForeHeadPartial_19","cageForeHeadPartial_14","cageNosePartial_20","cageNosePartial_15","cageNosePartial_7","cageMouthPartial_11","cageMouthPartial_0","cageMouthPartial_47","cageMouthPartial_36"};
for ($i=0;$i<size($bLocs);$i++)
  {
  $onMeshLoc=`substitute "Partial" $bLocs[$i] ""`+"OnMesh";
  $pos=`xform -q -ws -t $onMeshLoc`;
  if (`stringArrayCount $bLocs[$i] $midLocs`)
    $pos[0]=0.0;
  xform -ws -t $pos[0] $pos[1] $pos[2] $bLocs[$i];
  }
delete cageGroup;

//combine
duplicate -n PcageGroupCombine -rc PcageGroup;
select -r `listRelatives -c PcageGroupCombine`;
select -d PcageHead1;
polyUnite -n cageFace -ch 0 -mergeUVSets 1;
delete PcageGroupCombine;
polyMergeVertex  -d ($scale/20) -am 1 -ch 0 cageFace.vtx[25:27] cageFace.vtx[29:32] cageFace.vtx[39] cageFace.vtx[44] cageFace.vtx[49] cageFace.vtx[51:54] cageFace.vtx[59] cageFace.vtx[64] cageFace.vtx[69] cageFace.vtx[75] cageFace.vtx[81] cageFace.vtx[87:89] cageFace.vtx[106:113];
parent cageFace FaceFitSkeleton;
duplicate -n cageFaceOriginal cageFace;
setAttr PcageGroup.v 0;
setAttr cageFaceOriginal.v 0;
int $tempInts[]=`polyEvaluate -v cageFace`;
int $numVtx=$tempInts[0];
float $vtxPos[],$closestPos[];

//fatFace
duplicate -n fatFace $geometry;
$tempInts=`polyEvaluate -v fatFace`;
int $numVtxFatFace=$tempInts[0];
string $moveCmd="moveVertexAlongDirection";
progressBar -e -st ("Calculating") -bp -ii 0 -min 0 -max $numVtxFatFace $gMainProgressBar;
for ($i=0;$i<$numVtxFatFace;$i++)
	{
	$moveCmd+=" -n "+$scale/10.0;
	progressBar -e -s 1 $gMainProgressBar;
	}
select -r fatFace.vtx[0:99999];
eval($moveCmd);

createNode -n asFacePointOnMesh closestPointOnMesh;
connectAttr -f fatFace.worldMesh[0] asFacePointOnMesh.inMesh;

for ($i=0;$i<$numVtx;$i++)
	{
  $vtxPos=`xform -q -ws -t ("cageFace.vtx["+$i+"]")`;
  setAttr -type float3 asFacePointOnMesh.inPosition $vtxPos[0] $vtxPos[1] $vtxPos[2];
  $closestPos=`getAttr asFacePointOnMesh.result.position`;
  xform -ws -t $closestPos[0] $closestPos[1] $closestPos[2] ("cageFace.vtx["+$i+"]");
	}
delete fatFace asFacePointOnMesh;

//prep PcageHead as well, but not diplay yet
setAttr PcageHead.v 1;
float $objCenterPos[]=`objectCenter -gl PcageHead`;
setAttr PcageHead.v 0;
float $cheekPos[]=`xform -q -ws -t cheekOuter`;
float $pt5Pos[]=`xform -q -ws -t PcageHead.vtx[5]`;
float $scaled=`getAttr PcageGroup.scaleX`;
float $invScaled=1.0/$scaled;
xform -r -t 0 (($cheekPos[1]-$objCenterPos[1])*$invScaled) 0 PcageHead.vtx[0:36];
xform -r -s (($cheekPos[0]/$pt5Pos[0])+0.1) 1 1 PcageHead.vtx[0:36];
duplicate -n cageHead PcageHead;
parent cageHead FaceFitSkeleton;

//lips
string $frontMost0Lip;
float $zMost=0;
float $temp[];
//delete cageFace.f[82:103];
string $upperLower;
for ($b=0;$b<2;$b++)
	{
	if ($b==0) $upperLower="upper";
	if ($b==1) $upperLower="lower";

	for ($i=1;$i<99;$i++)
			if (!`objExists ($upperLower+"LipOuter"+$i)`)
				break;
	int $numLip=$i-1;
	for ($y=1;$y<99;$y++)
			{
			$joint="upperLipMiddle"+`asFaceNrToLetter $y`+"0";
			if (!`objExists $joint`) break;
			}
	int $numLipMiddleRows=$y+1;
	string $lip0s[]=`ls -type transform ($upperLower+"LipMiddle*0")`;
	for ($i=1;$i<size($lip0s);$i++)
		{
		$temp=`xform -q -ws -t $lip0s[$i]`;
		if ($temp[2]>$zMost)
			{
			$frontMost0Lip=$lip0s[$i];
			$zMost=$temp[2];
			}
		}
	if ($frontMost0Lip=="")
		$frontMost0Lip=($upperLower+"LipOuter0");
	select ($upperLower+"Glips");
	float $posA[]=`xform -q -ws -t ($upperLower+"LipOuter0")`;
	float $posB[]=`xform -q -ws -t $frontMost0Lip`;
	float $lattSize[]=`getAttr ($upperLower+"Glips.s")`;
	float $outherPos[]=`xform -q -ws -t ($upperLower+"LipOuter"+$numLip)`;
	float $scFac=(-$outherPos[0]/$lattSize[0])*2;
	scale -r $scFac $scFac $scFac ($upperLower+"Glips");
	setAttr ($upperLower+"Glips.v") 1;
	float $bb[]=`xform -q -bb ($upperLower+"Glips")`;
	setAttr ($upperLower+"Glips.v") 0;
	$yFactor=2.0;
	if ($upperLower=="lower")
		$yFactor=-2.0;
	setAttr -type float3 ($upperLower+"Glips.t") 0 ($posA[1]-($bb[4]-$bb[1])/$yFactor) ($posB[2]-($bb[5]-$bb[2])/2.0);

	//LipSamplerSurface
	nurbsPlane -n ($upperLower+"LipSamplerSurface") -p -0.5 0 0 -ax 0 1 0 -w 1 -lr 1 -d 3 -u ($numLip-2) -v ($numLipMiddleRows-4) -ch 0;
	for ($i=0;$i<$numLip+1;$i++)
		for ($y=0;$y<$numLipMiddleRows-1;$y++)
			{
			string $joint=$upperLower+"LipMiddle"+`asFaceNrToLetter $y`+$i;
			if ($y==0)
			    $joint=$upperLower+"LipOuter"+$i;
			float $pos[]=`xform -q -ws -t $joint`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LipSamplerSurface.cv["+$i+"]["+$y+"]"); 
			}
	}
parent upperGlips lowerGlips PcageGroup;
/*
asFacePlaceOnSurf upperLipSamplerSurface (0/9.0) 0 upperGlips.vtx[2];
asFacePlaceOnSurf upperLipSamplerSurface (1/9.0) 0 upperGlips.vtx[10];
asFacePlaceOnSurf upperLipSamplerSurface (2/9.0) 0 upperGlips.vtx[9];
asFacePlaceOnSurf upperLipSamplerSurface (3/9.0) 0 upperGlips.vtx[63];
asFacePlaceOnSurf upperLipSamplerSurface (4/9.0) 0 upperGlips.vtx[12];
asFacePlaceOnSurf upperLipSamplerSurface (5/9.0) 0 upperGlips.vtx[15];
asFacePlaceOnSurf upperLipSamplerSurface (6/9.0) 0 upperGlips.vtx[53];
asFacePlaceOnSurf upperLipSamplerSurface (7/9.0) 0 upperGlips.vtx[54];
asFacePlaceOnSurf upperLipSamplerSurface (8/9.0) 0 upperGlips.vtx[55];
asFacePlaceOnSurf upperLipSamplerSurface (9/9.0) 0 upperGlips.vtx[56];

asFacePlaceOnSurf upperLipSamplerSurface (0/9.0) (1/5.0) upperGlips.vtx[3];
asFacePlaceOnSurf upperLipSamplerSurface (1/9.0) (1/5.0) upperGlips.vtx[22];
asFacePlaceOnSurf upperLipSamplerSurface (2/9.0) (1/5.0) upperGlips.vtx[23];
asFacePlaceOnSurf upperLipSamplerSurface (3/9.0) (1/5.0) upperGlips.vtx[62];
asFacePlaceOnSurf upperLipSamplerSurface (4/9.0) (1/5.0) upperGlips.vtx[25];
asFacePlaceOnSurf upperLipSamplerSurface (5/9.0) (1/5.0) upperGlips.vtx[26];
asFacePlaceOnSurf upperLipSamplerSurface (6/9.0) (1/5.0) upperGlips.vtx[18];
asFacePlaceOnSurf upperLipSamplerSurface (7/9.0) (1/5.0) upperGlips.vtx[19];
asFacePlaceOnSurf upperLipSamplerSurface (8/9.0) (1/5.0) upperGlips.vtx[29];
asFacePlaceOnSurf upperLipSamplerSurface (9/9.0) (1/5.0) upperGlips.vtx[30];

asFacePlaceOnSurf upperLipSamplerSurface (0/9.0) (2/5.0) upperGlips.vtx[4];
asFacePlaceOnSurf upperLipSamplerSurface (1/9.0) (2/5.0) upperGlips.vtx[21];
asFacePlaceOnSurf upperLipSamplerSurface (2/9.0) (2/5.0) upperGlips.vtx[20];
asFacePlaceOnSurf upperLipSamplerSurface (3/9.0) (2/5.0) upperGlips.vtx[64];
asFacePlaceOnSurf upperLipSamplerSurface (4/9.0) (2/5.0) upperGlips.vtx[24];
asFacePlaceOnSurf upperLipSamplerSurface (5/9.0) (2/5.0) upperGlips.vtx[27];
asFacePlaceOnSurf upperLipSamplerSurface (6/9.0) (2/5.0) upperGlips.vtx[17];
asFacePlaceOnSurf upperLipSamplerSurface (7/9.0) (2/5.0) upperGlips.vtx[16];
asFacePlaceOnSurf upperLipSamplerSurface (8/9.0) (2/5.0) upperGlips.vtx[28];
asFacePlaceOnSurf upperLipSamplerSurface (9/9.0) (2/5.0) upperGlips.vtx[31];

asFacePlaceOnSurf upperLipSamplerSurface (0/9.0) (3/5.0) upperGlips.vtx[5];
asFacePlaceOnSurf upperLipSamplerSurface (1/9.0) (3/5.0) upperGlips.vtx[43];
asFacePlaceOnSurf upperLipSamplerSurface (2/9.0) (3/5.0) upperGlips.vtx[44];
asFacePlaceOnSurf upperLipSamplerSurface (3/9.0) (3/5.0) upperGlips.vtx[65];
asFacePlaceOnSurf upperLipSamplerSurface (4/9.0) (3/5.0) upperGlips.vtx[50];
asFacePlaceOnSurf upperLipSamplerSurface (5/9.0) (3/5.0) upperGlips.vtx[47];
asFacePlaceOnSurf upperLipSamplerSurface (6/9.0) (3/5.0) upperGlips.vtx[42];
asFacePlaceOnSurf upperLipSamplerSurface (7/9.0) (3/5.0) upperGlips.vtx[41];
asFacePlaceOnSurf upperLipSamplerSurface (8/9.0) (3/5.0) upperGlips.vtx[52];
asFacePlaceOnSurf upperLipSamplerSurface (9/9.0) (3/5.0) upperGlips.vtx[51];

asFacePlaceOnSurf upperLipSamplerSurface (0/9.0) (4/5.0) upperGlips.vtx[6];
asFacePlaceOnSurf upperLipSamplerSurface (1/9.0) (4/5.0) upperGlips.vtx[46];
asFacePlaceOnSurf upperLipSamplerSurface (2/9.0) (4/5.0) upperGlips.vtx[45];
asFacePlaceOnSurf upperLipSamplerSurface (3/9.0) (4/5.0) upperGlips.vtx[71];
asFacePlaceOnSurf upperLipSamplerSurface (4/9.0) (4/5.0) upperGlips.vtx[49];
asFacePlaceOnSurf upperLipSamplerSurface (5/9.0) (4/5.0) upperGlips.vtx[48];
asFacePlaceOnSurf upperLipSamplerSurface (6/9.0) (4/5.0) upperGlips.vtx[67];
asFacePlaceOnSurf upperLipSamplerSurface (7/9.0) (4/5.0) upperGlips.vtx[74];
asFacePlaceOnSurf upperLipSamplerSurface (8/9.0) (4/5.0) upperGlips.vtx[75];
asFacePlaceOnSurf upperLipSamplerSurface (9/9.0) (4/5.0) upperGlips.vtx[78];

asFacePlaceOnSurf upperLipSamplerSurface (0/9.0) (5/5.0) upperGlips.vtx[7];
asFacePlaceOnSurf upperLipSamplerSurface (1/9.0) (5/5.0) upperGlips.vtx[69];
asFacePlaceOnSurf upperLipSamplerSurface (2/9.0) (5/5.0) upperGlips.vtx[70];
asFacePlaceOnSurf upperLipSamplerSurface (3/9.0) (5/5.0) upperGlips.vtx[72];
asFacePlaceOnSurf upperLipSamplerSurface (4/9.0) (5/5.0) upperGlips.vtx[81];
asFacePlaceOnSurf upperLipSamplerSurface (5/9.0) (5/5.0) upperGlips.vtx[66];
asFacePlaceOnSurf upperLipSamplerSurface (6/9.0) (5/5.0) upperGlips.vtx[68];
asFacePlaceOnSurf upperLipSamplerSurface (7/9.0) (5/5.0) upperGlips.vtx[73];
asFacePlaceOnSurf upperLipSamplerSurface (8/9.0) (5/5.0) upperGlips.vtx[76];
asFacePlaceOnSurf upperLipSamplerSurface (9/9.0) (5/5.0) upperGlips.vtx[77];

delete upperGlips.f[39];

asFacePlaceOnSurf upperLipSamplerSurface (0/9.0) (-0.25/5.0) upperGlips.vtx[0];
asFacePlaceOnSurf upperLipSamplerSurface (1/9.0) (-0.25/5.0) upperGlips.vtx[11];
asFacePlaceOnSurf upperLipSamplerSurface (2/9.0) (-0.25/5.0) upperGlips.vtx[8];
asFacePlaceOnSurf upperLipSamplerSurface (3/9.0) (-0.25/5.0) upperGlips.vtx[61];
asFacePlaceOnSurf upperLipSamplerSurface (4/9.0) (-0.25/5.0) upperGlips.vtx[13];
asFacePlaceOnSurf upperLipSamplerSurface (5/9.0) (-0.25/5.0) upperGlips.vtx[14];
asFacePlaceOnSurf upperLipSamplerSurface (6/9.0) (-0.25/5.0) upperGlips.vtx[37];
asFacePlaceOnSurf upperLipSamplerSurface (7/9.0) (-0.25/5.0) upperGlips.vtx[38];
asFacePlaceOnSurf upperLipSamplerSurface (8/9.0) (-0.25/5.0) upperGlips.vtx[39];
asFacePlaceOnSurf upperLipSamplerSurface (9/9.0) (-0.25/5.0) upperGlips.vtx[40];

asFacePlaceOnSurf upperLipSamplerSurface (0/9.0) (-0.5/5.0) upperGlips.vtx[1];
asFacePlaceOnSurf upperLipSamplerSurface (1/9.0) (-0.5/5.0) upperGlips.vtx[58];
asFacePlaceOnSurf upperLipSamplerSurface (2/9.0) (-0.5/5.0) upperGlips.vtx[57];
asFacePlaceOnSurf upperLipSamplerSurface (3/9.0) (-0.5/5.0) upperGlips.vtx[60];
asFacePlaceOnSurf upperLipSamplerSurface (4/9.0) (-0.5/5.0) upperGlips.vtx[59];
asFacePlaceOnSurf upperLipSamplerSurface (5/9.0) (-0.5/5.0) upperGlips.vtx[36];
asFacePlaceOnSurf upperLipSamplerSurface (6/9.0) (-0.5/5.0) upperGlips.vtx[33];
asFacePlaceOnSurf upperLipSamplerSurface (7/9.0) (-0.5/5.0) upperGlips.vtx[32];
asFacePlaceOnSurf upperLipSamplerSurface (8/9.0) (-0.5/5.0) upperGlips.vtx[34];
asFacePlaceOnSurf upperLipSamplerSurface (9/9.0) (-0.5/5.0) upperGlips.vtx[35];

asFacePlaceOnSurf lowerLipSamplerSurface (0/9.0) 0 lowerGlips.vtx[4];
asFacePlaceOnSurf lowerLipSamplerSurface (1/9.0) 0 lowerGlips.vtx[64];
asFacePlaceOnSurf lowerLipSamplerSurface (2/9.0) 0 lowerGlips.vtx[55];
asFacePlaceOnSurf lowerLipSamplerSurface (3/9.0) 0 lowerGlips.vtx[54];
asFacePlaceOnSurf lowerLipSamplerSurface (4/9.0) 0 lowerGlips.vtx[47];
asFacePlaceOnSurf lowerLipSamplerSurface (5/9.0) 0 lowerGlips.vtx[46];
asFacePlaceOnSurf lowerLipSamplerSurface (6/9.0) 0 lowerGlips.vtx[45];
asFacePlaceOnSurf lowerLipSamplerSurface (7/9.0) 0 lowerGlips.vtx[44];
asFacePlaceOnSurf lowerLipSamplerSurface (8/9.0) 0 lowerGlips.vtx[43];
asFacePlaceOnSurf lowerLipSamplerSurface (9/9.0) 0 lowerGlips.vtx[42];

asFacePlaceOnSurf lowerLipSamplerSurface (0/9.0) (1/5.0) lowerGlips.vtx[3];
asFacePlaceOnSurf lowerLipSamplerSurface (1/9.0) (1/5.0) lowerGlips.vtx[62];
asFacePlaceOnSurf lowerLipSamplerSurface (2/9.0) (1/5.0) lowerGlips.vtx[52];
asFacePlaceOnSurf lowerLipSamplerSurface (3/9.0) (1/5.0) lowerGlips.vtx[23];
asFacePlaceOnSurf lowerLipSamplerSurface (4/9.0) (1/5.0) lowerGlips.vtx[22];
asFacePlaceOnSurf lowerLipSamplerSurface (5/9.0) (1/5.0) lowerGlips.vtx[19];
asFacePlaceOnSurf lowerLipSamplerSurface (6/9.0) (1/5.0) lowerGlips.vtx[18];
asFacePlaceOnSurf lowerLipSamplerSurface (7/9.0) (1/5.0) lowerGlips.vtx[15];
asFacePlaceOnSurf lowerLipSamplerSurface (8/9.0) (1/5.0) lowerGlips.vtx[12];
asFacePlaceOnSurf lowerLipSamplerSurface (9/9.0) (1/5.0) lowerGlips.vtx[10];

asFacePlaceOnSurf lowerLipSamplerSurface (0/9.0) (2/5.0) lowerGlips.vtx[2];
asFacePlaceOnSurf lowerLipSamplerSurface (1/9.0) (2/5.0) lowerGlips.vtx[63];
asFacePlaceOnSurf lowerLipSamplerSurface (2/9.0) (2/5.0) lowerGlips.vtx[53];
asFacePlaceOnSurf lowerLipSamplerSurface (3/9.0) (2/5.0) lowerGlips.vtx[20];
asFacePlaceOnSurf lowerLipSamplerSurface (4/9.0) (2/5.0) lowerGlips.vtx[21];
asFacePlaceOnSurf lowerLipSamplerSurface (5/9.0) (2/5.0) lowerGlips.vtx[16];
asFacePlaceOnSurf lowerLipSamplerSurface (6/9.0) (2/5.0) lowerGlips.vtx[17];
asFacePlaceOnSurf lowerLipSamplerSurface (7/9.0) (2/5.0) lowerGlips.vtx[14];
asFacePlaceOnSurf lowerLipSamplerSurface (8/9.0) (2/5.0) lowerGlips.vtx[13];
asFacePlaceOnSurf lowerLipSamplerSurface (9/9.0) (2/5.0) lowerGlips.vtx[11];

asFacePlaceOnSurf lowerLipSamplerSurface (0/9.0) (3/5.0) lowerGlips.vtx[1];
asFacePlaceOnSurf lowerLipSamplerSurface (1/9.0) (3/5.0) lowerGlips.vtx[60];
asFacePlaceOnSurf lowerLipSamplerSurface (2/9.0) (3/5.0) lowerGlips.vtx[49];
asFacePlaceOnSurf lowerLipSamplerSurface (3/9.0) (3/5.0) lowerGlips.vtx[48];
asFacePlaceOnSurf lowerLipSamplerSurface (4/9.0) (3/5.0) lowerGlips.vtx[40];
asFacePlaceOnSurf lowerLipSamplerSurface (5/9.0) (3/5.0) lowerGlips.vtx[41];
asFacePlaceOnSurf lowerLipSamplerSurface (6/9.0) (3/5.0) lowerGlips.vtx[39];
asFacePlaceOnSurf lowerLipSamplerSurface (7/9.0) (3/5.0) lowerGlips.vtx[38];
asFacePlaceOnSurf lowerLipSamplerSurface (8/9.0) (3/5.0) lowerGlips.vtx[37];
asFacePlaceOnSurf lowerLipSamplerSurface (9/9.0) (3/5.0) lowerGlips.vtx[36];

asFacePlaceOnSurf lowerLipSamplerSurface (0/9.0) (4/5.0) lowerGlips.vtx[0];
asFacePlaceOnSurf lowerLipSamplerSurface (1/9.0) (4/5.0) lowerGlips.vtx[61];
asFacePlaceOnSurf lowerLipSamplerSurface (2/9.0) (4/5.0) lowerGlips.vtx[50];
asFacePlaceOnSurf lowerLipSamplerSurface (3/9.0) (4/5.0) lowerGlips.vtx[51];
asFacePlaceOnSurf lowerLipSamplerSurface (4/9.0) (4/5.0) lowerGlips.vtx[78];
asFacePlaceOnSurf lowerLipSamplerSurface (5/9.0) (4/5.0) lowerGlips.vtx[75];
asFacePlaceOnSurf lowerLipSamplerSurface (6/9.0) (4/5.0) lowerGlips.vtx[74];
asFacePlaceOnSurf lowerLipSamplerSurface (7/9.0) (4/5.0) lowerGlips.vtx[70];
asFacePlaceOnSurf lowerLipSamplerSurface (8/9.0) (4/5.0) lowerGlips.vtx[68];
asFacePlaceOnSurf lowerLipSamplerSurface (9/9.0) (4/5.0) lowerGlips.vtx[67];

asFacePlaceOnSurf lowerLipSamplerSurface (0/9.0) (5/5.0) lowerGlips.vtx[7];
asFacePlaceOnSurf lowerLipSamplerSurface (1/9.0) (5/5.0) lowerGlips.vtx[79];
asFacePlaceOnSurf lowerLipSamplerSurface (2/9.0) (5/5.0) lowerGlips.vtx[80];
asFacePlaceOnSurf lowerLipSamplerSurface (3/9.0) (5/5.0) lowerGlips.vtx[76];
asFacePlaceOnSurf lowerLipSamplerSurface (4/9.0) (5/5.0) lowerGlips.vtx[77];
asFacePlaceOnSurf lowerLipSamplerSurface (5/9.0) (5/5.0) lowerGlips.vtx[72];
asFacePlaceOnSurf lowerLipSamplerSurface (6/9.0) (5/5.0) lowerGlips.vtx[73];
asFacePlaceOnSurf lowerLipSamplerSurface (7/9.0) (5/5.0) lowerGlips.vtx[71];
asFacePlaceOnSurf lowerLipSamplerSurface (8/9.0) (5/5.0) lowerGlips.vtx[69];

delete lowerGlips.f[0];

asFacePlaceOnSurf lowerLipSamplerSurface (0/9.0) (-0.25/5.0) lowerGlips.vtx[5];
asFacePlaceOnSurf lowerLipSamplerSurface (1/9.0) (-0.25/5.0) lowerGlips.vtx[63];
asFacePlaceOnSurf lowerLipSamplerSurface (2/9.0) (-0.25/5.0) lowerGlips.vtx[55];
asFacePlaceOnSurf lowerLipSamplerSurface (3/9.0) (-0.25/5.0) lowerGlips.vtx[54];
asFacePlaceOnSurf lowerLipSamplerSurface (4/9.0) (-0.25/5.0) lowerGlips.vtx[32];
asFacePlaceOnSurf lowerLipSamplerSurface (5/9.0) (-0.25/5.0) lowerGlips.vtx[33];
asFacePlaceOnSurf lowerLipSamplerSurface (6/9.0) (-0.25/5.0) lowerGlips.vtx[31];
asFacePlaceOnSurf lowerLipSamplerSurface (7/9.0) (-0.25/5.0) lowerGlips.vtx[30];
asFacePlaceOnSurf lowerLipSamplerSurface (8/9.0) (-0.25/5.0) lowerGlips.vtx[29];
asFacePlaceOnSurf lowerLipSamplerSurface (9/9.0) (-0.25/5.0) lowerGlips.vtx[28];

asFacePlaceOnSurf lowerLipSamplerSurface (0/9.0) (-0.5/5.0) lowerGlips.vtx[6];
asFacePlaceOnSurf lowerLipSamplerSurface (1/9.0) (-0.5/5.0) lowerGlips.vtx[64];
asFacePlaceOnSurf lowerLipSamplerSurface (2/9.0) (-0.5/5.0) lowerGlips.vtx[56];
asFacePlaceOnSurf lowerLipSamplerSurface (3/9.0) (-0.5/5.0) lowerGlips.vtx[57];
asFacePlaceOnSurf lowerLipSamplerSurface (4/9.0) (-0.5/5.0) lowerGlips.vtx[26];
asFacePlaceOnSurf lowerLipSamplerSurface (5/9.0) (-0.5/5.0) lowerGlips.vtx[27];
asFacePlaceOnSurf lowerLipSamplerSurface (6/9.0) (-0.5/5.0) lowerGlips.vtx[25];
asFacePlaceOnSurf lowerLipSamplerSurface (7/9.0) (-0.5/5.0) lowerGlips.vtx[24];
asFacePlaceOnSurf lowerLipSamplerSurface (8/9.0) (-0.5/5.0) lowerGlips.vtx[22];
asFacePlaceOnSurf lowerLipSamplerSurface (9/9.0) (-0.5/5.0) lowerGlips.vtx[23];
*/
delete upperLipSamplerSurface lowerLipSamplerSurface;

select cageFace;
progressBar -e -ep $gMainProgressBar;
}

global proc asFacePlaceOnSurf (string $surf,float $u,float $v,string $trn)
{
float $sampleU=abs($u);
float $sampleV=abs($v);
float $pos[]=`pointOnSurface -u $sampleU -v $sampleV -position $surf`;
if($v<0)
{
    float $pos2[]=`pointOnSurface -u $sampleU -v 0 -position $surf`;
    $pos[0]=$pos2[0]+($pos2[0]-$pos[0]);
    $pos[1]=$pos2[1]+($pos2[1]-$pos[1]);
    $pos[2]=$pos2[2]+($pos2[2]-$pos[2]);
}

eval ("select "+$trn);
xform -ws -t $pos[0] $pos[1] $pos[2];
}

global proc asFaceProcessor ()
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $skinCluster=`textField -q -tx asFsSkinClusterTextField`;
string $jawControl=`textField -q -tx asFsJawControlTextField`;
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
float $scale=`asFaceGetScale`;
string $tempString[],$allLipVtx[];
string $wrap,$wrapSet;
float $pos[];
int $tempInts[];
int $numVtx;

//Pop all center vtxs to real tx=0
select -r cageFace.vtx[14] cageFace.vtx[19] cageFace.vtx[24] cageFace.vtx[27] cageFace.vtx[32] cageFace.vtx[35] cageFace.vtx[38] cageFace.vtx[43] cageFace.vtx[48] cageFace.vtx[83] cageFace.vtx[94:95] cageFace.vtx[99] cageFace.vtx[110:111] cageFace.vtx[122:123] cageFace.vtx[134];
string $ctrVtxs[]=`ls -sl -fl`;
for ($i=0;$i<size($ctrVtxs);$i++)
	{
	$pos=`xform -q -ws -t $ctrVtxs[$i]`;
	xform -ws -t 0 $pos[1] $pos[2] $ctrVtxs[$i];
	}

createNode -n cageTempGroup transform;
createNode -n PcageGroup_R transform;
parent PcageGroup_R cageTempGroup;

//display PcageHead if not already visable
setAttr PcageHead.v 1;

//warp to tweaked cages
parent upperGlips lowerGlips FaceFitSkeleton;
select -r cageFaceOriginal cageFace;
blendShape -n warpTempBS;
setAttr warpTempBS.cageFaceOriginal 1;
duplicate -n PcageGroupTemp -rc PcageGroup;
delete PcageHead1;
/*
deformer -type wrap PcageGroupTemp;
select -r PcageGroupTemp cageFace;
AddWrapInfluence;
*/
select -r PcageGroupTemp cageFace;
CreateWrap;
setAttr warpTempBS.cageFaceOriginal 0;
parent upperGlips lowerGlips PcageGroup;
duplicate -n PcageHead1 cageHead;
parent PcageHead1 PcageGroupTemp;
$tempString=`listRelatives -type transform -c PcageGroup`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`objExists ($tempString[$i]+"1")`)
		continue;
	$tempInts=`polyEvaluate -v $tempString[$i]`;
	$numVtx=$tempInts[0];
	for ($y=0;$y<$numVtx;$y++)
		{
		$pos=`xform -q -ws -t ($tempString[$i]+"1.vtx["+$y+"]")`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($tempString[$i]+".vtx["+$y+"]");
		}
	}
delete PcageGroupTemp warpTempBS;

//Dup influences into PcageGroup
string $influences[]=`ls -type transform "faceCageInfluence*"`;
for ($i=0;$i<size($influences);$i++)
	{
	$tempString=`duplicate -n ($influences[$i]+"_Copy") $influences[$i]`;
	parent $tempString[0] PcageGroup;
	}

//update shape of `original`
$tempInts=`polyEvaluate -v cageFaceOriginal`;
int $numVtx=$tempInts[0];
for ($i=0;$i< $numVtx;$i++)
	{
	$vtxPos=`xform -q -ws -t ("cageFace.vtx["+$i+"]")`;
	xform -ws -t $vtxPos[0] $vtxPos[1] $vtxPos[2] ("cageFaceOriginal.vtx["+$i+"]");
	}

//Duplicate to make buildcage
$tempString=`listRelatives -type transform -c PcageGroup`;
for ($i=0;$i<size($tempString);$i++)
    {
    duplicate -n ($tempString[$i]+"_R") $tempString[$i];
    parent ($tempString[$i]+"_R") PcageGroup_R;
		if ($tempString[$i]=="PcageHead")
			continue;
		select -r $tempString[$i] ($tempString[$i]+"_R");
		blendShape -n ($tempString[$i]+"BlendShape");
		setAttr ($tempString[$i]+"BlendShape."+$tempString[$i]) 1;
    }



//mouthSplit
duplicate -rr -n PcageMouthSplit_R PcageMouth_R;
setAttr PcageMouthSplit_R.v 0;
/*
deformer -type wrap PcageMouthSplit_R;
select -r PcageMouthSplit_R PcageMouth_R;
AddWrapInfluence;
*/
select -r PcageMouthSplit_R PcageMouth_R;
CreateWrap;
select PcageMouthSplit_R.f[0:5] PcageMouthSplit_R.f[11:16] PcageMouthSplit_R.f[22:27] PcageMouthSplit_R.f[33:38];
polyChipOff -ch 1 -kft 1 -dup 0 -off 0;
$tempString=`polySeparate -rs 1 -ch 1 PcageMouthSplit_RShape`;
rename $tempString[1] PcageMouthUpper_R;
rename $tempString[0] PcageMouthLower_R;

//Mirror and wrap seam
string $mergMshs[]={"PcageForeHead","PcageNose","PcageMouth","PcageHead"};
$tempString=`duplicate -n PcageGroup_L -rc PcageGroup_R`;
for ($i=1;$i<size($tempString);$i++)
    rename $tempString[$i] `substitute "_R1" $tempString[$i] "_L"`;
scale -r -1 1 1 PcageGroup_L;

//disable seam wwap
for ($i=0;$i<size($mergMshs);$i++)
	{
	select -r ($mergMshs[$i]+"_L") ($mergMshs[$i]+"_R");
	CreateWrap;
	$tempString=`listRelatives -ni -s ($mergMshs[$i]+"_L")`;
	$tempString=`listConnections ($tempString[0]+".inMesh")`;
	$wrap=$tempString[0];
	
	setAttr ($wrap+".autoWeightThreshold") 0;
	setAttr ($wrap+".exclusiveBind") 0;
	setAttr ($wrap+".maxDistance") 0.001;
	
	//remove vtx`s not x==0 from set
	$tempString=`listConnections ($wrap+".message")`;
	$wrapSet=$tempString[0];
	select -r ($mergMshs[$i]+"_L.vtx[0:999]");
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$pos=`xform -q -ws -t $tempString[$y]`;
		if (abs($pos[0])<$scale/20.0)
			select -d $tempString[$y];
		}
	sets -remove $wrapSet `ls -sl`;
	}

/*
deformer -type wrap $geometry;
select -r $geometry PcageForeHead_R;
AddWrapInfluence;
*/
float $faceSizeFactor=`getAttr foreheadMiddle.ty`-`getAttr chinMiddle.ty`;
select -r $geometry PcageForeHead_R;
CreateWrap;
$tempString=`listRelatives -ni -s $geometry`;
$tempString=`listConnections ($geometry+".inMesh")`;
$wrap=$tempString[0];
setAttr ($wrap+".autoWeightThreshold") 0;
setAttr ($wrap+".exclusiveBind") 0;
setAttr ($wrap+".maxDistance") ($faceSizeFactor/3.0);

asFaceJawNeckBlendCage;

$tempString=`listRelatives -c PcageGroup_R PcageGroup_L`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`getAttr ($tempString[$i]+".v")`==0)
		continue;
	select -r $wrap $tempString[$i];
	AddWrapInfluence;
	}

//lip
string $upperLower;
string $side;
for ($a=0;$a<2;$a++)
	{
	if ($a==0)	$side="_R";
	if ($a==1)	$side="_L";

  duplicate -rr -n ("upperLipWip"+$side) $geometry;
  parent ("upperLipWip"+$side) cageTempGroup;
  setAttr ("upperLipWip"+$side+".v") 0;
  duplicate -rr -n ("lowerLipWip"+$side) ("upperLipWip"+$side);
  duplicate -rr -n ("lipWip"+$side) ("upperLipWip"+$side);
/*
  deformer -type wrap ("upperLipWip"+$side);
  select -r ("upperLipWip"+$side) ("PcageMouthUpper"+$side);
  AddWrapInfluence;
*/
  select -r ("upperLipWip"+$side) ("upperGlips"+$side);
	CreateWrap;
/*
  deformer -type wrap ("lowerLipWip"+$side);
  select -r ("lowerLipWip"+$side) ("PcageMouthLower"+$side);
  AddWrapInfluence;
*/
  select -r ("lowerLipWip"+$side) ("lowerGlips"+$side);
	CreateWrap;

  clear $allLipVtx;
  for ($b=0;$b<2;$b++)
  	{
  	if ($b==0) $upperLower="upper";
  	if ($b==1) $upperLower="lower";
  	select -r ($upperLower+"LipWip"+$side) ("lipWip"+$side);
  	$tempString=`blendShape -frontOfChain`;
  	rename $tempString[0] ($upperLower+"LipWipBlendShape"+$side);
  	$tempString=`listConnections ($upperLower+"LipWipBlendShape"+$side+".message")`;
  	rename $tempString[0] ($upperLower+"LipWipBlendShapeSet"+$side);
  	setAttr ($upperLower+"LipWipBlendShape"+$side+"."+$upperLower+"LipWip"+$side) 1;
  
  	select `ls -type joint ($upperLower+"Lip*")`;
  	select -d `ls -type joint "*LipCenter*_*"`;
  	asFaceSelectVtxFromJointWithMirrored ("lipWip"+$side);
  	$tempString=`ls -sl`;
  	select ("lipWip"+$side+".vtx[0:99999]");
  	select -d $tempString;
  	sets -remove ($upperLower+"LipWipBlendShapeSet"+$side) `ls -sl`;
  	appendStringArray $allLipVtx $tempString `size($tempString)`;
  	}
  select $allLipVtx;
  //deselect right side
  $tempString=`ls -sl -fl`;
  for ($i=0;$i<size($tempString);$i++)
  	{
  	$pos=`xform -q -ws -t $tempString[$i]`;
  	if ($a==0 && $pos[0]>0.01)
  		select -d $tempString[$i];
  	if ($a==1 && $pos[0]<-0.01)
  		select -d $tempString[$i];
  	}
  
  ConvertSelectionToContainedFaces;
  $tempString=`ls -sl`;
  select ("lipWip"+$side+".f[0:99999]");
  select -d $tempString;
  delete;
  }

	
select -r $wrap lipWip_L;AddWrapInfluence;
select -r $wrap lipWip_R;AddWrapInfluence;

//asFaceLimitWrapByBB;

setAttr "PcageGroup_L.visibility" 0;
setAttr "PcageGroup_R.visibility" 0;

//jawSpesificInfl`s
string $influences[]=`ls -type transform "faceCageInfluenceJaw*_Copy_*"`;
if (size($influences))
	{
	createNode -n tempJawAimAt transform;
	$pos=`xform -q -ws -t PcageMouth_R.vtx[0]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] tempJawAimAt;
	setDrivenKeyframe -itt spline -ott spline -currentDriver cageBlendShape.jaw_open_C tempJawAimAt.ty;
	setDrivenKeyframe -itt spline -ott spline -currentDriver cageBlendShape.jaw_open_C tempJawAimAt.tz;
	setAttr cageBlendShape.jaw_open_C 1;
	$pos=`xform -q -ws -t PcageMouth_R.vtx[0]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] tempJawAimAt;
	setDrivenKeyframe -itt spline -ott spline -currentDriver cageBlendShape.jaw_open_C tempJawAimAt.ty;
	setDrivenKeyframe -itt spline -ott spline -currentDriver cageBlendShape.jaw_open_C tempJawAimAt.tz;
	setAttr cageBlendShape.jaw_open_C 0;
	}
for ($i=0;$i<size($influences);$i++)
	{
	if (!`getAttr ($influences[$i]+".v")`)
		continue;
	$pos=`xform -q -ws -t $jawControl`;
	xform -ws -piv $pos[0] $pos[1] $pos[2] $influences[$i];
	aimConstraint -mo -worldUpType objectrotation -worldUpObject $headJoint tempJawAimAt $influences[$i];
	}

asFaceBakeShapes;
//Make shapes
asFaceSquintByLattice;
asFaceMakeShapes;

if (`objExists asFaceBS`)
	delete asFaceBS;
if (`objExists tempJawAimAt`)
	delete tempJawAimAt;
select `listRelatives -c faceTargets`;
select -add $geometry;
$tempString=`blendShape -frontOfChain`;
rename $tempString asFaceBS;

//remove teeth & tongue from BS
$tempString=`listConnections asFaceBS.message`;
string $bsSet=$tempString[0];
$tempString=`listConnections lipLidBS.message`;
string $lipLidbsSet=$tempString[0];
string $upperTeeth=`textField -q -tx asFsUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFsLowerTeethTextField`;
string $tongue=`textField -q -tx asFsTongueTextField`;
string $nonBs[]={"UpperTeeth","LowerTeeth","Tongue"};
for ($i=0;$i<size($nonBs);$i++)
	{
	string $obj=`textField -q -tx ("asFs"+$nonBs[$i]+"TextField")`;
	if (`gmatch $obj ("*"+$geometry+"[.]vtx*")`)
		{
		eval("select "+$obj);
		sets -rm $bsSet;
		sets -rm $lipLidbsSet;
		}
	}

delete cageTempGroup;
if (`objExists keepTweakedBlendShapes`)
	delete keepTweakedBlendShapes;
string $faceCageInfluencesCopies[]=`ls "faceCageInfluence*_Copy*"`;
if (size($faceCageInfluencesCopies))
	delete $faceCageInfluencesCopies;

reorderDeformers $skinCluster asFaceBS $geometry;
}

global proc asFaceMakeShapes ()
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $jawControl=`textField -q -tx asFsJawControlTextField`;
float $faceSizeFactor=`getAttr foreheadMiddle.ty`-`getAttr chinMiddle.ty`;
float $scale=`asFaceGetScale`;

string $shapes[]={"mouth_wide_C","jaw_open_C","mouth_smile_R","mouth_smile_L"};
for ($i=0;$i<size($shapes);$i++)
	{
	delete $shapes[$i];
	if ($shapes[$i]=="mouth_wide_C")
		{
		move -r ($scale*-0.3) ($scale*0.1) ($scale*-0.3) Lip_R;
		move -r ($scale*0.3) ($scale*0.1) ($scale*-0.3) Lip_L;
		scale -r 0.7 0.7 0.7 Lip_R Lip_L upperLip_M lowerLip_M;
		}
	if ($shapes[$i]=="mouth_smile_R")
		{
		move -r ($scale*-0.3) ($scale*0.4) ($scale*-0.3) Lip_R;
		move -r 0 ($scale*0.1) 0 lowerLip_M;
		scale -r 0.7 0.7 0.7 Lip_R;
		scale -r 0.85 0.85 0.85 upperLip_M lowerLip_M;
		}
	if ($shapes[$i]=="mouth_smile_L")
		{
		move -r ($scale*0.3) ($scale*0.4) ($scale*-0.3) Lip_L;
		move -r 0 ($scale*0.1) 0 lowerLip_M;
		scale -r 0.7 0.7 0.7 Lip_L;
		scale -r 0.85 0.85 0.85 upperLip_M lowerLip_M;
		}
	if ($shapes[$i]=="jaw_open_C")
		scale -r 0.8 0.8 0.8 Lip_R Lip_L upperLip_M lowerLip_M;

	duplicate -n $shapes[$i] $geometry;

	if ($shapes[$i]=="mouth_wide_C" || $shapes[$i]=="jaw_open_C" || $shapes[$i]=="mouth_smile_L" || $shapes[$i]=="mouth_smile_R")
		xform -os -t 0 0 0 -s 1 1 1 Lip_R Lip_L upperLip_M lowerLip_M;
	parent $shapes[$i] faceTargets;
	}
}

global proc asFaceSquintByLattice ()
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
$eyeJoint=`textField -q -tx ("asFsEyeJoint_RTextField")`;

for ($i=1;$i<99;$i++)
		if (!`objExists ("lowerEyeOuter"+$i)`)
			break;
int $numEye=$i-1;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	
	delete ("eye_shut"+$side);
	duplicate -n ("eye_shut"+$side) $geometry;
	parent ("eye_shut"+$side) faceTargets;
	select ("eye_shut"+$side);
	string $tempString[]=`lattice  -divisions 15 5 3 -objectCentered true  -ldv 2 2 2`;
	string $ffd=$tempString[0];
	string $lattice=$tempString[1];
	string $latticeBase=$tempString[2];
	float $pos[]=`xform -q -ws -t $eyeJoint`;
	float $cheekPos[]=`xform -q -ws -t cheekOuter`;
	float $pos2[]=`xform -q -ws -t cageFace.vtx[2]`;
	float $pos3[]=`xform -q -ws -t ("lowerEyeOuter"+$numEye)`;
	
	xform -ws -t 0 $pos[1] $pos3[2] $lattice;
	xform -ws -t 0 $pos[1] $pos3[2] $latticeBase;
	setAttr -type float3 ($lattice+".s") ($cheekPos[0]*3) (($pos2[1]-$pos[1])*3) (($pos2[1]-$pos[1])*3);
	setAttr -type float3 ($latticeBase+".s") ($cheekPos[0]*3) (($pos2[1]-$pos[1])*3) (($pos2[1]-$pos[1])*3);

	if ($side=="_R")
		select -r ($lattice+".pt[7:14][1:3][1]");
	else 
		select -r ($lattice+".pt[0:7][1:3][1]");
	scale -r -ocp 1 0.2 1 ;
	move -r 0 0 ($cheekPos[0]*-0.05) ;
	}
}

global proc asFaceLimitWrapByBB ()
{
float $cageHeadBB[]=`xform -q -bb cageHead`;
float $cageFaceBB[]=`xform -q -bb cageFace`;
float $cageFaceBBxPlus20=$cageFaceBB[0]+$cageFaceBB[0]/5.0;
string $geometry=`textField -q -tx asFsGeometryTextField`;
string $wrap;
string $history[]=`listHistory -lv 1 $geometry`;
for ($i=0;$i<size($history);$i++)
    if (`objectType $history[$i]`=="wrap")
        $wrap=$history[$i];
string $connections[]=`listConnections ($wrap+".message")`;
string $wrapSet=$connections[0];
int $tempInts[]=`polyEvaluate -v $geometry`;
int $numVtx=$tempInts[0];
float $pos[3];
select -cl;
for ($i=0;$i<$numVtx;$i++)
    {
    $pos=`xform -q -ws -t ($geometry+".vtx["+$i+"]")`;
    if ($pos[1]<$cageHeadBB[1])
        select -add ($geometry+".vtx["+$i+"]");
    if (abs($pos[0])>abs($cageFaceBBxPlus20))
        select -add ($geometry+".vtx["+$i+"]");
    }
if (size(`ls -sl`))
    sets -rm $wrapSet;
}

global proc asFaceJawNeckBlendCage ()
{
polyPlane -n jawNeckBlend_R -w 1 -h 1 -sx 8 -sy 1 -ax 0 1 0 -cuv 2 -ch 0;
float $pos[];
$pos=`xform -q -ws -t PcageCheek.vtx[4]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[9];
$pos=`xform -q -ws -t PcageCheek.vtx[3]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[10];
$pos=`xform -q -ws -t PcageCheek.vtx[2]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[11];
$pos=`xform -q -ws -t PcageCheek.vtx[1]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[12];
$pos=`xform -q -ws -t PcageCheek.vtx[0]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[13];
$pos=`xform -q -ws -t PcageMouth.vtx[15]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[14];
$pos=`xform -q -ws -t PcageMouth.vtx[14]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[15];
$pos=`xform -q -ws -t PcageMouth.vtx[13]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[16];
$pos=`xform -q -ws -t PcageMouth.vtx[12]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[17];

$pos=`xform -q -ws -t cageHead.vtx[15]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[0];
$pos=`xform -q -ws -t cageHead.vtx[15]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[1];
$pos=`xform -q -ws -t cageHead.vtx[19]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[2];
$pos=`xform -q -ws -t cageHead.vtx[19]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[3];
$pos=`xform -q -ws -t cageHead.vtx[19]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[4];
$pos=`xform -q -ws -t cageHead.vtx[19]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[5];
$pos=`xform -q -ws -t cageHead.vtx[21 ]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[6];
$pos=`xform -q -ws -t cageHead.vtx[21 ]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[7];
$pos=`xform -q -ws -t cageHead.vtx[21 ]`;xform -ws -t $pos[0] $pos[1] $pos[2] jawNeckBlend_R.vtx[8];

parent jawNeckBlend_R PcageGroup_R;
duplicate -n jawNeckBlend_L jawNeckBlend_R;
parent jawNeckBlend_L PcageGroup_L;
setAttr jawNeckBlend_L.ry 0;
setAttr jawNeckBlend_L.sz 1;

string $side;
for ($a=0;$a<2;$a++)
	{
	if ($a==0)	$side="_R";
	if ($a==1)	$side="_L";
/*
	deformer -type wrap ("jawNeckBlend"+$side);
	select -r ("jawNeckBlend"+$side) ("PcageCheek"+$side);
	AddWrapInfluence;
*/
	select -r ("jawNeckBlend"+$side) ("PcageCheek"+$side);
	CreateWrap;

	$tempString=`listRelatives -ni -s ("jawNeckBlend"+$side)`;
	$tempString=`listConnections ($tempString[0]+".inMesh")`;
	$wrap=$tempString[0];	
	setAttr ($wrap+".autoWeightThreshold") 0;
	setAttr ($wrap+".exclusiveBind") 0;
	setAttr ($wrap+".maxDistance") 0.001;
	}
}

global proc asFaceBsSdkSetup ()
{
int $cageFace=`objExists PcageGroup`;
string $jawControl=`textField -q -tx asFsJawControlTextField`;
float $scale=`asFaceGetScale`;
string $eyeControl;
string $side;
for ($a=0;$a<2;$a++)
	{
	if ($a==0)	$side="_R";
	if ($a==1)	$side="_L";
	if($cageFace)
		{
		asFaceBsSdk ("ctrlBrow"+$side+".ty")  1 ("asFaceBS.brow_raiser"+$side) 1;
		asFaceBsSdk ("ctrlBrow"+$side+".ty") -1 ("asFaceBS.brow_lowerer"+$side) 1;
		asFaceBsSdk ("ctrlBrow"+$side+".tx") -1 ("asFaceBS.brow_innerLowerer"+$side) 1;
		asFaceBsSdk ("ctrlBrow"+$side+".tx")  1 ("asFaceBS.brow_innerRaiser"+$side) 1;
		if (!`attributeExists squeeze ("ctrlBrow"+$side)`)
			addAttr -ln "squeeze"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlBrow"+$side);
		asFaceBsSdk ("ctrlBrow"+$side+".squeeze") 10 ("asFaceBS.brow_squeeze"+$side) 1;
		if (!`attributeExists outerUpDown ("ctrlBrow"+$side)`)
			addAttr -ln "outerUpDown"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlBrow"+$side);
		asFaceBsSdk ("ctrlBrow"+$side+".outerUpDown") 10 ("asFaceBS.brow_outerRaiser"+$side) 1;
		asFaceBsSdk ("ctrlBrow"+$side+".outerUpDown") -10 ("asFaceBS.brow_outerLowerer"+$side) 1;
		}

	asFaceBsSdk ("ctrlMouth_M.ty") -1 ($jawControl+".rz") 30;

	$eyeControl=`textField -q -tx ("asFsEyeControl"+$side+"TextField")`;
	asFaceBsSdk ("ctrlEye"+$side+".tx") -1 ($eyeControl+".ry") -30;
	asFaceBsSdk ("ctrlEye"+$side+".tx") 1 ($eyeControl+".ry") 30;
	asFaceBsSdk ("ctrlEye"+$side+".ty") -1 ($eyeControl+".rz") -30;
	asFaceBsSdk ("ctrlEye"+$side+".ty") 1 ($eyeControl+".rz") 30;
	if (!`attributeExists blink ("ctrlEye"+$side)`)
		addAttr -ln "blink"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkCenter ("ctrlEye"+$side)`)
		addAttr -ln "blinkCenter" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists upperLidFollow ("ctrlEye"+$side)`)
		addAttr -ln "upperLidFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLidFollow ("ctrlEye"+$side)`)
		addAttr -ln "lowerLidFollow" -dv 3 -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if($cageFace)
		if (!`attributeExists squint ("ctrlEye"+$side)`)
			addAttr -ln "squint"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists pupil ("ctrlEye"+$side)`)
		addAttr -ln "pupil"  -k 1 -dv 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if($cageFace)
		asFaceBsSdk ("ctrlEye"+$side+".squint") 10 ("asFaceBS.eye_shut"+$side) 1;
	if (`objExists EyeSetup`)
		{
		asFaceBsSdk ("ctrlEye"+$side+".blink") 10 ("EyeSetup.blink"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".blink") -10 ("EyeSetup.blink"+$side) -1;
		asFaceBsSdk ("ctrlEye"+$side+".blinkCenter") 10 ("EyeSetup.blinkCenter"+$side) 1;
		setAttr ("ctrlEye"+$side+".blinkCenter") 0.2;
		setAttr ("EyeSetup.upperLidFollow"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLidFollow") 10 ("EyeSetup.upperLidFollow"+$side) 1;
		setAttr ("ctrlEye"+$side+".upperLidFollow") 10;
		setAttr ("EyeSetup.lowerLidFollow"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLidFollow") 10 ("EyeSetup.lowerLidFollow"+$side) 1;
		setAttr ("ctrlEye"+$side+".lowerLidFollow") 10;
		}
	if($cageFace)
		{
		asFaceBsSdk ("ctrlCheek"+$side+".ty") 1 ("asFaceBS.cheek_raiser"+$side) 1;
		asFaceBsSdk ("ctrlCheek"+$side+".tx") -1 ("asFaceBS.cheek_suck"+$side) 1;
		asFaceBsSdk ("ctrlCheek"+$side+".tx") 1 ("asFaceBS.cheek_puff"+$side) 1;
	
		asFaceBsSdk ("ctrlNose"+$side+".tx") -1 ("asFaceBS.nose_compressor"+$side) 1;
		asFaceBsSdk ("ctrlNose"+$side+".tx") 1 ("asFaceBS.nose_dilator"+$side) 1;
		asFaceBsSdk ("ctrlNose"+$side+".ty") 1 ("asFaceBS.nose_wrinkler"+$side) 1;
		if (!`attributeExists furrowDeepener ("ctrlNose"+$side)`)
			addAttr -ln "furrowDeepener"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlNose"+$side);
		asFaceBsSdk ("ctrlNose"+$side+".furrowDeepener") 10 ("asFaceBS.nose_furrowDeepener"+$side) 1;
		}
	}
if($cageFace)
	{
	asFaceBsSdk ctrlMouth_M.ty -1 asFaceBS.jaw_open_C 1;
	asFaceBsSdk ctrlMouth_M.tx -1 asFaceBS.mouth_oo_C 1;
	asFaceBsSdk ctrlMouth_M.tx 1 asFaceBS.mouth_wide_C 1;
	}

if($cageFace)
	{
	if (!`attributeExists JAW ctrlMouth_M`)
		addAttr -k 0 -ln "JAW" -at "double" ctrlMouth_M;setAttr -l 1 -cb 1 ctrlMouth_M.JAW;
	if (!`attributeExists jawSide ctrlMouth_M`)
		addAttr -ln "jawSide"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.jawSide 10 ($jawControl+".tz") ($scale/3.0);
	asFaceBsSdk ctrlMouth_M.jawSide -10 ($jawControl+".tz") ($scale/-3.0);	

	if (!`attributeExists jawForward ctrlMouth_M`)
		addAttr -ln "jawForward"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.jawForward 10 ($jawControl+".tx") ($scale/3.0);
	asFaceBsSdk ctrlMouth_M.jawForward -10 ($jawControl+".tx") ($scale/-3.0);
	if (!`attributeExists jawShut ctrlMouth_M`)
		addAttr -ln "jawShut"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.jawShut 10 asFaceBS.jaw_shut_C 1;
	
	if (!`attributeExists CHIN ctrlMouth_M`)
		addAttr -k 0 -ln "CHIN" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.CHIN;
	if (!`attributeExists chinRaiser ctrlMouth_M`)
		addAttr -ln "chinRaiser"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.chinRaiser 10 asFaceBS.chin_raiser_C 1;
	
	if (!`attributeExists NARROW ctrlMouth_M`)
		addAttr -k 0 -ln "NARROW" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.NARROW;
	if (!`attributeExists oh ctrlMouth_M`)
		addAttr -ln "oh"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.oh 10 asFaceBS.mouth_oh_C 1;
	if (!`attributeExists pucker ctrlMouth_M`)
		addAttr -ln "pucker"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.pucker 10 asFaceBS.mouth_pucker_C 1;
	if (!`attributeExists funnel ctrlMouth_M`)
		addAttr -ln "funnel"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.funnel 10 asFaceBS.mouth_funneler_C 1;
	
	if (!`attributeExists LIP_PRESS ctrlMouth_M`)
		addAttr -k 0 -ln "LIP_PRESS" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.LIP_PRESS;
	if (!`attributeExists lipPress_R ctrlMouth_M`)
		addAttr -ln "lipPress_R"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	if (!`attributeExists lipPress_L ctrlMouth_M`)
		addAttr -ln "lipPress_L"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.lipPress_R 10 asFaceBS.mouth_presser_R 1;
	asFaceBsSdk ctrlMouth_M.lipPress_L 10 asFaceBS.mouth_presser_L 1;

	if (!`attributeExists LIP_ROLL ctrlMouth_M`)
		addAttr -k 0 -ln "LIP_ROLL" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.LIP_ROLL;
	if (!`attributeExists lipUpperRoll_R ctrlMouth_M`)
		addAttr -ln "lipUpperRoll_R"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.lipUpperRoll_R 10 asFaceBS.mouth_rollOutUpper_R 1;
	asFaceBsSdk ctrlMouth_M.lipUpperRoll_R -10 asFaceBS.mouth_rollInUpper_R 1;
	if (!`attributeExists lipUpperRoll_L ctrlMouth_M`)
		addAttr -ln "lipUpperRoll_L"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.lipUpperRoll_L 10 asFaceBS.mouth_rollOutUpper_L 1;
	asFaceBsSdk ctrlMouth_M.lipUpperRoll_L -10 asFaceBS.mouth_rollInUpper_L 1;
	if (!`attributeExists lipLowerRoll_R ctrlMouth_M`)
		addAttr -ln "lipLowerRoll_R"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.lipLowerRoll_R 10 asFaceBS.mouth_rollOutLower_R 1;
	asFaceBsSdk ctrlMouth_M.lipLowerRoll_R -10 asFaceBS.mouth_rollInLower_R 1;
	if (!`attributeExists lipLowerRoll_L ctrlMouth_M`)
		addAttr -ln "lipLowerRoll_L"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.lipLowerRoll_L 10 asFaceBS.mouth_rollOutLower_L 1;
	asFaceBsSdk ctrlMouth_M.lipLowerRoll_L -10 asFaceBS.mouth_rollInLower_L 1;
	}


if($cageFace)
	for ($a=0;$a<2;$a++)
		{
		if ($a==0)	$side="_R";
		if ($a==1)	$side="_L";
		asFaceBsSdk ("ctrlMouthCorner"+$side+".tx") 1 ("asFaceBS.mouth_puckerAnti"+$side) 1;
		asFaceBsSdk ("ctrlMouthCorner"+$side+".tx") -1 ("asFaceBS.mouth_pucker"+$side) 1;
		asFaceBsSdk ("ctrlMouthCorner"+$side+".ty") 1 ("asFaceBS.mouth_smile"+$side) 1;
		asFaceBsSdk ("ctrlMouthCorner"+$side+".ty") -1 ("asFaceBS.mouth_frown"+$side) 1;
		if (!`attributeExists dimpler ("ctrlMouthCorner"+$side)`)
			addAttr -ln "dimpler"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlMouthCorner"+$side);
		asFaceBsSdk ("ctrlMouthCorner"+$side+".dimpler") 10 ("asFaceBS.mouth_dimpler"+$side) 1;
		if (!`attributeExists stretcher ("ctrlMouthCorner"+$side)`)
			addAttr -ln "stretcher"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlMouthCorner"+$side);
		asFaceBsSdk ("ctrlMouthCorner"+$side+".stretcher") 10 ("asFaceBS.mouth_stretcher"+$side) 1;
		}

string $tempString[];
string $axis,$connectTo;
for ($i=0;$i<3;$i++)
	{
	if ($i==0) $axis="X";
	if ($i==1) $axis="Y";
	if ($i==2) $axis="Z";
	for ($y=1;$y<4;$y++)
		{
		if (!`attributeExists ("rot"+$axis+$y) ctrlTongue_M`)
			addAttr -ln ("rot"+$axis+$y) -k 1 ctrlTongue_M;
		if (!`objExists ("faceRigTongue"+$y+"_M")`)
			continue;
		$connectTo="faceRigTongue"+$y+"_M.r"+`tolower $axis`;
		$tempString=`listConnections $connectTo`;
		if (!size($tempString))
			connectAttr ("ctrlTongue_M.rot"+$axis+$y) $connectTo;
		}
	}
for ($i=0;$i<3;$i++)
	{
	if ($i==0) $axis="X";
	if ($i==1) $axis="Y";
	if ($i==2) $axis="Z";
	if (!`attributeExists ("size"+$axis) ctrlTongue_M`)
		addAttr -ln ("size"+$axis) -dv 1 -k 1 ctrlTongue_M;
	for ($y=1;$y<4;$y++)
		{
		if (!`objExists ("faceRigTongue"+$y+"_M")`)
			continue;
		$connectTo="faceRigTongue"+$y+"_M.s"+`tolower $axis`;
		$tempString=`listConnections $connectTo`;
		if (!size($tempString))
			connectAttr ("ctrlTongue_M.size"+$axis) ($connectTo);
		}
	}

//pre post infinity
select `listRelatives -type transform -c ctrlBox`;
select `listRelatives -type transform -c`;
string $nodes[]=`listConnections -s 0 -d 1`;
for ($i=0;$i<size($nodes);$i++)
	{
	$tempString=`nodeType -inherited $nodes[$i]`;
	if ($tempString[0]=="animCurve")
		{
		setAttr ($nodes[$i]+".preInfinity") 1;
		setAttr ($nodes[$i]+".postInfinity") 1;
        $tempFloat=`keyframe -q -fc $nodes[$i]`;
        if ($tempFloat[0]==0.0)
		    setAttr ($nodes[$i]+".preInfinity") 0;
		if ($tempFloat[size($tempFloat)-1]==0.0)
		    setAttr ($nodes[$i]+".postInfinity") 0;
		}
	}
select -cl;
}

global proc asFaceBsSdk (string $ctrl, float $driveValue, string $bs, float $drivenValue)
{
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl $driveValue;
setAttr $bs $drivenValue;
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl 0;
if ($driveValue>0)
	keyTangent -in 0 -itt linear -ott linear $bs;
}

global proc asFaceCtrlBox ()
{
if (`objExists ctrlBoxOffset`)
	delete ctrlBoxOffset;
string $headJoint=`textField -q -tx asFsHeadJointTextField`;
float $scale=`asFaceGetScale`;
float $cheekOuterPos[]=`xform -q -ws -t cheekOuter`;
float $upperEyeOuter1Pos[]=`xform -q -ws -t upperEyeOuter1`;
int $cageFace=`objExists PcageGroup`;
string $tempString[];

$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBox;
createNode -n ctrlBoxOffset transform;
parent ctrlBox ctrlBoxOffset;
parent ctrlBoxOffset FaceMotionSystem;
//editDisplayLayerMembers -noRecurse faceCtrlA ctrlBox;
parentConstraint -mo $headJoint ctrlBoxOffset;
scaleConstraint -mo $headJoint ctrlBoxOffset;
addAttr -k 1 -ln "limits" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "ACtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.ACtrlVis EyeSetup.ACtrlVis;
addAttr -k 1 -ln "BCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.BCtrlVis EyeSetup.BCtrlVis;
addAttr -k 1 -ln "CCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.CCtrlVis EyeSetup.CCtrlVis;
addAttr -k 1 -ln "SquashCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.SquashCtrlVis EyeSetup.SquashCtrlVis;
setAttr ctrlBoxShape.overrideEnabled 1;
setAttr ctrlBoxShape.overrideColor 17;

//Expand length down
move -r 0 -0.4 0 ctrlBoxShape.cv[2:3];

xform -ws -t ($cheekOuterPos[0]*-2) $cheekOuterPos[1] $upperEyeOuter1Pos[2] ctrlBox;
xform -s ($scale/2.0) $scale ($scale/2.0) ctrlBox;
makeIdentity -a 1 -t 0 -r 0 -s 1 ctrlBox;

//ctrlBoxTemplate
$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBoxTemplate;
parent ctrlBoxTemplate ctrlBox;
setAttr -type float3 ctrlBoxTemplate.t 0 0 0;
setAttr -type float3 ctrlBoxTemplate.s ($scale/6.0) ($scale/6.0) ($scale/6.0);
setAttr ctrlBoxTemplateShape.overrideEnabled 1;
setAttr ctrlBoxTemplateShape.overrideDisplayType 1;

//ctrlTemplate
duplicate -n ctrlTemplate ctrlBoxTemplate;
parent ctrlTemplate ctrlBoxTemplate;
transformLimits -tx -1 1 -ty -1 1 -tz 0 0 -etx 1 1 -ety 1 1 -etz 1 1 ctrlTemplate;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransYLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransYLimitEnable`);
setAttr ctrlTemplateShape.overrideDisplayType 0;
setAttr ctrlTemplate.rz 45;
setAttr -type float3 ctrlTemplate.s 0.2 0.2 0.2;
setAttr ctrlTemplateShape.overrideColor 17;
makeIdentity -a 1 -t 0 -r 1 -s 1 ctrlTemplate;
setAttr -l 1 -k 0 ctrlTemplate.tz;
setAttr -l 1 -k 0 ctrlTemplate.rx;
setAttr -l 1 -k 0 ctrlTemplate.ry;
setAttr -l 1 -k 0 ctrlTemplate.rz;
setAttr -l 1 -k 0 ctrlTemplate.sx;
setAttr -l 1 -k 0 ctrlTemplate.sy;
setAttr -l 1 -k 0 ctrlTemplate.sz;
setAttr -l 1 -k 0 ctrlTemplate.v;
sets -add FaceControlSet ctrlTemplate;

asFaceCreateCtrlBox "Brow_R" ($scale*-0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Brow_L" ($scale*0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Eye_R" ($scale*-0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Eye_L" ($scale*0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Cheek_R" ($scale*-0.25) 0 1;
asFaceCreateCtrlBox "Cheek_L" ($scale*0.25) 0 1;
asFaceCreateCtrlBox "Nose_R" ($scale*-0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Nose_L" ($scale*0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Mouth_M" 0 ($scale*-0.4) 2;
asFaceCreateCtrlBox "MouthCorner_R" ($scale*-0.25) ($scale*-1) 0;
asFaceCreateCtrlBox "MouthCorner_L" ($scale*0.25) ($scale*-1) 0;
scale -r 2 2 2 ctrlBoxMouth_M;
asFaceCreateCtrlBox "Tongue_M" 0 ($scale*-1.3) 2;
setAttr "ctrlBoxTongue_MShape.overrideVisibility" 0;
setAttr -l 1 -k 0 ctrlTongue_M.tx;
setAttr -l 1 -k 0 ctrlTongue_M.ty;
/*
if (`objExists squashBase` && `objExists squashTop`)
	{
	asFaceCreateCtrlBox "Squash_M" 0 ($scale*-1.2) 2;
	setAttr "ctrlBoxSquash_MShape.overrideVisibility" 0;
	setAttr -l 1 -k 0 ctrlSquash_M.tx;
	setAttr -l 1 -k 0 ctrlSquash_M.ty;
	addAttr -k 1 -dv 0 -ln factor -at double ctrlSquash_M;
	connectAttr ctrlSquash_M.factor squashHead.factor;
	addAttr -k 1 -dv 0 -ln startPos -at double ctrlSquash_M;
	connectAttr ctrlSquash_M.startPos squashHeadHandle.ty;
	addAttr -k 1 -dv 1 -ln size -at double ctrlSquash_M;
	connectAttr ctrlSquash_M.size squashHeadHandle.sy;
	}
*/
//tweak pos/scale ob bigbox
xform -ws -t ($cheekOuterPos[0]*-1.5) $cheekOuterPos[1] $upperEyeOuter1Pos[2] ctrlBox;
xform -s 1.5 1.5 1.5 ctrlBox;

if (!$cageFace)
	{
	string $ctrls[]=`listRelatives -type transform -c ctrlBox`;
	for ($i=0;$i<size($ctrls);$i++)
		if (!`gmatch $ctrls[$i] "ctrlBoxEye_*"`)
		    setAttr ($ctrls[$i]+".v") 0;
	setAttr ctrlBoxMouth_M.v 1;
	if (`objExists faceRigTongue0_M`)
		setAttr ctrlBoxTongue_M.v 1;
	}

delete ctrlBoxTemplate;
}

global proc asFaceCreateCtrlBox (string $name, float $x, float $y, int $half)
{
$tempString=`duplicate -rc ctrlBoxTemplate`;
rename $tempString[0] ("ctrlBox"+$name);
rename $tempString[1] ("ctrl"+$name);
setAttr -type float3 ("ctrlBox"+$name+".t") $x $y 0;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransYLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransYLimitEnable")`);

if ($half)
	{
	float $pos0[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[0]")`;
	float $pos2[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[2]")`;
	float $pos3[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[3]")`;
	if ($half==1)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[2]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos3[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[3]");
		transformLimits -tx -1 1 -ty 0 1 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	if ($half==2)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[1]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[0]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[4]");
		transformLimits -tx -1 1 -ty -1 0 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	}
}

global proc asFaceBakeShapes ()
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
int $center;
string $tempString[];

if (`checkBox -q -v asFaceKeepBlendShapes` && `objExists asFaceBS`)
	{
	createNode -n keepTweakedBlendShapes transform;
	setAttr keepTweakedBlendShapes.v 0;
	string $udas[]=`listAttr -ud FaceFitSkeleton`;
	string $keepShps[];
	for ($i=0;$i<size($udas);$i++)
		{
		if (`gmatch $udas[$i] "*_tweaked"`)
			if (`getAttr ("FaceFitSkeleton."+$udas[$i])`)
				$keepShps[size($keepShps)]=`substitute "_tweaked" $udas[$i] ""`;
		}
	for ($i=0;$i<size($keepShps);$i++)
		{
		setAttr ("asFaceBS."+$keepShps[$i]) 1;
		duplicate -n ($keepShps[$i]+"_tweaked") $geometry;
		parent ($keepShps[$i]+"_tweaked") keepTweakedBlendShapes;
		setAttr ("asFaceBS."+$keepShps[$i]) 0;
		}
	}

createNode -n faceTargets transform;
parent faceTargets cageTempGroup;
setAttr faceTargets.v 0;
string $bs="cageBlendShape";
string $bs1="cageBlendShape1";
string $skipShapes[]={"jaw_forward_C","jaw_back_C","jaw_side_R","mouth_lowerLipForward_R","mouth_lowerLipLowerer_C",
	"mouth_lowerLipLowerer_R","mouth_lowerLipRaiser_C","mouth_lowerLipRaiser_R",
	"mouth_thinLower_R","mouth_thinUpper_R","mouth_upperLipBack_R","mouth_upperLipForward_R",
	"mouth_upperLipLowerer_C","mouth_upperLipLowerer_R","mouth_upperLipRaiser_C",
	"mouth_upperLipRaiser_R","mouth_up_R"};
string $carryLipsShapes[]={"cheek_puff_R","cheek_suck_R","nose_wrinkler_R"};
string $shps[]=`listAttr -m ($bs+".weight")`;
string $tempWraps[];
for ($i=0;$i<size($shps);$i++)
//for ($i=0;$i<2;$i++)
	{
	if ($shps[$i]=="blank") continue;
	if (`stringArrayCount $shps[$i] $skipShapes`) continue;
	if (`stringArrayCount $shps[$i] $carryLipsShapes`)
		{
		select -r upperGlips_R PcageMouth_R;CreateWrap;
    $tempString=`listRelatives -ni -s upperGlips_R`;
    $tempString=`listConnections ($tempString[0]+".inMesh")`;
    $tempWraps[size($tempWraps)]=$tempString[0];
		select -r lowerGlips_R PcageMouth_R;CreateWrap;
    $tempString=`listRelatives -ni -s lowerGlips_R`;
    $tempString=`listConnections ($tempString[0]+".inMesh")`;
    $tempWraps[size($tempWraps)]=$tempString[0];
		}
	tokenize $shps[$i] "_" $tempString;
    $target=$tempString[0]+"_"+$tempString[1]+"_"+$tempString[2];
    $center=0;
	if ($tempString[2]=="C") $center=1;
	setAttr ($bs+"."+$shps[$i]) 1;
	if ($center)
		asFaceMirrorCage 0;
	duplicate -rr -n $target $geometry; refresh;
	parent $target faceTargets;
	setAttr ($bs+"."+$shps[$i]) 0;
	if ($center) 
		asFaceMirrorCage 0;

	//_L
	if (!$center)
		{
		$mirrorTarget=$tempString[0]+"_"+$tempString[1]+"_L";
		setAttr ($bs+"."+$shps[$i]) 1;
		asFaceMirrorCage 1;
		if (`stringArrayCount $shps[$i] $carryLipsShapes`)
			{
			setAttr "FlipTempPcageMouthBlendShape_L.FlipTempPcageMouth_L" 0;
			select -r upperGlips_L PcageMouth_L;CreateWrap;
	    $tempString=`listRelatives -ni -s upperGlips_L`;
	    $tempString=`listConnections ($tempString[0]+".inMesh")`;
	    $tempWraps[size($tempWraps)]=$tempString[0];
			select -r lowerGlips_L PcageMouth_L;CreateWrap;
	    $tempString=`listRelatives -ni -s lowerGlips_L`;
	    $tempString=`listConnections ($tempString[0]+".inMesh")`;
	    $tempWraps[size($tempWraps)]=$tempString[0];
			setAttr "FlipTempPcageMouthBlendShape_L.FlipTempPcageMouth_L" 1;
			}
		duplicate -rr -n $mirrorTarget $geometry;
		parent $mirrorTarget faceTargets;
		setAttr ($bs+"."+$shps[$i]) 0;
		delete `ls "FlipTemp*"`;
		}
	if (`stringArrayCount $shps[$i] $carryLipsShapes`)
		{
		delete $tempWraps;
		clear $tempWraps;
		}
	}


if (`checkBox -q -v asFaceKeepBlendShapes` && `objExists keepTweakedBlendShapes`)
	{
	string $shps[];
	string $keepShpsXforms[]=`listRelatives -c keepTweakedBlendShapes`;
	for ($i=0;$i<size($keepShpsXforms);$i++)
		$shps[size($shps)]=`substitute "_tweaked" $keepShpsXforms[$i] ""`;
	for ($i=0;$i<size($shps);$i++)
		connectAttr ($shps[$i]+"_tweaked.outMesh") ($shps[$i]+".inMesh");
	}
}

global proc asFaceMirrorCage (int $flip)
{
string $cageMshs[]={"PcageMouthUpper","PcageMouthLower","PcageForeHead","PcageNose","PcageCheek","PcageMouth","upperGlips","lowerGlips"};
int $tempInts[];
int $numVtx;
float $pos[],$pos1[];
string $mesh;
string $tempString[];
for ($i=0;$i<size($cageMshs);$i++)
	{
	if ($flip)
		{
		duplicate -n ("FlipTemp"+$cageMshs[$i]+"_R") ($cageMshs[$i]+"_R");
		duplicate -n ("FlipTemp"+$cageMshs[$i]+"_L") ($cageMshs[$i]+"_L");
		}
	$tempString=`listRelatives -ni -s ($cageMshs[$i]+"_R")`;
	$mesh=$tempString[0];
	$tempInts=`polyEvaluate -v $mesh`;
	$numVtx=$tempInts[0];
	for ($y=0;$y<$numVtx;$y++)
	    {
	    $pos=`xform -q -ws -t ($cageMshs[$i]+"_R.vtx["+$y+"]")`;
	    if ($flip)
	    	{
		    $pos1=`xform -q -ws -t ($cageMshs[$i]+"_L.vtx["+$y+"]")`;
	    	xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] ("FlipTemp"+$cageMshs[$i]+"_L.vtx["+$y+"]");
		    xform -ws -t ($pos1[0]*-1) $pos1[1] $pos1[2] ("FlipTemp"+$cageMshs[$i]+"_R.vtx["+$y+"]");
	    	}
	    else
		    xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] ($cageMshs[$i]+"_L.vtx["+$y+"]");
	    }
    if ($flip)
        {
        select -r ("FlipTemp"+$cageMshs[$i]+"_R") ($cageMshs[$i]+"_R");
        $tempString=`blendShape`;
        rename $tempString[0] ("FlipTemp"+$cageMshs[$i]+"BlendShape_R");
        setAttr ("FlipTemp"+$cageMshs[$i]+"BlendShape_R.FlipTemp"+$cageMshs[$i]+"_R") 1;

        select -r ("FlipTemp"+$cageMshs[$i]+"_L") ($cageMshs[$i]+"_L");
        $tempString=`blendShape`;
        rename $tempString[0] ("FlipTemp"+$cageMshs[$i]+"BlendShape_L");
        setAttr ("FlipTemp"+$cageMshs[$i]+"BlendShape_L.FlipTemp"+$cageMshs[$i]+"_L") 1;
        }
	}
}

global proc asFaceAddInfluenceSphere ()
{
float $scale=`asFaceGetScale`;
if (!`objExists cageLambertSG`)
	return;
string $tempString[]=`polySphere -n faceCageInfluence -r $scale -sx 10 -sy 6 -ax 0 1 0 -cuv 2 -ch 1`;
sets -e -forceElement cageLambertSG $tempString[0];
float $cheekOuterPos[]=`xform -q -ws -t cheekOuter`;
xform -ws -t ($cheekOuterPos[0]*1.5) $cheekOuterPos[1] $cheekOuterPos[2] $tempString[0];
parent $tempString[0] FaceFitSkeleton;
}

global proc asFaceAddInfluencePlane (int $followJaw)
{
float $scale=`asFaceGetScale`;
if (!`objExists cageLambertSG`)
	return;
string $name="faceCageInfluence";
if ($followJaw)
	$name="faceCageInfluenceJaw";
string $tempString[]=`polyPlane -n $name -w $scale -h $scale -sx 1 -sy 1 -ax 0 1 0 -cuv 2 -ch 1`;
sets -e -forceElement cageLambertSG $tempString[0];
float $cheekOuterPos[]=`xform -q -ws -t cheekOuter`;
xform -ws -t 0 $cheekOuterPos[1] $cheekOuterPos[2] $tempString[0];
if ($followJaw)
	move -r 0 (-1*$scale) 0 $tempString[0];
parent $tempString[0] FaceFitSkeleton;
}

global proc asFaceAddInfluenceEyeLid ()
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
if (`objExists faceCageInfluenceEyeLid`)
    return;
duplicate -n faceCageInfluenceEyeLid $geometry;
parent faceCageInfluenceEyeLid FaceFitSkeleton;
string $temString[]=`listRelatives -s faceCageInfluenceEyeLid`;
for ($shape in $temString)
    if (`getAttr ($shape+".intermediateObject")`)
        delete $shape;
sets -e -forceElement cageLambertSG faceCageInfluenceEyeLid;
select `ls -type joint "upperEyeInner*" "lowerEyeInner*"`;
select -d `ls -type joint "upperEyeInner*_*" "lowerEyeInner*_*"`;
asFaceSelectVtxFromJoint faceCageInfluenceEyeLid;
ConvertSelectionToFaces;
string $sel[]=`ls -sl`;
select -r faceCageInfluenceEyeLid.f[0:99999];
select -d $sel;
delete;
float $scale=`asFaceGetScale`;
move -r -os -wd 0 0 ($scale/30.0) faceCageInfluenceEyeLid;
}

global proc asFaceHeadCage ()
{
setAttr "cageHead.visibility" 1;
select cageHead;
}


global proc asFaceSelectVtxFromJoint (string $geometry)
{
string $selJoints[]=`ls -sl`;
string $tempString[],$vtxs[];
clear $vtxs;
float $pos[];
select $geometry;
for ($i=0;$i<size($selJoints);$i++)
    {
    $pos=`xform -q -ws -t $selJoints[$i]`;
    polySelectConstraint -m 3 -t 1 -d 1 -db 0 0.0001 -dp $pos[0] $pos[1] $pos[2];
    $tempString=`ls -sl -fl`;
    if ($tempString[0]=="")
    	;//warning ("Not found vtx near:"+$selJoints[$i]);
    else
        $vtxs[size($vtxs)]=$tempString[0];
    polySelectConstraint -m 0;
    }
select $vtxs;
}

global proc asFaceSelectVtxFromJointWithMirrored (string $geometry)
{
string $selJoints[]=`ls -sl`;
string $tempString[],$vtxs[];
float $pos[];
select $geometry;
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($selJoints);$i++)
	    {
	    $pos=`xform -q -ws -t $selJoints[$i]`;
	    polySelectConstraint -m 3 -t 1 -d 1 -db 0 0.0001 -dp ($pos[0]*$b) $pos[1] $pos[2];
	    $tempString=`ls -sl -fl`;
	    if ($tempString[0]=="")
  	  	;//warning ("Not found vtx near:"+$selJoints[$i]);
  	  else
		    $vtxs[size($vtxs)]=$tempString[0];
	    polySelectConstraint -m 0;
	    }
select $vtxs;
}

global proc asAverageInbetweenVerts (string $cage)
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
float $scale=`asFaceGetScale`;
string $tempString[],$tempString2[];
string $anchors[]=`listRelatives -c cageLevelAGroup`;
string $locAtVert;
int $tempInts[]=`polyEvaluate -v $cage`;
int $numVerts=$tempInts[0];
int $chillVtnr[];
clear $chillVtnr;
float $mag;
float $pos[];
duplicate -n ($cage+"2")  $cage;
for ($i=0;$i<$numVerts+1;$i++)
    {
    $tempString=`listConnections ($cage+".pnts["+$i+"]")`;
    if (!`size($tempString)`)
        $chillVtnr[size($chillVtnr)]=$i;
    }
select -cl;
for ($i=0;$i<size($chillVtnr);$i++)
     select -add ($cage+"2.pnts["+$chillVtnr[$i]+"]");
for ($i=0;$i<31;$i++)
    polyAverageVertex -i 10;

for ($i=0;$i<size($chillVtnr);$i++)
    {
    $pos=`xform -q -ws -t ($cage+"2.pnts["+$chillVtnr[$i]+"]")`;
    xform -ws -t $pos[0] $pos[1] $pos[2] ($cage+".pnts["+$chillVtnr[$i]+"]");
    }
delete ($cage+"2");
select -cl;
for ($i=0;$i<size($chillVtnr);$i++)
     select -add ($cage+".pnts["+$chillVtnr[$i]+"]");
$tempString=`newCluster (" -n "+$cage+"Cluster -envelope 1")`;
parent ($cage+"ClusterHandle") cageLevelCGroup;
select -cl;
for ($i=0;$i<size($chillVtnr);$i++)
     select -add ($cage+".pnts["+$chillVtnr[$i]+"]");
if ($cage=="cageForeHead")
    {select -tgl cageForeHead.vtx[3] ;select -tgl cageForeHead.vtx[1] ;select -tgl cageForeHead.vtx[4] ;}
for ($i=0;$i<3;$i++)
    polyAverageVertex -i 10;
}

global proc asVertSnapToPoint (string $trnA, string $trnB, string $cageMesh, int $vtxNr, float $weight)
{
string $geometry=`textField -q -tx asFsGeometryTextField`;
float $scale=`asFaceGetScale`;
float $pos[];
string $tempString[];
string $locPartial,$loc1;

if ($trnB!="")
    {
    $tempString=`spaceLocator -n ($cageMesh+"Partial_"+$vtxNr)`;
    $locPartial=$tempString[0];
    setAttr ($locPartial+"Shape.v") 0;
    pointConstraint -w $weight ($trnA+"_Loc") $locPartial;
    pointConstraint -w (1.0-$weight) ($trnB+"_Loc") $locPartial;

    $tempString=`spaceLocator -n ($cageMesh+"Loc_"+$vtxNr)`;
    $loc1=$tempString[0];
    parent $loc1 $locPartial cageLevelBGroup;
    $pos=`xform -q -ws -t $locPartial`;
    }
else
    {
    $loc1=$trnA+"_Loc";
    if (!`objExists $loc1`)
        {
        $tempString=`spaceLocator -n $loc1`;
        parent $loc1 cageLevelAGroup;
        }
    $pos=`xform -q -ws -t $trnA`;
    }
xform -ws -t $pos[0] $pos[1] $pos[2] $loc1;
setAttr -type float3 ($loc1+"Shape.localScale") ($scale/4.0) ($scale/4.0) ($scale/4.0);
string $tempString[]=`spaceLocator -n ($cageMesh+"_"+$vtxNr+"OnMesh")`;
string $loc2=$tempString[0];
parent $loc2 cageOnMesh;
string $pointOnMesh=`createNode -n ($cageMesh+"_"+$vtxNr+"PointOnMesh") closestPointOnMesh`;
connectAttr -f ($geometry+".worldMesh[0]") ($pointOnMesh+".inMesh");
connectAttr -f ($loc1+"Shape.worldPosition[0]") ($pointOnMesh+".inPosition");
connectAttr -f ($pointOnMesh+".position") ($loc2+".translate");
setAttr ($loc2+".v") 0;
connectAttr -f ($loc2+".t") ($cageMesh+".pnts["+$vtxNr+"]");
if ($trnB!="")
    parent $loc1 $locPartial;
}


global proc string[] asFaceCreateLipCurves ()
{
string $joint,$inOut,$cmd;
string $tempString[];
string $return[];
float $pos[];

for ($a=0;$a<7;$a++)
    {
    if ($a==0) $inOut="Outer";
    if ($a==1) $inOut="MiddleA";
    if ($a==2) $inOut="MiddleB";
    if ($a==3) $inOut="MiddleC";
    if ($a==4) $inOut="MiddleD";
    if ($a==5) $inOut="MiddleE";
    if ($a==6) $inOut="MiddleF";
    if (!`objExists ("upperLip"+$inOut+"0")`)
        continue;
    $cmd="curve -d 1 ";

		for ($i=0;$i<99;$i++)
		    if (!`objExists ("upperLip"+$inOut+$i)`)
		        break;
		$numLips=$i;

    for ($i=0;$i<$numLips;$i++)
        {
        $pos=`xform -q -ws -t ("upperLip"+$inOut+$i)`;
        $cmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
        }
    for ($i=$numLips-1;$i>-1;$i--)
        {
				if (!`objExists ("lowerLip"+$inOut+$i)`)
					continue;
        $pos=`xform -q -ws -t ("lowerLip"+$inOut+$i)`;
        $cmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
        }
    $cmd+="";
    $tempString[0]=`eval($cmd)`;
    rename $tempString[0] ("lipCurve"+$inOut);
    createNode -n ("lipCurve"+$inOut+"PointOnCurveInfo") pointOnCurveInfo;
    connectAttr -f ("lipCurve"+$inOut+"Shape.worldSpace[0]") ("lipCurve"+$inOut+"PointOnCurveInfo.inputCurve");
    setAttr ("lipCurve"+$inOut+"PointOnCurveInfo.turnOnPercentage") 1;
    $return[size($return)]=$inOut;
    }
return $return;
}